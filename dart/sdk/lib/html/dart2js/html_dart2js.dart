library html;

import 'dart:isolate';
import 'dart:json';
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated dart:html library.







LocalWindow get window => JS('LocalWindow', 'window');
_LocalWindowImpl get _window => JS('_LocalWindowImpl', 'window');

Document get document => JS('Document', 'document');

_DocumentImpl get _document => JS('_DocumentImpl', 'document');

Element query(String selector) => _document.query(selector);
List<Element> queryAll(String selector) => _document.queryAll(selector);

// Workaround for tags like <cite> that lack their own Element subclass --
// Dart issue 1990.
class _HTMLElementImpl extends _ElementImpl native "*HTMLElement" {
}

// Support for Send/ReceivePortSync.
int _getNewIsolateId() {
  if (JS('bool', r'!window.$dart$isolate$counter')) {
    JS('void', r'window.$dart$isolate$counter = 1');
  }
  return JS('int', r'window.$dart$isolate$counter++');
}

// Fast path to invoke JS send port.
_callPortSync(int id, message) {
  return JS('var', r'ReceivePortSync.dispatchCall(#, #)', id, message);
}

// TODO(vsm): Plumb this properly.
spawnDomFunction(f) => spawnFunction(f);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AbstractWorker
abstract class AbstractWorker implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  AbstractWorkerEvents get on;

  /** @domName AbstractWorker.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName AbstractWorker.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName AbstractWorker.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class AbstractWorkerEvents implements Events {

  EventListenerList get error;
}

class _AbstractWorkerImpl extends _EventTargetImpl implements AbstractWorker native "*AbstractWorker" {

  _AbstractWorkerEventsImpl get on =>
    new _AbstractWorkerEventsImpl(this);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _AbstractWorkerEventsImpl extends _EventsImpl implements AbstractWorkerEvents {
  _AbstractWorkerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error => this['error'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AnalyserNode
abstract class AnalyserNode implements AudioNode {

  /** @domName AnalyserNode.fftSize */
  int fftSize;

  /** @domName AnalyserNode.frequencyBinCount */
  int get frequencyBinCount;

  /** @domName AnalyserNode.maxDecibels */
  num maxDecibels;

  /** @domName AnalyserNode.minDecibels */
  num minDecibels;

  /** @domName AnalyserNode.smoothingTimeConstant */
  num smoothingTimeConstant;

  /** @domName AnalyserNode.getByteFrequencyData */
  void getByteFrequencyData(Uint8Array array);

  /** @domName AnalyserNode.getByteTimeDomainData */
  void getByteTimeDomainData(Uint8Array array);

  /** @domName AnalyserNode.getFloatFrequencyData */
  void getFloatFrequencyData(Float32Array array);
}

class _AnalyserNodeImpl extends _AudioNodeImpl implements AnalyserNode native "*AnalyserNode" {

  int fftSize;

  final int frequencyBinCount;

  num maxDecibels;

  num minDecibels;

  num smoothingTimeConstant;

  void getByteFrequencyData(_Uint8ArrayImpl array) native;

  void getByteTimeDomainData(_Uint8ArrayImpl array) native;

  void getFloatFrequencyData(_Float32ArrayImpl array) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAnchorElement
abstract class AnchorElement implements Element {

  factory AnchorElement({String href}) {
    if (!?href) {
      return _Elements.createAnchorElement();
    }
    return _Elements.createAnchorElement(href);
  }

  /** @domName HTMLAnchorElement.charset */
  String charset;

  /** @domName HTMLAnchorElement.coords */
  String coords;

  /** @domName HTMLAnchorElement.download */
  String download;

  /** @domName HTMLAnchorElement.hash */
  String hash;

  /** @domName HTMLAnchorElement.host */
  String host;

  /** @domName HTMLAnchorElement.hostname */
  String hostname;

  /** @domName HTMLAnchorElement.href */
  String href;

  /** @domName HTMLAnchorElement.hreflang */
  String hreflang;

  /** @domName HTMLAnchorElement.name */
  String name;

  /** @domName HTMLAnchorElement.origin */
  String get origin;

  /** @domName HTMLAnchorElement.pathname */
  String pathname;

  /** @domName HTMLAnchorElement.ping */
  String ping;

  /** @domName HTMLAnchorElement.port */
  String port;

  /** @domName HTMLAnchorElement.protocol */
  String protocol;

  /** @domName HTMLAnchorElement.rel */
  String rel;

  /** @domName HTMLAnchorElement.rev */
  String rev;

  /** @domName HTMLAnchorElement.search */
  String search;

  /** @domName HTMLAnchorElement.shape */
  String shape;

  /** @domName HTMLAnchorElement.target */
  String target;

  /** @domName HTMLAnchorElement.type */
  String type;

  /** @domName HTMLAnchorElement.toString */
  String toString();
}

class _AnchorElementImpl extends _ElementImpl implements AnchorElement native "*HTMLAnchorElement" {

  String charset;

  String coords;

  String download;

  String hash;

  String host;

  String hostname;

  String href;

  String hreflang;

  String name;

  final String origin;

  String pathname;

  String ping;

  String port;

  String protocol;

  String rel;

  String rev;

  String search;

  String shape;

  String target;

  String type;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimation
abstract class Animation {

  static const int DIRECTION_ALTERNATE = 1;

  static const int DIRECTION_NORMAL = 0;

  static const int FILL_BACKWARDS = 1;

  static const int FILL_BOTH = 3;

  static const int FILL_FORWARDS = 2;

  static const int FILL_NONE = 0;

  /** @domName WebKitAnimation.delay */
  num get delay;

  /** @domName WebKitAnimation.direction */
  int get direction;

  /** @domName WebKitAnimation.duration */
  num get duration;

  /** @domName WebKitAnimation.elapsedTime */
  num elapsedTime;

  /** @domName WebKitAnimation.ended */
  bool get ended;

  /** @domName WebKitAnimation.fillMode */
  int get fillMode;

  /** @domName WebKitAnimation.iterationCount */
  int get iterationCount;

  /** @domName WebKitAnimation.name */
  String get name;

  /** @domName WebKitAnimation.paused */
  bool get paused;

  /** @domName WebKitAnimation.pause */
  void pause();

  /** @domName WebKitAnimation.play */
  void play();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimationEvent
abstract class AnimationEvent implements Event {

  /** @domName WebKitAnimationEvent.animationName */
  String get animationName;

  /** @domName WebKitAnimationEvent.elapsedTime */
  num get elapsedTime;
}

class _AnimationEventImpl extends _EventImpl implements AnimationEvent native "*WebKitAnimationEvent" {

  final String animationName;

  final num elapsedTime;
}

class _AnimationImpl implements Animation native "*WebKitAnimation" {

  final num delay;

  final int direction;

  final num duration;

  num elapsedTime;

  final bool ended;

  final int fillMode;

  final int iterationCount;

  final String name;

  final bool paused;

  void pause() native;

  void play() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAppletElement
abstract class AppletElement implements Element {

  /** @domName HTMLAppletElement.align */
  String align;

  /** @domName HTMLAppletElement.alt */
  String alt;

  /** @domName HTMLAppletElement.archive */
  String archive;

  /** @domName HTMLAppletElement.code */
  String code;

  /** @domName HTMLAppletElement.codeBase */
  String codeBase;

  /** @domName HTMLAppletElement.height */
  String height;

  /** @domName HTMLAppletElement.hspace */
  String hspace;

  /** @domName HTMLAppletElement.name */
  String name;

  /** @domName HTMLAppletElement.object */
  String object;

  /** @domName HTMLAppletElement.vspace */
  String vspace;

  /** @domName HTMLAppletElement.width */
  String width;
}

class _AppletElementImpl extends _ElementImpl implements AppletElement native "*HTMLAppletElement" {

  String align;

  String alt;

  String archive;

  String code;

  String codeBase;

  String height;

  String hspace;

  String name;

  String object;

  String vspace;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAreaElement
abstract class AreaElement implements Element {

  factory AreaElement() => _Elements.createAreaElement();

  /** @domName HTMLAreaElement.alt */
  String alt;

  /** @domName HTMLAreaElement.coords */
  String coords;

  /** @domName HTMLAreaElement.hash */
  String get hash;

  /** @domName HTMLAreaElement.host */
  String get host;

  /** @domName HTMLAreaElement.hostname */
  String get hostname;

  /** @domName HTMLAreaElement.href */
  String href;

  /** @domName HTMLAreaElement.noHref */
  bool noHref;

  /** @domName HTMLAreaElement.pathname */
  String get pathname;

  /** @domName HTMLAreaElement.ping */
  String ping;

  /** @domName HTMLAreaElement.port */
  String get port;

  /** @domName HTMLAreaElement.protocol */
  String get protocol;

  /** @domName HTMLAreaElement.search */
  String get search;

  /** @domName HTMLAreaElement.shape */
  String shape;

  /** @domName HTMLAreaElement.target */
  String target;
}

class _AreaElementImpl extends _ElementImpl implements AreaElement native "*HTMLAreaElement" {

  String alt;

  String coords;

  final String hash;

  final String host;

  final String hostname;

  String href;

  bool noHref;

  final String pathname;

  String ping;

  final String port;

  final String protocol;

  final String search;

  String shape;

  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ArrayBuffer
abstract class ArrayBuffer {

  factory ArrayBuffer(int length) => _ArrayBufferFactoryProvider.createArrayBuffer(length);

  /** @domName ArrayBuffer.byteLength */
  int get byteLength;

  /** @domName ArrayBuffer.slice */
  ArrayBuffer slice(int begin, [int end]);
}

class _ArrayBufferImpl implements ArrayBuffer native "*ArrayBuffer" {

  final int byteLength;

  _ArrayBufferImpl slice(int begin, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ArrayBufferView
abstract class ArrayBufferView {

  /** @domName ArrayBufferView.buffer */
  ArrayBuffer get buffer;

  /** @domName ArrayBufferView.byteLength */
  int get byteLength;

  /** @domName ArrayBufferView.byteOffset */
  int get byteOffset;
}

class _ArrayBufferViewImpl implements ArrayBufferView native "*ArrayBufferView" {

  final _ArrayBufferImpl buffer;

  final int byteLength;

  final int byteOffset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Attr
abstract class Attr implements Node {

  /** @domName Attr.isId */
  bool get isId;

  /** @domName Attr.name */
  String get name;

  /** @domName Attr.ownerElement */
  Element get ownerElement;

  /** @domName Attr.specified */
  bool get specified;

  /** @domName Attr.value */
  String value;
}

class _AttrImpl extends _NodeImpl implements Attr native "*Attr" {

  final bool isId;

  final String name;

  final _ElementImpl ownerElement;

  final bool specified;

  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioBuffer
abstract class AudioBuffer {

  /** @domName AudioBuffer.duration */
  num get duration;

  /** @domName AudioBuffer.gain */
  num gain;

  /** @domName AudioBuffer.length */
  int get length;

  /** @domName AudioBuffer.numberOfChannels */
  int get numberOfChannels;

  /** @domName AudioBuffer.sampleRate */
  num get sampleRate;

  /** @domName AudioBuffer.getChannelData */
  Float32Array getChannelData(int channelIndex);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void AudioBufferCallback(AudioBuffer audioBuffer);

class _AudioBufferImpl implements AudioBuffer native "*AudioBuffer" {

  final num duration;

  num gain;

  final int length;

  final int numberOfChannels;

  final num sampleRate;

  _Float32ArrayImpl getChannelData(int channelIndex) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioBufferSourceNode
abstract class AudioBufferSourceNode implements AudioSourceNode {

  static const int FINISHED_STATE = 3;

  static const int PLAYING_STATE = 2;

  static const int SCHEDULED_STATE = 1;

  static const int UNSCHEDULED_STATE = 0;

  /** @domName AudioBufferSourceNode.buffer */
  AudioBuffer buffer;

  /** @domName AudioBufferSourceNode.gain */
  AudioGain get gain;

  /** @domName AudioBufferSourceNode.loop */
  bool loop;

  /** @domName AudioBufferSourceNode.loopEnd */
  num loopEnd;

  /** @domName AudioBufferSourceNode.loopStart */
  num loopStart;

  /** @domName AudioBufferSourceNode.playbackRate */
  AudioParam get playbackRate;

  /** @domName AudioBufferSourceNode.playbackState */
  int get playbackState;

  /** @domName AudioBufferSourceNode.start */
  void start(num when, [num grainOffset, num grainDuration]);

  /** @domName AudioBufferSourceNode.stop */
  void stop(num when);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioBufferSourceNodeImpl extends _AudioSourceNodeImpl implements AudioBufferSourceNode native "*AudioBufferSourceNode" {

  // TODO(efortuna): Remove these methods when Chrome stable also uses start
  // instead of noteOn.
  void start(num when, [num grainOffset, num grainDuration]) {
    if (JS('bool', '!!#.start', this)) {
      if (?grainDuration) {
        JS('void', '#.start(#, #, #)', this, when, grainOffset, grainDuration);
      } else if (?grainOffset) {
        JS('void', '#.start(#, #)', this, when, grainOffset);
      } else {
        JS('void', '#.start(#)', this, when);
      }
    } else {
      if (?grainDuration) {
        JS('void', '#.noteOn(#, #, #)', this, when, grainOffset, grainDuration);
      } else if (?grainOffset) {
        JS('void', '#.noteOn(#, #)', this, when, grainOffset);
      } else {
        JS('void', '#.noteOn(#)', this, when);
      }
    }
  }

  void stop(num when) {
    if (JS('bool', '!!#.stop', this)) {
      JS('void', '#.stop(#)', this, when);
    } else {
      JS('void', '#.noteOff(#)', this, when);
    }
  }

  _AudioBufferImpl buffer;

  final _AudioGainImpl gain;

  bool loop;

  num loopEnd;

  num loopStart;

  final _AudioParamImpl playbackRate;

  final int playbackState;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName AudioContext
abstract class AudioContext implements EventTarget {
  factory AudioContext() => _AudioContextFactoryProvider.createAudioContext();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  AudioContextEvents get on;

  /** @domName AudioContext.activeSourceCount */
  int get activeSourceCount;

  /** @domName AudioContext.currentTime */
  num get currentTime;

  /** @domName AudioContext.destination */
  AudioDestinationNode get destination;

  /** @domName AudioContext.listener */
  AudioListener get listener;

  /** @domName AudioContext.sampleRate */
  num get sampleRate;

  /** @domName AudioContext.createAnalyser */
  AnalyserNode createAnalyser();

  /** @domName AudioContext.createBiquadFilter */
  BiquadFilterNode createBiquadFilter();

  /** @domName AudioContext.createBuffer */
  AudioBuffer createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate]);

  /** @domName AudioContext.createBufferSource */
  AudioBufferSourceNode createBufferSource();

  /** @domName AudioContext.createChannelMerger */
  ChannelMergerNode createChannelMerger([int numberOfInputs]);

  /** @domName AudioContext.createChannelSplitter */
  ChannelSplitterNode createChannelSplitter([int numberOfOutputs]);

  /** @domName AudioContext.createConvolver */
  ConvolverNode createConvolver();

  /** @domName AudioContext.createDelay */
  DelayNode createDelay([num maxDelayTime]);

  /** @domName AudioContext.createDynamicsCompressor */
  DynamicsCompressorNode createDynamicsCompressor();

  /** @domName AudioContext.createGain */
  GainNode createGain();

  /** @domName AudioContext.createMediaElementSource */
  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement);

  /** @domName AudioContext.createMediaStreamSource */
  MediaStreamAudioSourceNode createMediaStreamSource(MediaStream mediaStream);

  /** @domName AudioContext.createOscillator */
  OscillatorNode createOscillator();

  /** @domName AudioContext.createPanner */
  PannerNode createPanner();

  /** @domName AudioContext.createScriptProcessor */
  ScriptProcessorNode createScriptProcessor(int bufferSize, [int numberOfInputChannels, int numberOfOutputChannels]);

  /** @domName AudioContext.createWaveShaper */
  WaveShaperNode createWaveShaper();

  /** @domName AudioContext.createWaveTable */
  WaveTable createWaveTable(Float32Array real, Float32Array imag);

  /** @domName AudioContext.decodeAudioData */
  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]);

  /** @domName AudioContext.startRendering */
  void startRendering();
}

abstract class AudioContextEvents implements Events {

  EventListenerList get complete;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioContextImpl extends _EventTargetImpl implements AudioContext native "*AudioContext" {

  _AudioContextEventsImpl get on =>
    new _AudioContextEventsImpl(this);

  final int activeSourceCount;

  final num currentTime;

  final _AudioDestinationNodeImpl destination;

  final _AudioListenerImpl listener;

  final num sampleRate;

  _AnalyserNodeImpl createAnalyser() native;

  _BiquadFilterNodeImpl createBiquadFilter() native;

  _AudioBufferImpl createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate]) native;

  _AudioBufferSourceNodeImpl createBufferSource() native;

  _ChannelMergerNodeImpl createChannelMerger([int numberOfInputs]) native;

  _ChannelSplitterNodeImpl createChannelSplitter([int numberOfOutputs]) native;

  _ConvolverNodeImpl createConvolver() native;

  _DelayNodeImpl createDelay([num maxDelayTime]) native;

  _DynamicsCompressorNodeImpl createDynamicsCompressor() native;

  _MediaElementAudioSourceNodeImpl createMediaElementSource(_MediaElementImpl mediaElement) native;

  _MediaStreamAudioSourceNodeImpl createMediaStreamSource(_MediaStreamImpl mediaStream) native;

  _OscillatorNodeImpl createOscillator() native;

  _PannerNodeImpl createPanner() native;

  _WaveShaperNodeImpl createWaveShaper() native;

  _WaveTableImpl createWaveTable(_Float32ArrayImpl real, _Float32ArrayImpl imag) native;

  void decodeAudioData(_ArrayBufferImpl audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]) native;

  void startRendering() native;

  GainNode createGain() {
    if (JS('bool', '#.createGain !== undefined', this)) {
      return JS('GainNode', '#.createGain()', this);
    } else {
      return JS('GainNode', '#.createGainNode()', this);
    }
  }

  ScriptProcessorNode createScriptProcessor(int bufferSize,
      [int numberOfInputChannels, int numberOfOutputChannels]) {
    var function = JS('dynamic', '#.createScriptProcessor || '
        '#.createJavaScriptNode', this, this);
    if (?numberOfOutputChannels) {
      return JS('ScriptProcessorNode', '#.call(#, #, #, #)', function, this,
          bufferSize, numberOfInputChannels, numberOfOutputChannels);
    } else if (?numberOfInputChannels) {
      return JS('ScriptProcessorNode', '#.call(#, #, #)', function, this,
          bufferSize, numberOfInputChannels);
    } else {
      return JS('ScriptProcessorNode', '#.call(#, #)', function, this,
          bufferSize);
    }
  }
}

class _AudioContextEventsImpl extends _EventsImpl implements AudioContextEvents {
  _AudioContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get complete => this['complete'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioDestinationNode
abstract class AudioDestinationNode implements AudioNode {

  /** @domName AudioDestinationNode.numberOfChannels */
  int get numberOfChannels;
}

class _AudioDestinationNodeImpl extends _AudioNodeImpl implements AudioDestinationNode native "*AudioDestinationNode" {

  final int numberOfChannels;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAudioElement
abstract class AudioElement implements MediaElement {

  factory AudioElement([String src]) {
    if (!?src) {
      return _AudioElementFactoryProvider.createAudioElement();
    }
    return _AudioElementFactoryProvider.createAudioElement(src);
  }
}

class _AudioElementImpl extends _MediaElementImpl implements AudioElement native "*HTMLAudioElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioGain
abstract class AudioGain implements AudioParam {
}

class _AudioGainImpl extends _AudioParamImpl implements AudioGain native "*AudioGain" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioListener
abstract class AudioListener {

  /** @domName AudioListener.dopplerFactor */
  num dopplerFactor;

  /** @domName AudioListener.speedOfSound */
  num speedOfSound;

  /** @domName AudioListener.setOrientation */
  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp);

  /** @domName AudioListener.setPosition */
  void setPosition(num x, num y, num z);

  /** @domName AudioListener.setVelocity */
  void setVelocity(num x, num y, num z);
}

class _AudioListenerImpl implements AudioListener native "*AudioListener" {

  num dopplerFactor;

  num speedOfSound;

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) native;

  void setPosition(num x, num y, num z) native;

  void setVelocity(num x, num y, num z) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioNode
abstract class AudioNode {

  /** @domName AudioNode.context */
  AudioContext get context;

  /** @domName AudioNode.numberOfInputs */
  int get numberOfInputs;

  /** @domName AudioNode.numberOfOutputs */
  int get numberOfOutputs;

  /** @domName AudioNode.connect */
  void connect(destination, int output, [int input]);

  /** @domName AudioNode.disconnect */
  void disconnect(int output);
}

class _AudioNodeImpl implements AudioNode native "*AudioNode" {

  final _AudioContextImpl context;

  final int numberOfInputs;

  final int numberOfOutputs;

  void connect(destination, int output, [int input]) native;

  void disconnect(int output) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioParam
abstract class AudioParam {

  /** @domName AudioParam.defaultValue */
  num get defaultValue;

  /** @domName AudioParam.maxValue */
  num get maxValue;

  /** @domName AudioParam.minValue */
  num get minValue;

  /** @domName AudioParam.name */
  String get name;

  /** @domName AudioParam.units */
  int get units;

  /** @domName AudioParam.value */
  num value;

  /** @domName AudioParam.cancelScheduledValues */
  void cancelScheduledValues(num startTime);

  /** @domName AudioParam.exponentialRampToValueAtTime */
  void exponentialRampToValueAtTime(num value, num time);

  /** @domName AudioParam.linearRampToValueAtTime */
  void linearRampToValueAtTime(num value, num time);

  /** @domName AudioParam.setTargetAtTime */
  void setTargetAtTime(num target, num time, num timeConstant);

  /** @domName AudioParam.setValueAtTime */
  void setValueAtTime(num value, num time);

  /** @domName AudioParam.setValueCurveAtTime */
  void setValueCurveAtTime(Float32Array values, num time, num duration);
}

class _AudioParamImpl implements AudioParam native "*AudioParam" {

  final num defaultValue;

  final num maxValue;

  final num minValue;

  final String name;

  final int units;

  num value;

  void cancelScheduledValues(num startTime) native;

  void exponentialRampToValueAtTime(num value, num time) native;

  void linearRampToValueAtTime(num value, num time) native;

  void setTargetAtTime(num target, num time, num timeConstant) native;

  void setValueAtTime(num value, num time) native;

  void setValueCurveAtTime(_Float32ArrayImpl values, num time, num duration) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioProcessingEvent
abstract class AudioProcessingEvent implements Event {

  /** @domName AudioProcessingEvent.inputBuffer */
  AudioBuffer get inputBuffer;

  /** @domName AudioProcessingEvent.outputBuffer */
  AudioBuffer get outputBuffer;
}

class _AudioProcessingEventImpl extends _EventImpl implements AudioProcessingEvent native "*AudioProcessingEvent" {

  final _AudioBufferImpl inputBuffer;

  final _AudioBufferImpl outputBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioSourceNode
abstract class AudioSourceNode implements AudioNode {
}

class _AudioSourceNodeImpl extends _AudioNodeImpl implements AudioSourceNode native "*AudioSourceNode" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBRElement
abstract class BRElement implements Element {

  factory BRElement() => _Elements.createBRElement();

  /** @domName HTMLBRElement.clear */
  String clear;
}

class _BRElementImpl extends _ElementImpl implements BRElement native "*HTMLBRElement" {

  String clear;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BarInfo
abstract class BarInfo {

  /** @domName BarInfo.visible */
  bool get visible;
}

class _BarInfoImpl implements BarInfo native "*BarInfo" {

  final bool visible;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBaseElement
abstract class BaseElement implements Element {

  factory BaseElement() => _Elements.createBaseElement();

  /** @domName HTMLBaseElement.href */
  String href;

  /** @domName HTMLBaseElement.target */
  String target;
}

class _BaseElementImpl extends _ElementImpl implements BaseElement native "*HTMLBaseElement" {

  String href;

  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBaseFontElement
abstract class BaseFontElement implements Element {

  /** @domName HTMLBaseFontElement.color */
  String color;

  /** @domName HTMLBaseFontElement.face */
  String face;

  /** @domName HTMLBaseFontElement.size */
  int size;
}

class _BaseFontElementImpl extends _ElementImpl implements BaseFontElement native "*HTMLBaseFontElement" {

  String color;

  String face;

  int size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BatteryManager
abstract class BatteryManager implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  BatteryManagerEvents get on;

  /** @domName BatteryManager.charging */
  bool get charging;

  /** @domName BatteryManager.chargingTime */
  num get chargingTime;

  /** @domName BatteryManager.dischargingTime */
  num get dischargingTime;

  /** @domName BatteryManager.level */
  num get level;

  /** @domName BatteryManager.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName BatteryManager.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName BatteryManager.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class BatteryManagerEvents implements Events {

  EventListenerList get chargingChange;

  EventListenerList get chargingTimeChange;

  EventListenerList get dischargingTimeChange;

  EventListenerList get levelChange;
}

class _BatteryManagerImpl extends _EventTargetImpl implements BatteryManager native "*BatteryManager" {

  _BatteryManagerEventsImpl get on =>
    new _BatteryManagerEventsImpl(this);

  final bool charging;

  final num chargingTime;

  final num dischargingTime;

  final num level;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _BatteryManagerEventsImpl extends _EventsImpl implements BatteryManagerEvents {
  _BatteryManagerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get chargingChange => this['chargingchange'];

  EventListenerList get chargingTimeChange => this['chargingtimechange'];

  EventListenerList get dischargingTimeChange => this['dischargingtimechange'];

  EventListenerList get levelChange => this['levelchange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BeforeLoadEvent
abstract class BeforeLoadEvent implements Event {

  /** @domName BeforeLoadEvent.url */
  String get url;
}

class _BeforeLoadEventImpl extends _EventImpl implements BeforeLoadEvent native "*BeforeLoadEvent" {

  final String url;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BiquadFilterNode
abstract class BiquadFilterNode implements AudioNode {

  static const int ALLPASS = 7;

  static const int BANDPASS = 2;

  static const int HIGHPASS = 1;

  static const int HIGHSHELF = 4;

  static const int LOWPASS = 0;

  static const int LOWSHELF = 3;

  static const int NOTCH = 6;

  static const int PEAKING = 5;

  /** @domName BiquadFilterNode.Q */
  AudioParam get Q;

  /** @domName BiquadFilterNode.frequency */
  AudioParam get frequency;

  /** @domName BiquadFilterNode.gain */
  AudioParam get gain;

  /** @domName BiquadFilterNode.type */
  int type;

  /** @domName BiquadFilterNode.getFrequencyResponse */
  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse);
}

class _BiquadFilterNodeImpl extends _AudioNodeImpl implements BiquadFilterNode native "*BiquadFilterNode" {

  final _AudioParamImpl Q;

  final _AudioParamImpl frequency;

  final _AudioParamImpl gain;

  int type;

  void getFrequencyResponse(_Float32ArrayImpl frequencyHz, _Float32ArrayImpl magResponse, _Float32ArrayImpl phaseResponse) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Blob
abstract class Blob {

  factory Blob(List blobParts, [String type, String endings]) {
    if (!?type) {
      return _BlobFactoryProvider.createBlob(blobParts);
    }
    if (!?endings) {
      return _BlobFactoryProvider.createBlob(blobParts, type);
    }
    return _BlobFactoryProvider.createBlob(blobParts, type, endings);
  }

  /** @domName Blob.size */
  int get size;

  /** @domName Blob.type */
  String get type;

  /** @domName Blob.slice */
  Blob slice([int start, int end, String contentType]);
}

class _BlobImpl implements Blob native "*Blob" {

  final int size;

  final String type;

  _BlobImpl slice([int start, int end, String contentType]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBodyElement
abstract class BodyElement implements Element {

  factory BodyElement() => _Elements.createBodyElement();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  BodyElementEvents get on;

  /** @domName HTMLBodyElement.aLink */
  String aLink;

  /** @domName HTMLBodyElement.background */
  String background;

  /** @domName HTMLBodyElement.bgColor */
  String bgColor;

  /** @domName HTMLBodyElement.link */
  String link;

  /** @domName HTMLBodyElement.vLink */
  String vLink;
}

abstract class BodyElementEvents implements ElementEvents {

  EventListenerList get beforeUnload;

  EventListenerList get blur;

  EventListenerList get error;

  EventListenerList get focus;

  EventListenerList get hashChange;

  EventListenerList get load;

  EventListenerList get message;

  EventListenerList get offline;

  EventListenerList get online;

  EventListenerList get popState;

  EventListenerList get resize;

  EventListenerList get storage;

  EventListenerList get unload;
}

class _BodyElementImpl extends _ElementImpl implements BodyElement native "*HTMLBodyElement" {

  _BodyElementEventsImpl get on =>
    new _BodyElementEventsImpl(this);

  String aLink;

  String background;

  String bgColor;

  String link;

  String vLink;
}

class _BodyElementEventsImpl extends _ElementEventsImpl implements BodyElementEvents {
  _BodyElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get beforeUnload => this['beforeunload'];

  EventListenerList get blur => this['blur'];

  EventListenerList get error => this['error'];

  EventListenerList get focus => this['focus'];

  EventListenerList get hashChange => this['hashchange'];

  EventListenerList get load => this['load'];

  EventListenerList get message => this['message'];

  EventListenerList get offline => this['offline'];

  EventListenerList get online => this['online'];

  EventListenerList get popState => this['popstate'];

  EventListenerList get resize => this['resize'];

  EventListenerList get storage => this['storage'];

  EventListenerList get unload => this['unload'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLButtonElement
abstract class ButtonElement implements Element {

  factory ButtonElement() => _Elements.createButtonElement();

  /** @domName HTMLButtonElement.autofocus */
  bool autofocus;

  /** @domName HTMLButtonElement.disabled */
  bool disabled;

  /** @domName HTMLButtonElement.form */
  FormElement get form;

  /** @domName HTMLButtonElement.formAction */
  String formAction;

  /** @domName HTMLButtonElement.formEnctype */
  String formEnctype;

  /** @domName HTMLButtonElement.formMethod */
  String formMethod;

  /** @domName HTMLButtonElement.formNoValidate */
  bool formNoValidate;

  /** @domName HTMLButtonElement.formTarget */
  String formTarget;

  /** @domName HTMLButtonElement.labels */
  List<Node> get labels;

  /** @domName HTMLButtonElement.name */
  String name;

  /** @domName HTMLButtonElement.type */
  String type;

  /** @domName HTMLButtonElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLButtonElement.validity */
  ValidityState get validity;

  /** @domName HTMLButtonElement.value */
  String value;

  /** @domName HTMLButtonElement.willValidate */
  bool get willValidate;

  /** @domName HTMLButtonElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLButtonElement.setCustomValidity */
  void setCustomValidity(String error);
}

class _ButtonElementImpl extends _ElementImpl implements ButtonElement native "*HTMLButtonElement" {

  bool autofocus;

  bool disabled;

  final _FormElementImpl form;

  String formAction;

  String formEnctype;

  String formMethod;

  bool formNoValidate;

  String formTarget;

  final List<Node> labels;

  String name;

  String type;

  final String validationMessage;

  final _ValidityStateImpl validity;

  String value;

  final bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CDATASection
abstract class CDATASection implements Text {
}

class _CDATASectionImpl extends _TextImpl implements CDATASection native "*CDATASection" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSCharsetRule
abstract class CSSCharsetRule implements CSSRule {

  /** @domName CSSCharsetRule.encoding */
  String encoding;
}

class _CSSCharsetRuleImpl extends _CSSRuleImpl implements CSSCharsetRule native "*CSSCharsetRule" {

  String encoding;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSFontFaceRule
abstract class CSSFontFaceRule implements CSSRule {

  /** @domName CSSFontFaceRule.style */
  CSSStyleDeclaration get style;
}

class _CSSFontFaceRuleImpl extends _CSSRuleImpl implements CSSFontFaceRule native "*CSSFontFaceRule" {

  final _CSSStyleDeclarationImpl style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSImportRule
abstract class CSSImportRule implements CSSRule {

  /** @domName CSSImportRule.href */
  String get href;

  /** @domName CSSImportRule.media */
  MediaList get media;

  /** @domName CSSImportRule.styleSheet */
  CSSStyleSheet get styleSheet;
}

class _CSSImportRuleImpl extends _CSSRuleImpl implements CSSImportRule native "*CSSImportRule" {

  final String href;

  final _MediaListImpl media;

  final _CSSStyleSheetImpl styleSheet;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSKeyframeRule
abstract class CSSKeyframeRule implements CSSRule {

  /** @domName WebKitCSSKeyframeRule.keyText */
  String keyText;

  /** @domName WebKitCSSKeyframeRule.style */
  CSSStyleDeclaration get style;
}

class _CSSKeyframeRuleImpl extends _CSSRuleImpl implements CSSKeyframeRule native "*WebKitCSSKeyframeRule" {

  String keyText;

  final _CSSStyleDeclarationImpl style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSKeyframesRule
abstract class CSSKeyframesRule implements CSSRule {

  /** @domName WebKitCSSKeyframesRule.cssRules */
  List<CSSRule> get cssRules;

  /** @domName WebKitCSSKeyframesRule.name */
  String name;

  /** @domName WebKitCSSKeyframesRule.deleteRule */
  void deleteRule(String key);

  /** @domName WebKitCSSKeyframesRule.findRule */
  CSSKeyframeRule findRule(String key);

  /** @domName WebKitCSSKeyframesRule.insertRule */
  void insertRule(String rule);
}

class _CSSKeyframesRuleImpl extends _CSSRuleImpl implements CSSKeyframesRule native "*WebKitCSSKeyframesRule" {

  final _CSSRuleListImpl cssRules;

  String name;

  void deleteRule(String key) native;

  _CSSKeyframeRuleImpl findRule(String key) native;

  void insertRule(String rule) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSMatrix
abstract class CSSMatrix {

  factory CSSMatrix([String cssValue]) {
    if (!?cssValue) {
      return _CSSMatrixFactoryProvider.createCSSMatrix();
    }
    return _CSSMatrixFactoryProvider.createCSSMatrix(cssValue);
  }

  /** @domName WebKitCSSMatrix.a */
  num a;

  /** @domName WebKitCSSMatrix.b */
  num b;

  /** @domName WebKitCSSMatrix.c */
  num c;

  /** @domName WebKitCSSMatrix.d */
  num d;

  /** @domName WebKitCSSMatrix.e */
  num e;

  /** @domName WebKitCSSMatrix.f */
  num f;

  /** @domName WebKitCSSMatrix.m11 */
  num m11;

  /** @domName WebKitCSSMatrix.m12 */
  num m12;

  /** @domName WebKitCSSMatrix.m13 */
  num m13;

  /** @domName WebKitCSSMatrix.m14 */
  num m14;

  /** @domName WebKitCSSMatrix.m21 */
  num m21;

  /** @domName WebKitCSSMatrix.m22 */
  num m22;

  /** @domName WebKitCSSMatrix.m23 */
  num m23;

  /** @domName WebKitCSSMatrix.m24 */
  num m24;

  /** @domName WebKitCSSMatrix.m31 */
  num m31;

  /** @domName WebKitCSSMatrix.m32 */
  num m32;

  /** @domName WebKitCSSMatrix.m33 */
  num m33;

  /** @domName WebKitCSSMatrix.m34 */
  num m34;

  /** @domName WebKitCSSMatrix.m41 */
  num m41;

  /** @domName WebKitCSSMatrix.m42 */
  num m42;

  /** @domName WebKitCSSMatrix.m43 */
  num m43;

  /** @domName WebKitCSSMatrix.m44 */
  num m44;

  /** @domName WebKitCSSMatrix.inverse */
  CSSMatrix inverse();

  /** @domName WebKitCSSMatrix.multiply */
  CSSMatrix multiply(CSSMatrix secondMatrix);

  /** @domName WebKitCSSMatrix.rotate */
  CSSMatrix rotate(num rotX, num rotY, num rotZ);

  /** @domName WebKitCSSMatrix.rotateAxisAngle */
  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle);

  /** @domName WebKitCSSMatrix.scale */
  CSSMatrix scale(num scaleX, num scaleY, num scaleZ);

  /** @domName WebKitCSSMatrix.setMatrixValue */
  void setMatrixValue(String string);

  /** @domName WebKitCSSMatrix.skewX */
  CSSMatrix skewX(num angle);

  /** @domName WebKitCSSMatrix.skewY */
  CSSMatrix skewY(num angle);

  /** @domName WebKitCSSMatrix.toString */
  String toString();

  /** @domName WebKitCSSMatrix.translate */
  CSSMatrix translate(num x, num y, num z);
}

class _CSSMatrixImpl implements CSSMatrix native "*WebKitCSSMatrix" {

  num a;

  num b;

  num c;

  num d;

  num e;

  num f;

  num m11;

  num m12;

  num m13;

  num m14;

  num m21;

  num m22;

  num m23;

  num m24;

  num m31;

  num m32;

  num m33;

  num m34;

  num m41;

  num m42;

  num m43;

  num m44;

  _CSSMatrixImpl inverse() native;

  _CSSMatrixImpl multiply(_CSSMatrixImpl secondMatrix) native;

  _CSSMatrixImpl rotate(num rotX, num rotY, num rotZ) native;

  _CSSMatrixImpl rotateAxisAngle(num x, num y, num z, num angle) native;

  _CSSMatrixImpl scale(num scaleX, num scaleY, num scaleZ) native;

  void setMatrixValue(String string) native;

  _CSSMatrixImpl skewX(num angle) native;

  _CSSMatrixImpl skewY(num angle) native;

  String toString() native;

  _CSSMatrixImpl translate(num x, num y, num z) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSMediaRule
abstract class CSSMediaRule implements CSSRule {

  /** @domName CSSMediaRule.cssRules */
  List<CSSRule> get cssRules;

  /** @domName CSSMediaRule.media */
  MediaList get media;

  /** @domName CSSMediaRule.deleteRule */
  void deleteRule(int index);

  /** @domName CSSMediaRule.insertRule */
  int insertRule(String rule, int index);
}

class _CSSMediaRuleImpl extends _CSSRuleImpl implements CSSMediaRule native "*CSSMediaRule" {

  final _CSSRuleListImpl cssRules;

  final _MediaListImpl media;

  void deleteRule(int index) native;

  int insertRule(String rule, int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSPageRule
abstract class CSSPageRule implements CSSRule {

  /** @domName CSSPageRule.selectorText */
  String selectorText;

  /** @domName CSSPageRule.style */
  CSSStyleDeclaration get style;
}

class _CSSPageRuleImpl extends _CSSRuleImpl implements CSSPageRule native "*CSSPageRule" {

  String selectorText;

  final _CSSStyleDeclarationImpl style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSPrimitiveValue
abstract class CSSPrimitiveValue implements CSSValue {

  static const int CSS_ATTR = 22;

  static const int CSS_CM = 6;

  static const int CSS_COUNTER = 23;

  static const int CSS_DEG = 11;

  static const int CSS_DIMENSION = 18;

  static const int CSS_EMS = 3;

  static const int CSS_EXS = 4;

  static const int CSS_GRAD = 13;

  static const int CSS_HZ = 16;

  static const int CSS_IDENT = 21;

  static const int CSS_IN = 8;

  static const int CSS_KHZ = 17;

  static const int CSS_MM = 7;

  static const int CSS_MS = 14;

  static const int CSS_NUMBER = 1;

  static const int CSS_PC = 10;

  static const int CSS_PERCENTAGE = 2;

  static const int CSS_PT = 9;

  static const int CSS_PX = 5;

  static const int CSS_RAD = 12;

  static const int CSS_RECT = 24;

  static const int CSS_RGBCOLOR = 25;

  static const int CSS_S = 15;

  static const int CSS_STRING = 19;

  static const int CSS_UNKNOWN = 0;

  static const int CSS_URI = 20;

  static const int CSS_VH = 27;

  static const int CSS_VMIN = 28;

  static const int CSS_VW = 26;

  /** @domName CSSPrimitiveValue.primitiveType */
  int get primitiveType;

  /** @domName CSSPrimitiveValue.getCounterValue */
  Counter getCounterValue();

  /** @domName CSSPrimitiveValue.getFloatValue */
  num getFloatValue(int unitType);

  /** @domName CSSPrimitiveValue.getRGBColorValue */
  RGBColor getRGBColorValue();

  /** @domName CSSPrimitiveValue.getRectValue */
  Rect getRectValue();

  /** @domName CSSPrimitiveValue.getStringValue */
  String getStringValue();

  /** @domName CSSPrimitiveValue.setFloatValue */
  void setFloatValue(int unitType, num floatValue);

  /** @domName CSSPrimitiveValue.setStringValue */
  void setStringValue(int stringType, String stringValue);
}

class _CSSPrimitiveValueImpl extends _CSSValueImpl implements CSSPrimitiveValue native "*CSSPrimitiveValue" {

  final int primitiveType;

  _CounterImpl getCounterValue() native;

  num getFloatValue(int unitType) native;

  _RGBColorImpl getRGBColorValue() native;

  _RectImpl getRectValue() native;

  String getStringValue() native;

  void setFloatValue(int unitType, num floatValue) native;

  void setStringValue(int stringType, String stringValue) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSRule
abstract class CSSRule {

  static const int CHARSET_RULE = 2;

  static const int FONT_FACE_RULE = 5;

  static const int IMPORT_RULE = 3;

  static const int MEDIA_RULE = 4;

  static const int PAGE_RULE = 6;

  static const int STYLE_RULE = 1;

  static const int UNKNOWN_RULE = 0;

  static const int WEBKIT_KEYFRAMES_RULE = 7;

  static const int WEBKIT_KEYFRAME_RULE = 8;

  /** @domName CSSRule.cssText */
  String cssText;

  /** @domName CSSRule.parentRule */
  CSSRule get parentRule;

  /** @domName CSSRule.parentStyleSheet */
  CSSStyleSheet get parentStyleSheet;

  /** @domName CSSRule.type */
  int get type;
}

class _CSSRuleImpl implements CSSRule native "*CSSRule" {

  String cssText;

  final _CSSRuleImpl parentRule;

  final _CSSStyleSheetImpl parentStyleSheet;

  final int type;
}

class _CSSRuleListImpl implements List<CSSRule>, JavaScriptIndexingBehavior native "*CSSRuleList" {

  final int length;

  _CSSRuleImpl operator[](int index) => JS("_CSSRuleImpl", "#[#]", this, index);

  void operator[]=(int index, _CSSRuleImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<CSSRule> mixins.
  // CSSRule is the element type.

  // From Iterable<CSSRule>:

  Iterator<CSSRule> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<CSSRule>(this);
  }

  // From Collection<CSSRule>:

  void add(CSSRule value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(CSSRule value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<CSSRule> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(CSSRule element) => _Collections.contains(this, element);

  void forEach(void f(CSSRule element)) => _Collections.forEach(this, f);

  Collection map(f(CSSRule element)) => _Collections.map(this, [], f);

  Collection<CSSRule> filter(bool f(CSSRule element)) =>
     _Collections.filter(this, <CSSRule>[], f);

  bool every(bool f(CSSRule element)) => _Collections.every(this, f);

  bool some(bool f(CSSRule element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<CSSRule>:

  void sort([Comparator<CSSRule> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(CSSRule element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(CSSRule element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  CSSRule get last => this[length - 1];

  CSSRule removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<CSSRule> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [CSSRule initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<CSSRule> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <CSSRule>[]);

  // -- end List<CSSRule> mixins.

  _CSSRuleImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName CSSStyleDeclaration
abstract class CSSStyleDeclaration  {
  factory CSSStyleDeclaration() => _CSSStyleDeclarationFactoryProvider.createCSSStyleDeclaration();
  factory CSSStyleDeclaration.css(String css) => _CSSStyleDeclarationFactoryProvider.createCSSStyleDeclaration_css(css);


  /** @domName CSSStyleDeclaration.cssText */
  String cssText;

  /** @domName CSSStyleDeclaration.length */
  int get length;

  /** @domName CSSStyleDeclaration.parentRule */
  CSSRule get parentRule;

  /** @domName CSSStyleDeclaration.getPropertyCSSValue */
  CSSValue getPropertyCSSValue(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyPriority */
  String getPropertyPriority(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyShorthand */
  String getPropertyShorthand(String propertyName);

  /** @domName CSSStyleDeclaration.isPropertyImplicit */
  bool isPropertyImplicit(String propertyName);

  /** @domName CSSStyleDeclaration.item */
  String item(int index);

  /** @domName CSSStyleDeclaration.removeProperty */
  String removeProperty(String propertyName);

  /** @domName CSSStyleDeclaration.setProperty */
  void setProperty(String propertyName, String value, [String priority]);


  /** Gets the value of "animation" */
  String get animation;

  /** Sets the value of "animation" */
  void set animation(var value);

  /** Gets the value of "animation-delay" */
  String get animationDelay;

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value);

  /** Gets the value of "animation-direction" */
  String get animationDirection;

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value);

  /** Gets the value of "animation-duration" */
  String get animationDuration;

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value);

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode;

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value);

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount;

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value);

  /** Gets the value of "animation-name" */
  String get animationName;

  /** Sets the value of "animation-name" */
  void set animationName(var value);

  /** Gets the value of "animation-play-state" */
  String get animationPlayState;

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value);

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction;

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value);

  /** Gets the value of "appearance" */
  String get appearance;

  /** Sets the value of "appearance" */
  void set appearance(var value);

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility;

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value);

  /** Gets the value of "background" */
  String get background;

  /** Sets the value of "background" */
  void set background(var value);

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment;

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value);

  /** Gets the value of "background-clip" */
  String get backgroundClip;

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value);

  /** Gets the value of "background-color" */
  String get backgroundColor;

  /** Sets the value of "background-color" */
  void set backgroundColor(var value);

  /** Gets the value of "background-composite" */
  String get backgroundComposite;

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value);

  /** Gets the value of "background-image" */
  String get backgroundImage;

  /** Sets the value of "background-image" */
  void set backgroundImage(var value);

  /** Gets the value of "background-origin" */
  String get backgroundOrigin;

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value);

  /** Gets the value of "background-position" */
  String get backgroundPosition;

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value);

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX;

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value);

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY;

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value);

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat;

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value);

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX;

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value);

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY;

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value);

  /** Gets the value of "background-size" */
  String get backgroundSize;

  /** Sets the value of "background-size" */
  void set backgroundSize(var value);

  /** Gets the value of "border" */
  String get border;

  /** Sets the value of "border" */
  void set border(var value);

  /** Gets the value of "border-after" */
  String get borderAfter;

  /** Sets the value of "border-after" */
  void set borderAfter(var value);

  /** Gets the value of "border-after-color" */
  String get borderAfterColor;

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value);

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle;

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value);

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth;

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value);

  /** Gets the value of "border-before" */
  String get borderBefore;

  /** Sets the value of "border-before" */
  void set borderBefore(var value);

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor;

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value);

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle;

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value);

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth;

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value);

  /** Gets the value of "border-bottom" */
  String get borderBottom;

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value);

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor;

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value);

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius;

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value);

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius;

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value);

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle;

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value);

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth;

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value);

  /** Gets the value of "border-collapse" */
  String get borderCollapse;

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value);

  /** Gets the value of "border-color" */
  String get borderColor;

  /** Sets the value of "border-color" */
  void set borderColor(var value);

  /** Gets the value of "border-end" */
  String get borderEnd;

  /** Sets the value of "border-end" */
  void set borderEnd(var value);

  /** Gets the value of "border-end-color" */
  String get borderEndColor;

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value);

  /** Gets the value of "border-end-style" */
  String get borderEndStyle;

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value);

  /** Gets the value of "border-end-width" */
  String get borderEndWidth;

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value);

  /** Gets the value of "border-fit" */
  String get borderFit;

  /** Sets the value of "border-fit" */
  void set borderFit(var value);

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing;

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value);

  /** Gets the value of "border-image" */
  String get borderImage;

  /** Sets the value of "border-image" */
  void set borderImage(var value);

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset;

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value);

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat;

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value);

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice;

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value);

  /** Gets the value of "border-image-source" */
  String get borderImageSource;

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value);

  /** Gets the value of "border-image-width" */
  String get borderImageWidth;

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value);

  /** Gets the value of "border-left" */
  String get borderLeft;

  /** Sets the value of "border-left" */
  void set borderLeft(var value);

  /** Gets the value of "border-left-color" */
  String get borderLeftColor;

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value);

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle;

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value);

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth;

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value);

  /** Gets the value of "border-radius" */
  String get borderRadius;

  /** Sets the value of "border-radius" */
  void set borderRadius(var value);

  /** Gets the value of "border-right" */
  String get borderRight;

  /** Sets the value of "border-right" */
  void set borderRight(var value);

  /** Gets the value of "border-right-color" */
  String get borderRightColor;

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value);

  /** Gets the value of "border-right-style" */
  String get borderRightStyle;

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value);

  /** Gets the value of "border-right-width" */
  String get borderRightWidth;

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value);

  /** Gets the value of "border-spacing" */
  String get borderSpacing;

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value);

  /** Gets the value of "border-start" */
  String get borderStart;

  /** Sets the value of "border-start" */
  void set borderStart(var value);

  /** Gets the value of "border-start-color" */
  String get borderStartColor;

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value);

  /** Gets the value of "border-start-style" */
  String get borderStartStyle;

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value);

  /** Gets the value of "border-start-width" */
  String get borderStartWidth;

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value);

  /** Gets the value of "border-style" */
  String get borderStyle;

  /** Sets the value of "border-style" */
  void set borderStyle(var value);

  /** Gets the value of "border-top" */
  String get borderTop;

  /** Sets the value of "border-top" */
  void set borderTop(var value);

  /** Gets the value of "border-top-color" */
  String get borderTopColor;

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value);

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius;

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value);

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius;

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value);

  /** Gets the value of "border-top-style" */
  String get borderTopStyle;

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value);

  /** Gets the value of "border-top-width" */
  String get borderTopWidth;

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value);

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing;

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value);

  /** Gets the value of "border-width" */
  String get borderWidth;

  /** Sets the value of "border-width" */
  void set borderWidth(var value);

  /** Gets the value of "bottom" */
  String get bottom;

  /** Sets the value of "bottom" */
  void set bottom(var value);

  /** Gets the value of "box-align" */
  String get boxAlign;

  /** Sets the value of "box-align" */
  void set boxAlign(var value);

  /** Gets the value of "box-direction" */
  String get boxDirection;

  /** Sets the value of "box-direction" */
  void set boxDirection(var value);

  /** Gets the value of "box-flex" */
  String get boxFlex;

  /** Sets the value of "box-flex" */
  void set boxFlex(var value);

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup;

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value);

  /** Gets the value of "box-lines" */
  String get boxLines;

  /** Sets the value of "box-lines" */
  void set boxLines(var value);

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup;

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value);

  /** Gets the value of "box-orient" */
  String get boxOrient;

  /** Sets the value of "box-orient" */
  void set boxOrient(var value);

  /** Gets the value of "box-pack" */
  String get boxPack;

  /** Sets the value of "box-pack" */
  void set boxPack(var value);

  /** Gets the value of "box-reflect" */
  String get boxReflect;

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value);

  /** Gets the value of "box-shadow" */
  String get boxShadow;

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value);

  /** Gets the value of "box-sizing" */
  String get boxSizing;

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value);

  /** Gets the value of "caption-side" */
  String get captionSide;

  /** Sets the value of "caption-side" */
  void set captionSide(var value);

  /** Gets the value of "clear" */
  String get clear;

  /** Sets the value of "clear" */
  void set clear(var value);

  /** Gets the value of "clip" */
  String get clip;

  /** Sets the value of "clip" */
  void set clip(var value);

  /** Gets the value of "color" */
  String get color;

  /** Sets the value of "color" */
  void set color(var value);

  /** Gets the value of "color-correction" */
  String get colorCorrection;

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value);

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter;

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value);

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore;

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value);

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside;

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value);

  /** Gets the value of "column-count" */
  String get columnCount;

  /** Sets the value of "column-count" */
  void set columnCount(var value);

  /** Gets the value of "column-gap" */
  String get columnGap;

  /** Sets the value of "column-gap" */
  void set columnGap(var value);

  /** Gets the value of "column-rule" */
  String get columnRule;

  /** Sets the value of "column-rule" */
  void set columnRule(var value);

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor;

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value);

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle;

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value);

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth;

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value);

  /** Gets the value of "column-span" */
  String get columnSpan;

  /** Sets the value of "column-span" */
  void set columnSpan(var value);

  /** Gets the value of "column-width" */
  String get columnWidth;

  /** Sets the value of "column-width" */
  void set columnWidth(var value);

  /** Gets the value of "columns" */
  String get columns;

  /** Sets the value of "columns" */
  void set columns(var value);

  /** Gets the value of "content" */
  String get content;

  /** Sets the value of "content" */
  void set content(var value);

  /** Gets the value of "counter-increment" */
  String get counterIncrement;

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value);

  /** Gets the value of "counter-reset" */
  String get counterReset;

  /** Sets the value of "counter-reset" */
  void set counterReset(var value);

  /** Gets the value of "cursor" */
  String get cursor;

  /** Sets the value of "cursor" */
  void set cursor(var value);

  /** Gets the value of "direction" */
  String get direction;

  /** Sets the value of "direction" */
  void set direction(var value);

  /** Gets the value of "display" */
  String get display;

  /** Sets the value of "display" */
  void set display(var value);

  /** Gets the value of "empty-cells" */
  String get emptyCells;

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value);

  /** Gets the value of "filter" */
  String get filter;

  /** Sets the value of "filter" */
  void set filter(var value);

  /** Gets the value of "flex-align" */
  String get flexAlign;

  /** Sets the value of "flex-align" */
  void set flexAlign(var value);

  /** Gets the value of "flex-flow" */
  String get flexFlow;

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value);

  /** Gets the value of "flex-order" */
  String get flexOrder;

  /** Sets the value of "flex-order" */
  void set flexOrder(var value);

  /** Gets the value of "flex-pack" */
  String get flexPack;

  /** Sets the value of "flex-pack" */
  void set flexPack(var value);

  /** Gets the value of "float" */
  String get float;

  /** Sets the value of "float" */
  void set float(var value);

  /** Gets the value of "flow-from" */
  String get flowFrom;

  /** Sets the value of "flow-from" */
  void set flowFrom(var value);

  /** Gets the value of "flow-into" */
  String get flowInto;

  /** Sets the value of "flow-into" */
  void set flowInto(var value);

  /** Gets the value of "font" */
  String get font;

  /** Sets the value of "font" */
  void set font(var value);

  /** Gets the value of "font-family" */
  String get fontFamily;

  /** Sets the value of "font-family" */
  void set fontFamily(var value);

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings;

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value);

  /** Gets the value of "font-size" */
  String get fontSize;

  /** Sets the value of "font-size" */
  void set fontSize(var value);

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta;

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value);

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing;

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value);

  /** Gets the value of "font-stretch" */
  String get fontStretch;

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value);

  /** Gets the value of "font-style" */
  String get fontStyle;

  /** Sets the value of "font-style" */
  void set fontStyle(var value);

  /** Gets the value of "font-variant" */
  String get fontVariant;

  /** Sets the value of "font-variant" */
  void set fontVariant(var value);

  /** Gets the value of "font-weight" */
  String get fontWeight;

  /** Sets the value of "font-weight" */
  void set fontWeight(var value);

  /** @domName CSSStyleDeclaration.getPropertyValue. */
  String getPropertyValue(String propertyName);

  /** Gets the value of "height" */
  String get height;

  /** Sets the value of "height" */
  void set height(var value);

  /** Gets the value of "highlight" */
  String get highlight;

  /** Sets the value of "highlight" */
  void set highlight(var value);

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter;

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value);

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter;

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value);

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore;

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value);

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines;

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value);

  /** Gets the value of "hyphens" */
  String get hyphens;

  /** Sets the value of "hyphens" */
  void set hyphens(var value);

  /** Gets the value of "image-rendering" */
  String get imageRendering;

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value);

  /** Gets the value of "left" */
  String get left;

  /** Sets the value of "left" */
  void set left(var value);

  /** Gets the value of "letter-spacing" */
  String get letterSpacing;

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value);

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain;

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value);

  /** Gets the value of "line-break" */
  String get lineBreak;

  /** Sets the value of "line-break" */
  void set lineBreak(var value);

  /** Gets the value of "line-clamp" */
  String get lineClamp;

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value);

  /** Gets the value of "line-height" */
  String get lineHeight;

  /** Sets the value of "line-height" */
  void set lineHeight(var value);

  /** Gets the value of "list-style" */
  String get listStyle;

  /** Sets the value of "list-style" */
  void set listStyle(var value);

  /** Gets the value of "list-style-image" */
  String get listStyleImage;

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value);

  /** Gets the value of "list-style-position" */
  String get listStylePosition;

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value);

  /** Gets the value of "list-style-type" */
  String get listStyleType;

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value);

  /** Gets the value of "locale" */
  String get locale;

  /** Sets the value of "locale" */
  void set locale(var value);

  /** Gets the value of "logical-height" */
  String get logicalHeight;

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value);

  /** Gets the value of "logical-width" */
  String get logicalWidth;

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value);

  /** Gets the value of "margin" */
  String get margin;

  /** Sets the value of "margin" */
  void set margin(var value);

  /** Gets the value of "margin-after" */
  String get marginAfter;

  /** Sets the value of "margin-after" */
  void set marginAfter(var value);

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse;

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value);

  /** Gets the value of "margin-before" */
  String get marginBefore;

  /** Sets the value of "margin-before" */
  void set marginBefore(var value);

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse;

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value);

  /** Gets the value of "margin-bottom" */
  String get marginBottom;

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value);

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse;

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value);

  /** Gets the value of "margin-collapse" */
  String get marginCollapse;

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value);

  /** Gets the value of "margin-end" */
  String get marginEnd;

  /** Sets the value of "margin-end" */
  void set marginEnd(var value);

  /** Gets the value of "margin-left" */
  String get marginLeft;

  /** Sets the value of "margin-left" */
  void set marginLeft(var value);

  /** Gets the value of "margin-right" */
  String get marginRight;

  /** Sets the value of "margin-right" */
  void set marginRight(var value);

  /** Gets the value of "margin-start" */
  String get marginStart;

  /** Sets the value of "margin-start" */
  void set marginStart(var value);

  /** Gets the value of "margin-top" */
  String get marginTop;

  /** Sets the value of "margin-top" */
  void set marginTop(var value);

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse;

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value);

  /** Gets the value of "marquee" */
  String get marquee;

  /** Sets the value of "marquee" */
  void set marquee(var value);

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection;

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value);

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement;

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value);

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition;

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value);

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed;

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value);

  /** Gets the value of "marquee-style" */
  String get marqueeStyle;

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value);

  /** Gets the value of "mask" */
  String get mask;

  /** Sets the value of "mask" */
  void set mask(var value);

  /** Gets the value of "mask-attachment" */
  String get maskAttachment;

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value);

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage;

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value);

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset;

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value);

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat;

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value);

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice;

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value);

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource;

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value);

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth;

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value);

  /** Gets the value of "mask-clip" */
  String get maskClip;

  /** Sets the value of "mask-clip" */
  void set maskClip(var value);

  /** Gets the value of "mask-composite" */
  String get maskComposite;

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value);

  /** Gets the value of "mask-image" */
  String get maskImage;

  /** Sets the value of "mask-image" */
  void set maskImage(var value);

  /** Gets the value of "mask-origin" */
  String get maskOrigin;

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value);

  /** Gets the value of "mask-position" */
  String get maskPosition;

  /** Sets the value of "mask-position" */
  void set maskPosition(var value);

  /** Gets the value of "mask-position-x" */
  String get maskPositionX;

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value);

  /** Gets the value of "mask-position-y" */
  String get maskPositionY;

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value);

  /** Gets the value of "mask-repeat" */
  String get maskRepeat;

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value);

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX;

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value);

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY;

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value);

  /** Gets the value of "mask-size" */
  String get maskSize;

  /** Sets the value of "mask-size" */
  void set maskSize(var value);

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor;

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value);

  /** Gets the value of "max-height" */
  String get maxHeight;

  /** Sets the value of "max-height" */
  void set maxHeight(var value);

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight;

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value);

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth;

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value);

  /** Gets the value of "max-width" */
  String get maxWidth;

  /** Sets the value of "max-width" */
  void set maxWidth(var value);

  /** Gets the value of "min-height" */
  String get minHeight;

  /** Sets the value of "min-height" */
  void set minHeight(var value);

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight;

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value);

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth;

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value);

  /** Gets the value of "min-width" */
  String get minWidth;

  /** Sets the value of "min-width" */
  void set minWidth(var value);

  /** Gets the value of "nbsp-mode" */
  String get nbspMode;

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value);

  /** Gets the value of "opacity" */
  String get opacity;

  /** Sets the value of "opacity" */
  void set opacity(var value);

  /** Gets the value of "orphans" */
  String get orphans;

  /** Sets the value of "orphans" */
  void set orphans(var value);

  /** Gets the value of "outline" */
  String get outline;

  /** Sets the value of "outline" */
  void set outline(var value);

  /** Gets the value of "outline-color" */
  String get outlineColor;

  /** Sets the value of "outline-color" */
  void set outlineColor(var value);

  /** Gets the value of "outline-offset" */
  String get outlineOffset;

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value);

  /** Gets the value of "outline-style" */
  String get outlineStyle;

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value);

  /** Gets the value of "outline-width" */
  String get outlineWidth;

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value);

  /** Gets the value of "overflow" */
  String get overflow;

  /** Sets the value of "overflow" */
  void set overflow(var value);

  /** Gets the value of "overflow-x" */
  String get overflowX;

  /** Sets the value of "overflow-x" */
  void set overflowX(var value);

  /** Gets the value of "overflow-y" */
  String get overflowY;

  /** Sets the value of "overflow-y" */
  void set overflowY(var value);

  /** Gets the value of "padding" */
  String get padding;

  /** Sets the value of "padding" */
  void set padding(var value);

  /** Gets the value of "padding-after" */
  String get paddingAfter;

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value);

  /** Gets the value of "padding-before" */
  String get paddingBefore;

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value);

  /** Gets the value of "padding-bottom" */
  String get paddingBottom;

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value);

  /** Gets the value of "padding-end" */
  String get paddingEnd;

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value);

  /** Gets the value of "padding-left" */
  String get paddingLeft;

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value);

  /** Gets the value of "padding-right" */
  String get paddingRight;

  /** Sets the value of "padding-right" */
  void set paddingRight(var value);

  /** Gets the value of "padding-start" */
  String get paddingStart;

  /** Sets the value of "padding-start" */
  void set paddingStart(var value);

  /** Gets the value of "padding-top" */
  String get paddingTop;

  /** Sets the value of "padding-top" */
  void set paddingTop(var value);

  /** Gets the value of "page" */
  String get page;

  /** Sets the value of "page" */
  void set page(var value);

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter;

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value);

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore;

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value);

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside;

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value);

  /** Gets the value of "perspective" */
  String get perspective;

  /** Sets the value of "perspective" */
  void set perspective(var value);

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin;

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value);

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX;

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value);

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY;

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value);

  /** Gets the value of "pointer-events" */
  String get pointerEvents;

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value);

  /** Gets the value of "position" */
  String get position;

  /** Sets the value of "position" */
  void set position(var value);

  /** Gets the value of "quotes" */
  String get quotes;

  /** Sets the value of "quotes" */
  void set quotes(var value);

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter;

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value);

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore;

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value);

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside;

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value);

  /** Gets the value of "region-overflow" */
  String get regionOverflow;

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value);

  /** Gets the value of "resize" */
  String get resize;

  /** Sets the value of "resize" */
  void set resize(var value);

  /** Gets the value of "right" */
  String get right;

  /** Sets the value of "right" */
  void set right(var value);

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering;

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value);

  /** Gets the value of "size" */
  String get size;

  /** Sets the value of "size" */
  void set size(var value);

  /** Gets the value of "speak" */
  String get speak;

  /** Sets the value of "speak" */
  void set speak(var value);

  /** Gets the value of "src" */
  String get src;

  /** Sets the value of "src" */
  void set src(var value);

  /** Gets the value of "table-layout" */
  String get tableLayout;

  /** Sets the value of "table-layout" */
  void set tableLayout(var value);

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor;

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value);

  /** Gets the value of "text-align" */
  String get textAlign;

  /** Sets the value of "text-align" */
  void set textAlign(var value);

  /** Gets the value of "text-combine" */
  String get textCombine;

  /** Sets the value of "text-combine" */
  void set textCombine(var value);

  /** Gets the value of "text-decoration" */
  String get textDecoration;

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value);

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect;

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value);

  /** Gets the value of "text-emphasis" */
  String get textEmphasis;

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value);

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor;

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value);

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition;

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value);

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle;

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value);

  /** Gets the value of "text-fill-color" */
  String get textFillColor;

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value);

  /** Gets the value of "text-indent" */
  String get textIndent;

  /** Sets the value of "text-indent" */
  void set textIndent(var value);

  /** Gets the value of "text-line-through" */
  String get textLineThrough;

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value);

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor;

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value);

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode;

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value);

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle;

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value);

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth;

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value);

  /** Gets the value of "text-orientation" */
  String get textOrientation;

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value);

  /** Gets the value of "text-overflow" */
  String get textOverflow;

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value);

  /** Gets the value of "text-overline" */
  String get textOverline;

  /** Sets the value of "text-overline" */
  void set textOverline(var value);

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor;

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value);

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode;

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value);

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle;

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value);

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth;

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value);

  /** Gets the value of "text-rendering" */
  String get textRendering;

  /** Sets the value of "text-rendering" */
  void set textRendering(var value);

  /** Gets the value of "text-security" */
  String get textSecurity;

  /** Sets the value of "text-security" */
  void set textSecurity(var value);

  /** Gets the value of "text-shadow" */
  String get textShadow;

  /** Sets the value of "text-shadow" */
  void set textShadow(var value);

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust;

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value);

  /** Gets the value of "text-stroke" */
  String get textStroke;

  /** Sets the value of "text-stroke" */
  void set textStroke(var value);

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor;

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value);

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth;

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value);

  /** Gets the value of "text-transform" */
  String get textTransform;

  /** Sets the value of "text-transform" */
  void set textTransform(var value);

  /** Gets the value of "text-underline" */
  String get textUnderline;

  /** Sets the value of "text-underline" */
  void set textUnderline(var value);

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor;

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value);

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode;

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value);

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle;

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value);

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth;

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value);

  /** Gets the value of "top" */
  String get top;

  /** Sets the value of "top" */
  void set top(var value);

  /** Gets the value of "transform" */
  String get transform;

  /** Sets the value of "transform" */
  void set transform(var value);

  /** Gets the value of "transform-origin" */
  String get transformOrigin;

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value);

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX;

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value);

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY;

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value);

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ;

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value);

  /** Gets the value of "transform-style" */
  String get transformStyle;

  /** Sets the value of "transform-style" */
  void set transformStyle(var value);

  /** Gets the value of "transition" */
  String get transition;

  /** Sets the value of "transition" */
  void set transition(var value);

  /** Gets the value of "transition-delay" */
  String get transitionDelay;

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value);

  /** Gets the value of "transition-duration" */
  String get transitionDuration;

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value);

  /** Gets the value of "transition-property" */
  String get transitionProperty;

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value);

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction;

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value);

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi;

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value);

  /** Gets the value of "unicode-range" */
  String get unicodeRange;

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value);

  /** Gets the value of "user-drag" */
  String get userDrag;

  /** Sets the value of "user-drag" */
  void set userDrag(var value);

  /** Gets the value of "user-modify" */
  String get userModify;

  /** Sets the value of "user-modify" */
  void set userModify(var value);

  /** Gets the value of "user-select" */
  String get userSelect;

  /** Sets the value of "user-select" */
  void set userSelect(var value);

  /** Gets the value of "vertical-align" */
  String get verticalAlign;

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value);

  /** Gets the value of "visibility" */
  String get visibility;

  /** Sets the value of "visibility" */
  void set visibility(var value);

  /** Gets the value of "white-space" */
  String get whiteSpace;

  /** Sets the value of "white-space" */
  void set whiteSpace(var value);

  /** Gets the value of "widows" */
  String get widows;

  /** Sets the value of "widows" */
  void set widows(var value);

  /** Gets the value of "width" */
  String get width;

  /** Sets the value of "width" */
  void set width(var value);

  /** Gets the value of "word-break" */
  String get wordBreak;

  /** Sets the value of "word-break" */
  void set wordBreak(var value);

  /** Gets the value of "word-spacing" */
  String get wordSpacing;

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value);

  /** Gets the value of "word-wrap" */
  String get wordWrap;

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value);

  /** Gets the value of "wrap-shape" */
  String get wrapShape;

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value);

  /** Gets the value of "writing-mode" */
  String get writingMode;

  /** Sets the value of "writing-mode" */
  void set writingMode(var value);

  /** Gets the value of "z-index" */
  String get zIndex;

  /** Sets the value of "z-index" */
  void set zIndex(var value);

  /** Gets the value of "zoom" */
  String get zoom;

  /** Sets the value of "zoom" */
  void set zoom(var value);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

String _cachedBrowserPrefix;

String get _browserPrefix {
  if (_cachedBrowserPrefix == null) {
    if (_Device.isFirefox) {
      _cachedBrowserPrefix = '-moz-';
    } else if (_Device.isIE) {
      _cachedBrowserPrefix = '-ms-';
    } else if (_Device.isOpera) {
      _cachedBrowserPrefix = '-o-';
    } else {
      _cachedBrowserPrefix = '-webkit-';
    }
  }
  return _cachedBrowserPrefix;
}

class _CSSStyleDeclarationImpl implements CSSStyleDeclaration native "*CSSStyleDeclaration" {


  String cssText;

  final int length;

  final _CSSRuleImpl parentRule;

  _CSSValueImpl getPropertyCSSValue(String propertyName) native;

  String getPropertyPriority(String propertyName) native;

  String getPropertyShorthand(String propertyName) native;

  String _getPropertyValue(String propertyName) native "getPropertyValue";

  bool isPropertyImplicit(String propertyName) native;

  String item(int index) native;

  String removeProperty(String propertyName) native;


  String getPropertyValue(String propertyName) {
    var propValue = _getPropertyValue(propertyName);
    return propValue != null ? propValue : '';
  }

  void setProperty(String propertyName, String value, [String priority]) {
    JS('void', '#.setProperty(#, #, #)', this, propertyName, value, priority);
    // Bug #2772, IE9 requires a poke to actually apply the value.
    if (JS('bool', '!!#.setAttribute', this)) {
      JS('void', '#.setAttribute(#, #)', this, propertyName, value);
    }
  }

  // TODO(jacobr): generate this list of properties using the existing script.
    /** Gets the value of "animation" */
  String get animation =>
    getPropertyValue('${_browserPrefix}animation');

  /** Sets the value of "animation" */
  void set animation(var value) {
    setProperty('${_browserPrefix}animation', value, '');
  }

  /** Gets the value of "animation-delay" */
  String get animationDelay =>
    getPropertyValue('${_browserPrefix}animation-delay');

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value) {
    setProperty('${_browserPrefix}animation-delay', value, '');
  }

  /** Gets the value of "animation-direction" */
  String get animationDirection =>
    getPropertyValue('${_browserPrefix}animation-direction');

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value) {
    setProperty('${_browserPrefix}animation-direction', value, '');
  }

  /** Gets the value of "animation-duration" */
  String get animationDuration =>
    getPropertyValue('${_browserPrefix}animation-duration');

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value) {
    setProperty('${_browserPrefix}animation-duration', value, '');
  }

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode =>
    getPropertyValue('${_browserPrefix}animation-fill-mode');

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value) {
    setProperty('${_browserPrefix}animation-fill-mode', value, '');
  }

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount =>
    getPropertyValue('${_browserPrefix}animation-iteration-count');

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value) {
    setProperty('${_browserPrefix}animation-iteration-count', value, '');
  }

  /** Gets the value of "animation-name" */
  String get animationName =>
    getPropertyValue('${_browserPrefix}animation-name');

  /** Sets the value of "animation-name" */
  void set animationName(var value) {
    setProperty('${_browserPrefix}animation-name', value, '');
  }

  /** Gets the value of "animation-play-state" */
  String get animationPlayState =>
    getPropertyValue('${_browserPrefix}animation-play-state');

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value) {
    setProperty('${_browserPrefix}animation-play-state', value, '');
  }

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction =>
    getPropertyValue('${_browserPrefix}animation-timing-function');

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value) {
    setProperty('${_browserPrefix}animation-timing-function', value, '');
  }

  /** Gets the value of "appearance" */
  String get appearance =>
    getPropertyValue('${_browserPrefix}appearance');

  /** Sets the value of "appearance" */
  void set appearance(var value) {
    setProperty('${_browserPrefix}appearance', value, '');
  }

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility =>
    getPropertyValue('${_browserPrefix}backface-visibility');

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value) {
    setProperty('${_browserPrefix}backface-visibility', value, '');
  }

  /** Gets the value of "background" */
  String get background =>
    getPropertyValue('background');

  /** Sets the value of "background" */
  void set background(var value) {
    setProperty('background', value, '');
  }

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment =>
    getPropertyValue('background-attachment');

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value) {
    setProperty('background-attachment', value, '');
  }

  /** Gets the value of "background-clip" */
  String get backgroundClip =>
    getPropertyValue('background-clip');

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value) {
    setProperty('background-clip', value, '');
  }

  /** Gets the value of "background-color" */
  String get backgroundColor =>
    getPropertyValue('background-color');

  /** Sets the value of "background-color" */
  void set backgroundColor(var value) {
    setProperty('background-color', value, '');
  }

  /** Gets the value of "background-composite" */
  String get backgroundComposite =>
    getPropertyValue('${_browserPrefix}background-composite');

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value) {
    setProperty('${_browserPrefix}background-composite', value, '');
  }

  /** Gets the value of "background-image" */
  String get backgroundImage =>
    getPropertyValue('background-image');

  /** Sets the value of "background-image" */
  void set backgroundImage(var value) {
    setProperty('background-image', value, '');
  }

  /** Gets the value of "background-origin" */
  String get backgroundOrigin =>
    getPropertyValue('background-origin');

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value) {
    setProperty('background-origin', value, '');
  }

  /** Gets the value of "background-position" */
  String get backgroundPosition =>
    getPropertyValue('background-position');

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value) {
    setProperty('background-position', value, '');
  }

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX =>
    getPropertyValue('background-position-x');

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value) {
    setProperty('background-position-x', value, '');
  }

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY =>
    getPropertyValue('background-position-y');

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value) {
    setProperty('background-position-y', value, '');
  }

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat =>
    getPropertyValue('background-repeat');

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value) {
    setProperty('background-repeat', value, '');
  }

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX =>
    getPropertyValue('background-repeat-x');

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value) {
    setProperty('background-repeat-x', value, '');
  }

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY =>
    getPropertyValue('background-repeat-y');

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value) {
    setProperty('background-repeat-y', value, '');
  }

  /** Gets the value of "background-size" */
  String get backgroundSize =>
    getPropertyValue('background-size');

  /** Sets the value of "background-size" */
  void set backgroundSize(var value) {
    setProperty('background-size', value, '');
  }

  /** Gets the value of "border" */
  String get border =>
    getPropertyValue('border');

  /** Sets the value of "border" */
  void set border(var value) {
    setProperty('border', value, '');
  }

  /** Gets the value of "border-after" */
  String get borderAfter =>
    getPropertyValue('${_browserPrefix}border-after');

  /** Sets the value of "border-after" */
  void set borderAfter(var value) {
    setProperty('${_browserPrefix}border-after', value, '');
  }

  /** Gets the value of "border-after-color" */
  String get borderAfterColor =>
    getPropertyValue('${_browserPrefix}border-after-color');

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value) {
    setProperty('${_browserPrefix}border-after-color', value, '');
  }

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle =>
    getPropertyValue('${_browserPrefix}border-after-style');

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value) {
    setProperty('${_browserPrefix}border-after-style', value, '');
  }

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth =>
    getPropertyValue('${_browserPrefix}border-after-width');

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value) {
    setProperty('${_browserPrefix}border-after-width', value, '');
  }

  /** Gets the value of "border-before" */
  String get borderBefore =>
    getPropertyValue('${_browserPrefix}border-before');

  /** Sets the value of "border-before" */
  void set borderBefore(var value) {
    setProperty('${_browserPrefix}border-before', value, '');
  }

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor =>
    getPropertyValue('${_browserPrefix}border-before-color');

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value) {
    setProperty('${_browserPrefix}border-before-color', value, '');
  }

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle =>
    getPropertyValue('${_browserPrefix}border-before-style');

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value) {
    setProperty('${_browserPrefix}border-before-style', value, '');
  }

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth =>
    getPropertyValue('${_browserPrefix}border-before-width');

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value) {
    setProperty('${_browserPrefix}border-before-width', value, '');
  }

  /** Gets the value of "border-bottom" */
  String get borderBottom =>
    getPropertyValue('border-bottom');

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value) {
    setProperty('border-bottom', value, '');
  }

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor =>
    getPropertyValue('border-bottom-color');

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value) {
    setProperty('border-bottom-color', value, '');
  }

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius =>
    getPropertyValue('border-bottom-left-radius');

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value) {
    setProperty('border-bottom-left-radius', value, '');
  }

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius =>
    getPropertyValue('border-bottom-right-radius');

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value) {
    setProperty('border-bottom-right-radius', value, '');
  }

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle =>
    getPropertyValue('border-bottom-style');

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value) {
    setProperty('border-bottom-style', value, '');
  }

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth =>
    getPropertyValue('border-bottom-width');

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value) {
    setProperty('border-bottom-width', value, '');
  }

  /** Gets the value of "border-collapse" */
  String get borderCollapse =>
    getPropertyValue('border-collapse');

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value) {
    setProperty('border-collapse', value, '');
  }

  /** Gets the value of "border-color" */
  String get borderColor =>
    getPropertyValue('border-color');

  /** Sets the value of "border-color" */
  void set borderColor(var value) {
    setProperty('border-color', value, '');
  }

  /** Gets the value of "border-end" */
  String get borderEnd =>
    getPropertyValue('${_browserPrefix}border-end');

  /** Sets the value of "border-end" */
  void set borderEnd(var value) {
    setProperty('${_browserPrefix}border-end', value, '');
  }

  /** Gets the value of "border-end-color" */
  String get borderEndColor =>
    getPropertyValue('${_browserPrefix}border-end-color');

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value) {
    setProperty('${_browserPrefix}border-end-color', value, '');
  }

  /** Gets the value of "border-end-style" */
  String get borderEndStyle =>
    getPropertyValue('${_browserPrefix}border-end-style');

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value) {
    setProperty('${_browserPrefix}border-end-style', value, '');
  }

  /** Gets the value of "border-end-width" */
  String get borderEndWidth =>
    getPropertyValue('${_browserPrefix}border-end-width');

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value) {
    setProperty('${_browserPrefix}border-end-width', value, '');
  }

  /** Gets the value of "border-fit" */
  String get borderFit =>
    getPropertyValue('${_browserPrefix}border-fit');

  /** Sets the value of "border-fit" */
  void set borderFit(var value) {
    setProperty('${_browserPrefix}border-fit', value, '');
  }

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing =>
    getPropertyValue('${_browserPrefix}border-horizontal-spacing');

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value) {
    setProperty('${_browserPrefix}border-horizontal-spacing', value, '');
  }

  /** Gets the value of "border-image" */
  String get borderImage =>
    getPropertyValue('border-image');

  /** Sets the value of "border-image" */
  void set borderImage(var value) {
    setProperty('border-image', value, '');
  }

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset =>
    getPropertyValue('border-image-outset');

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value) {
    setProperty('border-image-outset', value, '');
  }

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat =>
    getPropertyValue('border-image-repeat');

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value) {
    setProperty('border-image-repeat', value, '');
  }

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice =>
    getPropertyValue('border-image-slice');

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value) {
    setProperty('border-image-slice', value, '');
  }

  /** Gets the value of "border-image-source" */
  String get borderImageSource =>
    getPropertyValue('border-image-source');

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value) {
    setProperty('border-image-source', value, '');
  }

  /** Gets the value of "border-image-width" */
  String get borderImageWidth =>
    getPropertyValue('border-image-width');

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value) {
    setProperty('border-image-width', value, '');
  }

  /** Gets the value of "border-left" */
  String get borderLeft =>
    getPropertyValue('border-left');

  /** Sets the value of "border-left" */
  void set borderLeft(var value) {
    setProperty('border-left', value, '');
  }

  /** Gets the value of "border-left-color" */
  String get borderLeftColor =>
    getPropertyValue('border-left-color');

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value) {
    setProperty('border-left-color', value, '');
  }

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle =>
    getPropertyValue('border-left-style');

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value) {
    setProperty('border-left-style', value, '');
  }

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth =>
    getPropertyValue('border-left-width');

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value) {
    setProperty('border-left-width', value, '');
  }

  /** Gets the value of "border-radius" */
  String get borderRadius =>
    getPropertyValue('border-radius');

  /** Sets the value of "border-radius" */
  void set borderRadius(var value) {
    setProperty('border-radius', value, '');
  }

  /** Gets the value of "border-right" */
  String get borderRight =>
    getPropertyValue('border-right');

  /** Sets the value of "border-right" */
  void set borderRight(var value) {
    setProperty('border-right', value, '');
  }

  /** Gets the value of "border-right-color" */
  String get borderRightColor =>
    getPropertyValue('border-right-color');

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value) {
    setProperty('border-right-color', value, '');
  }

  /** Gets the value of "border-right-style" */
  String get borderRightStyle =>
    getPropertyValue('border-right-style');

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value) {
    setProperty('border-right-style', value, '');
  }

  /** Gets the value of "border-right-width" */
  String get borderRightWidth =>
    getPropertyValue('border-right-width');

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value) {
    setProperty('border-right-width', value, '');
  }

  /** Gets the value of "border-spacing" */
  String get borderSpacing =>
    getPropertyValue('border-spacing');

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value) {
    setProperty('border-spacing', value, '');
  }

  /** Gets the value of "border-start" */
  String get borderStart =>
    getPropertyValue('${_browserPrefix}border-start');

  /** Sets the value of "border-start" */
  void set borderStart(var value) {
    setProperty('${_browserPrefix}border-start', value, '');
  }

  /** Gets the value of "border-start-color" */
  String get borderStartColor =>
    getPropertyValue('${_browserPrefix}border-start-color');

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value) {
    setProperty('${_browserPrefix}border-start-color', value, '');
  }

  /** Gets the value of "border-start-style" */
  String get borderStartStyle =>
    getPropertyValue('${_browserPrefix}border-start-style');

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value) {
    setProperty('${_browserPrefix}border-start-style', value, '');
  }

  /** Gets the value of "border-start-width" */
  String get borderStartWidth =>
    getPropertyValue('${_browserPrefix}border-start-width');

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value) {
    setProperty('${_browserPrefix}border-start-width', value, '');
  }

  /** Gets the value of "border-style" */
  String get borderStyle =>
    getPropertyValue('border-style');

  /** Sets the value of "border-style" */
  void set borderStyle(var value) {
    setProperty('border-style', value, '');
  }

  /** Gets the value of "border-top" */
  String get borderTop =>
    getPropertyValue('border-top');

  /** Sets the value of "border-top" */
  void set borderTop(var value) {
    setProperty('border-top', value, '');
  }

  /** Gets the value of "border-top-color" */
  String get borderTopColor =>
    getPropertyValue('border-top-color');

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value) {
    setProperty('border-top-color', value, '');
  }

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius =>
    getPropertyValue('border-top-left-radius');

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value) {
    setProperty('border-top-left-radius', value, '');
  }

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius =>
    getPropertyValue('border-top-right-radius');

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value) {
    setProperty('border-top-right-radius', value, '');
  }

  /** Gets the value of "border-top-style" */
  String get borderTopStyle =>
    getPropertyValue('border-top-style');

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value) {
    setProperty('border-top-style', value, '');
  }

  /** Gets the value of "border-top-width" */
  String get borderTopWidth =>
    getPropertyValue('border-top-width');

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value) {
    setProperty('border-top-width', value, '');
  }

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing =>
    getPropertyValue('${_browserPrefix}border-vertical-spacing');

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value) {
    setProperty('${_browserPrefix}border-vertical-spacing', value, '');
  }

  /** Gets the value of "border-width" */
  String get borderWidth =>
    getPropertyValue('border-width');

  /** Sets the value of "border-width" */
  void set borderWidth(var value) {
    setProperty('border-width', value, '');
  }

  /** Gets the value of "bottom" */
  String get bottom =>
    getPropertyValue('bottom');

  /** Sets the value of "bottom" */
  void set bottom(var value) {
    setProperty('bottom', value, '');
  }

  /** Gets the value of "box-align" */
  String get boxAlign =>
    getPropertyValue('${_browserPrefix}box-align');

  /** Sets the value of "box-align" */
  void set boxAlign(var value) {
    setProperty('${_browserPrefix}box-align', value, '');
  }

  /** Gets the value of "box-direction" */
  String get boxDirection =>
    getPropertyValue('${_browserPrefix}box-direction');

  /** Sets the value of "box-direction" */
  void set boxDirection(var value) {
    setProperty('${_browserPrefix}box-direction', value, '');
  }

  /** Gets the value of "box-flex" */
  String get boxFlex =>
    getPropertyValue('${_browserPrefix}box-flex');

  /** Sets the value of "box-flex" */
  void set boxFlex(var value) {
    setProperty('${_browserPrefix}box-flex', value, '');
  }

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup =>
    getPropertyValue('${_browserPrefix}box-flex-group');

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value) {
    setProperty('${_browserPrefix}box-flex-group', value, '');
  }

  /** Gets the value of "box-lines" */
  String get boxLines =>
    getPropertyValue('${_browserPrefix}box-lines');

  /** Sets the value of "box-lines" */
  void set boxLines(var value) {
    setProperty('${_browserPrefix}box-lines', value, '');
  }

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup =>
    getPropertyValue('${_browserPrefix}box-ordinal-group');

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value) {
    setProperty('${_browserPrefix}box-ordinal-group', value, '');
  }

  /** Gets the value of "box-orient" */
  String get boxOrient =>
    getPropertyValue('${_browserPrefix}box-orient');

  /** Sets the value of "box-orient" */
  void set boxOrient(var value) {
    setProperty('${_browserPrefix}box-orient', value, '');
  }

  /** Gets the value of "box-pack" */
  String get boxPack =>
    getPropertyValue('${_browserPrefix}box-pack');

  /** Sets the value of "box-pack" */
  void set boxPack(var value) {
    setProperty('${_browserPrefix}box-pack', value, '');
  }

  /** Gets the value of "box-reflect" */
  String get boxReflect =>
    getPropertyValue('${_browserPrefix}box-reflect');

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value) {
    setProperty('${_browserPrefix}box-reflect', value, '');
  }

  /** Gets the value of "box-shadow" */
  String get boxShadow =>
    getPropertyValue('box-shadow');

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value) {
    setProperty('box-shadow', value, '');
  }

  /** Gets the value of "box-sizing" */
  String get boxSizing =>
    getPropertyValue('box-sizing');

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value) {
    setProperty('box-sizing', value, '');
  }

  /** Gets the value of "caption-side" */
  String get captionSide =>
    getPropertyValue('caption-side');

  /** Sets the value of "caption-side" */
  void set captionSide(var value) {
    setProperty('caption-side', value, '');
  }

  /** Gets the value of "clear" */
  String get clear =>
    getPropertyValue('clear');

  /** Sets the value of "clear" */
  void set clear(var value) {
    setProperty('clear', value, '');
  }

  /** Gets the value of "clip" */
  String get clip =>
    getPropertyValue('clip');

  /** Sets the value of "clip" */
  void set clip(var value) {
    setProperty('clip', value, '');
  }

  /** Gets the value of "color" */
  String get color =>
    getPropertyValue('color');

  /** Sets the value of "color" */
  void set color(var value) {
    setProperty('color', value, '');
  }

  /** Gets the value of "color-correction" */
  String get colorCorrection =>
    getPropertyValue('${_browserPrefix}color-correction');

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value) {
    setProperty('${_browserPrefix}color-correction', value, '');
  }

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter =>
    getPropertyValue('${_browserPrefix}column-break-after');

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value) {
    setProperty('${_browserPrefix}column-break-after', value, '');
  }

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore =>
    getPropertyValue('${_browserPrefix}column-break-before');

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value) {
    setProperty('${_browserPrefix}column-break-before', value, '');
  }

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside =>
    getPropertyValue('${_browserPrefix}column-break-inside');

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value) {
    setProperty('${_browserPrefix}column-break-inside', value, '');
  }

  /** Gets the value of "column-count" */
  String get columnCount =>
    getPropertyValue('${_browserPrefix}column-count');

  /** Sets the value of "column-count" */
  void set columnCount(var value) {
    setProperty('${_browserPrefix}column-count', value, '');
  }

  /** Gets the value of "column-gap" */
  String get columnGap =>
    getPropertyValue('${_browserPrefix}column-gap');

  /** Sets the value of "column-gap" */
  void set columnGap(var value) {
    setProperty('${_browserPrefix}column-gap', value, '');
  }

  /** Gets the value of "column-rule" */
  String get columnRule =>
    getPropertyValue('${_browserPrefix}column-rule');

  /** Sets the value of "column-rule" */
  void set columnRule(var value) {
    setProperty('${_browserPrefix}column-rule', value, '');
  }

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor =>
    getPropertyValue('${_browserPrefix}column-rule-color');

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value) {
    setProperty('${_browserPrefix}column-rule-color', value, '');
  }

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle =>
    getPropertyValue('${_browserPrefix}column-rule-style');

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value) {
    setProperty('${_browserPrefix}column-rule-style', value, '');
  }

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth =>
    getPropertyValue('${_browserPrefix}column-rule-width');

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value) {
    setProperty('${_browserPrefix}column-rule-width', value, '');
  }

  /** Gets the value of "column-span" */
  String get columnSpan =>
    getPropertyValue('${_browserPrefix}column-span');

  /** Sets the value of "column-span" */
  void set columnSpan(var value) {
    setProperty('${_browserPrefix}column-span', value, '');
  }

  /** Gets the value of "column-width" */
  String get columnWidth =>
    getPropertyValue('${_browserPrefix}column-width');

  /** Sets the value of "column-width" */
  void set columnWidth(var value) {
    setProperty('${_browserPrefix}column-width', value, '');
  }

  /** Gets the value of "columns" */
  String get columns =>
    getPropertyValue('${_browserPrefix}columns');

  /** Sets the value of "columns" */
  void set columns(var value) {
    setProperty('${_browserPrefix}columns', value, '');
  }

  /** Gets the value of "content" */
  String get content =>
    getPropertyValue('content');

  /** Sets the value of "content" */
  void set content(var value) {
    setProperty('content', value, '');
  }

  /** Gets the value of "counter-increment" */
  String get counterIncrement =>
    getPropertyValue('counter-increment');

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value) {
    setProperty('counter-increment', value, '');
  }

  /** Gets the value of "counter-reset" */
  String get counterReset =>
    getPropertyValue('counter-reset');

  /** Sets the value of "counter-reset" */
  void set counterReset(var value) {
    setProperty('counter-reset', value, '');
  }

  /** Gets the value of "cursor" */
  String get cursor =>
    getPropertyValue('cursor');

  /** Sets the value of "cursor" */
  void set cursor(var value) {
    setProperty('cursor', value, '');
  }

  /** Gets the value of "direction" */
  String get direction =>
    getPropertyValue('direction');

  /** Sets the value of "direction" */
  void set direction(var value) {
    setProperty('direction', value, '');
  }

  /** Gets the value of "display" */
  String get display =>
    getPropertyValue('display');

  /** Sets the value of "display" */
  void set display(var value) {
    setProperty('display', value, '');
  }

  /** Gets the value of "empty-cells" */
  String get emptyCells =>
    getPropertyValue('empty-cells');

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value) {
    setProperty('empty-cells', value, '');
  }

  /** Gets the value of "filter" */
  String get filter =>
    getPropertyValue('${_browserPrefix}filter');

  /** Sets the value of "filter" */
  void set filter(var value) {
    setProperty('${_browserPrefix}filter', value, '');
  }

  /** Gets the value of "flex-align" */
  String get flexAlign =>
    getPropertyValue('${_browserPrefix}flex-align');

  /** Sets the value of "flex-align" */
  void set flexAlign(var value) {
    setProperty('${_browserPrefix}flex-align', value, '');
  }

  /** Gets the value of "flex-flow" */
  String get flexFlow =>
    getPropertyValue('${_browserPrefix}flex-flow');

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value) {
    setProperty('${_browserPrefix}flex-flow', value, '');
  }

  /** Gets the value of "flex-order" */
  String get flexOrder =>
    getPropertyValue('${_browserPrefix}flex-order');

  /** Sets the value of "flex-order" */
  void set flexOrder(var value) {
    setProperty('${_browserPrefix}flex-order', value, '');
  }

  /** Gets the value of "flex-pack" */
  String get flexPack =>
    getPropertyValue('${_browserPrefix}flex-pack');

  /** Sets the value of "flex-pack" */
  void set flexPack(var value) {
    setProperty('${_browserPrefix}flex-pack', value, '');
  }

  /** Gets the value of "float" */
  String get float =>
    getPropertyValue('float');

  /** Sets the value of "float" */
  void set float(var value) {
    setProperty('float', value, '');
  }

  /** Gets the value of "flow-from" */
  String get flowFrom =>
    getPropertyValue('${_browserPrefix}flow-from');

  /** Sets the value of "flow-from" */
  void set flowFrom(var value) {
    setProperty('${_browserPrefix}flow-from', value, '');
  }

  /** Gets the value of "flow-into" */
  String get flowInto =>
    getPropertyValue('${_browserPrefix}flow-into');

  /** Sets the value of "flow-into" */
  void set flowInto(var value) {
    setProperty('${_browserPrefix}flow-into', value, '');
  }

  /** Gets the value of "font" */
  String get font =>
    getPropertyValue('font');

  /** Sets the value of "font" */
  void set font(var value) {
    setProperty('font', value, '');
  }

  /** Gets the value of "font-family" */
  String get fontFamily =>
    getPropertyValue('font-family');

  /** Sets the value of "font-family" */
  void set fontFamily(var value) {
    setProperty('font-family', value, '');
  }

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings =>
    getPropertyValue('${_browserPrefix}font-feature-settings');

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value) {
    setProperty('${_browserPrefix}font-feature-settings', value, '');
  }

  /** Gets the value of "font-size" */
  String get fontSize =>
    getPropertyValue('font-size');

  /** Sets the value of "font-size" */
  void set fontSize(var value) {
    setProperty('font-size', value, '');
  }

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta =>
    getPropertyValue('${_browserPrefix}font-size-delta');

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value) {
    setProperty('${_browserPrefix}font-size-delta', value, '');
  }

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing =>
    getPropertyValue('${_browserPrefix}font-smoothing');

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value) {
    setProperty('${_browserPrefix}font-smoothing', value, '');
  }

  /** Gets the value of "font-stretch" */
  String get fontStretch =>
    getPropertyValue('font-stretch');

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value) {
    setProperty('font-stretch', value, '');
  }

  /** Gets the value of "font-style" */
  String get fontStyle =>
    getPropertyValue('font-style');

  /** Sets the value of "font-style" */
  void set fontStyle(var value) {
    setProperty('font-style', value, '');
  }

  /** Gets the value of "font-variant" */
  String get fontVariant =>
    getPropertyValue('font-variant');

  /** Sets the value of "font-variant" */
  void set fontVariant(var value) {
    setProperty('font-variant', value, '');
  }

  /** Gets the value of "font-weight" */
  String get fontWeight =>
    getPropertyValue('font-weight');

  /** Sets the value of "font-weight" */
  void set fontWeight(var value) {
    setProperty('font-weight', value, '');
  }

  /** Gets the value of "height" */
  String get height =>
    getPropertyValue('height');

  /** Sets the value of "height" */
  void set height(var value) {
    setProperty('height', value, '');
  }

  /** Gets the value of "highlight" */
  String get highlight =>
    getPropertyValue('${_browserPrefix}highlight');

  /** Sets the value of "highlight" */
  void set highlight(var value) {
    setProperty('${_browserPrefix}highlight', value, '');
  }

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter =>
    getPropertyValue('${_browserPrefix}hyphenate-character');

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value) {
    setProperty('${_browserPrefix}hyphenate-character', value, '');
  }

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-after');

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-after', value, '');
  }

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-before');

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-before', value, '');
  }

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-lines');

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-lines', value, '');
  }

  /** Gets the value of "hyphens" */
  String get hyphens =>
    getPropertyValue('${_browserPrefix}hyphens');

  /** Sets the value of "hyphens" */
  void set hyphens(var value) {
    setProperty('${_browserPrefix}hyphens', value, '');
  }

  /** Gets the value of "image-rendering" */
  String get imageRendering =>
    getPropertyValue('image-rendering');

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value) {
    setProperty('image-rendering', value, '');
  }

  /** Gets the value of "left" */
  String get left =>
    getPropertyValue('left');

  /** Sets the value of "left" */
  void set left(var value) {
    setProperty('left', value, '');
  }

  /** Gets the value of "letter-spacing" */
  String get letterSpacing =>
    getPropertyValue('letter-spacing');

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value) {
    setProperty('letter-spacing', value, '');
  }

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain =>
    getPropertyValue('${_browserPrefix}line-box-contain');

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value) {
    setProperty('${_browserPrefix}line-box-contain', value, '');
  }

  /** Gets the value of "line-break" */
  String get lineBreak =>
    getPropertyValue('${_browserPrefix}line-break');

  /** Sets the value of "line-break" */
  void set lineBreak(var value) {
    setProperty('${_browserPrefix}line-break', value, '');
  }

  /** Gets the value of "line-clamp" */
  String get lineClamp =>
    getPropertyValue('${_browserPrefix}line-clamp');

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value) {
    setProperty('${_browserPrefix}line-clamp', value, '');
  }

  /** Gets the value of "line-height" */
  String get lineHeight =>
    getPropertyValue('line-height');

  /** Sets the value of "line-height" */
  void set lineHeight(var value) {
    setProperty('line-height', value, '');
  }

  /** Gets the value of "list-style" */
  String get listStyle =>
    getPropertyValue('list-style');

  /** Sets the value of "list-style" */
  void set listStyle(var value) {
    setProperty('list-style', value, '');
  }

  /** Gets the value of "list-style-image" */
  String get listStyleImage =>
    getPropertyValue('list-style-image');

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value) {
    setProperty('list-style-image', value, '');
  }

  /** Gets the value of "list-style-position" */
  String get listStylePosition =>
    getPropertyValue('list-style-position');

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value) {
    setProperty('list-style-position', value, '');
  }

  /** Gets the value of "list-style-type" */
  String get listStyleType =>
    getPropertyValue('list-style-type');

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value) {
    setProperty('list-style-type', value, '');
  }

  /** Gets the value of "locale" */
  String get locale =>
    getPropertyValue('${_browserPrefix}locale');

  /** Sets the value of "locale" */
  void set locale(var value) {
    setProperty('${_browserPrefix}locale', value, '');
  }

  /** Gets the value of "logical-height" */
  String get logicalHeight =>
    getPropertyValue('${_browserPrefix}logical-height');

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value) {
    setProperty('${_browserPrefix}logical-height', value, '');
  }

  /** Gets the value of "logical-width" */
  String get logicalWidth =>
    getPropertyValue('${_browserPrefix}logical-width');

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value) {
    setProperty('${_browserPrefix}logical-width', value, '');
  }

  /** Gets the value of "margin" */
  String get margin =>
    getPropertyValue('margin');

  /** Sets the value of "margin" */
  void set margin(var value) {
    setProperty('margin', value, '');
  }

  /** Gets the value of "margin-after" */
  String get marginAfter =>
    getPropertyValue('${_browserPrefix}margin-after');

  /** Sets the value of "margin-after" */
  void set marginAfter(var value) {
    setProperty('${_browserPrefix}margin-after', value, '');
  }

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse =>
    getPropertyValue('${_browserPrefix}margin-after-collapse');

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value) {
    setProperty('${_browserPrefix}margin-after-collapse', value, '');
  }

  /** Gets the value of "margin-before" */
  String get marginBefore =>
    getPropertyValue('${_browserPrefix}margin-before');

  /** Sets the value of "margin-before" */
  void set marginBefore(var value) {
    setProperty('${_browserPrefix}margin-before', value, '');
  }

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse =>
    getPropertyValue('${_browserPrefix}margin-before-collapse');

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value) {
    setProperty('${_browserPrefix}margin-before-collapse', value, '');
  }

  /** Gets the value of "margin-bottom" */
  String get marginBottom =>
    getPropertyValue('margin-bottom');

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value) {
    setProperty('margin-bottom', value, '');
  }

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse =>
    getPropertyValue('${_browserPrefix}margin-bottom-collapse');

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value) {
    setProperty('${_browserPrefix}margin-bottom-collapse', value, '');
  }

  /** Gets the value of "margin-collapse" */
  String get marginCollapse =>
    getPropertyValue('${_browserPrefix}margin-collapse');

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value) {
    setProperty('${_browserPrefix}margin-collapse', value, '');
  }

  /** Gets the value of "margin-end" */
  String get marginEnd =>
    getPropertyValue('${_browserPrefix}margin-end');

  /** Sets the value of "margin-end" */
  void set marginEnd(var value) {
    setProperty('${_browserPrefix}margin-end', value, '');
  }

  /** Gets the value of "margin-left" */
  String get marginLeft =>
    getPropertyValue('margin-left');

  /** Sets the value of "margin-left" */
  void set marginLeft(var value) {
    setProperty('margin-left', value, '');
  }

  /** Gets the value of "margin-right" */
  String get marginRight =>
    getPropertyValue('margin-right');

  /** Sets the value of "margin-right" */
  void set marginRight(var value) {
    setProperty('margin-right', value, '');
  }

  /** Gets the value of "margin-start" */
  String get marginStart =>
    getPropertyValue('${_browserPrefix}margin-start');

  /** Sets the value of "margin-start" */
  void set marginStart(var value) {
    setProperty('${_browserPrefix}margin-start', value, '');
  }

  /** Gets the value of "margin-top" */
  String get marginTop =>
    getPropertyValue('margin-top');

  /** Sets the value of "margin-top" */
  void set marginTop(var value) {
    setProperty('margin-top', value, '');
  }

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse =>
    getPropertyValue('${_browserPrefix}margin-top-collapse');

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value) {
    setProperty('${_browserPrefix}margin-top-collapse', value, '');
  }

  /** Gets the value of "marquee" */
  String get marquee =>
    getPropertyValue('${_browserPrefix}marquee');

  /** Sets the value of "marquee" */
  void set marquee(var value) {
    setProperty('${_browserPrefix}marquee', value, '');
  }

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection =>
    getPropertyValue('${_browserPrefix}marquee-direction');

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value) {
    setProperty('${_browserPrefix}marquee-direction', value, '');
  }

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement =>
    getPropertyValue('${_browserPrefix}marquee-increment');

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value) {
    setProperty('${_browserPrefix}marquee-increment', value, '');
  }

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition =>
    getPropertyValue('${_browserPrefix}marquee-repetition');

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value) {
    setProperty('${_browserPrefix}marquee-repetition', value, '');
  }

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed =>
    getPropertyValue('${_browserPrefix}marquee-speed');

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value) {
    setProperty('${_browserPrefix}marquee-speed', value, '');
  }

  /** Gets the value of "marquee-style" */
  String get marqueeStyle =>
    getPropertyValue('${_browserPrefix}marquee-style');

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value) {
    setProperty('${_browserPrefix}marquee-style', value, '');
  }

  /** Gets the value of "mask" */
  String get mask =>
    getPropertyValue('${_browserPrefix}mask');

  /** Sets the value of "mask" */
  void set mask(var value) {
    setProperty('${_browserPrefix}mask', value, '');
  }

  /** Gets the value of "mask-attachment" */
  String get maskAttachment =>
    getPropertyValue('${_browserPrefix}mask-attachment');

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value) {
    setProperty('${_browserPrefix}mask-attachment', value, '');
  }

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage =>
    getPropertyValue('${_browserPrefix}mask-box-image');

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value) {
    setProperty('${_browserPrefix}mask-box-image', value, '');
  }

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset =>
    getPropertyValue('${_browserPrefix}mask-box-image-outset');

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value) {
    setProperty('${_browserPrefix}mask-box-image-outset', value, '');
  }

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat =>
    getPropertyValue('${_browserPrefix}mask-box-image-repeat');

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value) {
    setProperty('${_browserPrefix}mask-box-image-repeat', value, '');
  }

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice =>
    getPropertyValue('${_browserPrefix}mask-box-image-slice');

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value) {
    setProperty('${_browserPrefix}mask-box-image-slice', value, '');
  }

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource =>
    getPropertyValue('${_browserPrefix}mask-box-image-source');

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value) {
    setProperty('${_browserPrefix}mask-box-image-source', value, '');
  }

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth =>
    getPropertyValue('${_browserPrefix}mask-box-image-width');

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value) {
    setProperty('${_browserPrefix}mask-box-image-width', value, '');
  }

  /** Gets the value of "mask-clip" */
  String get maskClip =>
    getPropertyValue('${_browserPrefix}mask-clip');

  /** Sets the value of "mask-clip" */
  void set maskClip(var value) {
    setProperty('${_browserPrefix}mask-clip', value, '');
  }

  /** Gets the value of "mask-composite" */
  String get maskComposite =>
    getPropertyValue('${_browserPrefix}mask-composite');

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value) {
    setProperty('${_browserPrefix}mask-composite', value, '');
  }

  /** Gets the value of "mask-image" */
  String get maskImage =>
    getPropertyValue('${_browserPrefix}mask-image');

  /** Sets the value of "mask-image" */
  void set maskImage(var value) {
    setProperty('${_browserPrefix}mask-image', value, '');
  }

  /** Gets the value of "mask-origin" */
  String get maskOrigin =>
    getPropertyValue('${_browserPrefix}mask-origin');

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value) {
    setProperty('${_browserPrefix}mask-origin', value, '');
  }

  /** Gets the value of "mask-position" */
  String get maskPosition =>
    getPropertyValue('${_browserPrefix}mask-position');

  /** Sets the value of "mask-position" */
  void set maskPosition(var value) {
    setProperty('${_browserPrefix}mask-position', value, '');
  }

  /** Gets the value of "mask-position-x" */
  String get maskPositionX =>
    getPropertyValue('${_browserPrefix}mask-position-x');

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value) {
    setProperty('${_browserPrefix}mask-position-x', value, '');
  }

  /** Gets the value of "mask-position-y" */
  String get maskPositionY =>
    getPropertyValue('${_browserPrefix}mask-position-y');

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value) {
    setProperty('${_browserPrefix}mask-position-y', value, '');
  }

  /** Gets the value of "mask-repeat" */
  String get maskRepeat =>
    getPropertyValue('${_browserPrefix}mask-repeat');

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value) {
    setProperty('${_browserPrefix}mask-repeat', value, '');
  }

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX =>
    getPropertyValue('${_browserPrefix}mask-repeat-x');

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value) {
    setProperty('${_browserPrefix}mask-repeat-x', value, '');
  }

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY =>
    getPropertyValue('${_browserPrefix}mask-repeat-y');

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value) {
    setProperty('${_browserPrefix}mask-repeat-y', value, '');
  }

  /** Gets the value of "mask-size" */
  String get maskSize =>
    getPropertyValue('${_browserPrefix}mask-size');

  /** Sets the value of "mask-size" */
  void set maskSize(var value) {
    setProperty('${_browserPrefix}mask-size', value, '');
  }

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor =>
    getPropertyValue('${_browserPrefix}match-nearest-mail-blockquote-color');

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value) {
    setProperty('${_browserPrefix}match-nearest-mail-blockquote-color', value, '');
  }

  /** Gets the value of "max-height" */
  String get maxHeight =>
    getPropertyValue('max-height');

  /** Sets the value of "max-height" */
  void set maxHeight(var value) {
    setProperty('max-height', value, '');
  }

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight =>
    getPropertyValue('${_browserPrefix}max-logical-height');

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value) {
    setProperty('${_browserPrefix}max-logical-height', value, '');
  }

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth =>
    getPropertyValue('${_browserPrefix}max-logical-width');

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value) {
    setProperty('${_browserPrefix}max-logical-width', value, '');
  }

  /** Gets the value of "max-width" */
  String get maxWidth =>
    getPropertyValue('max-width');

  /** Sets the value of "max-width" */
  void set maxWidth(var value) {
    setProperty('max-width', value, '');
  }

  /** Gets the value of "min-height" */
  String get minHeight =>
    getPropertyValue('min-height');

  /** Sets the value of "min-height" */
  void set minHeight(var value) {
    setProperty('min-height', value, '');
  }

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight =>
    getPropertyValue('${_browserPrefix}min-logical-height');

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value) {
    setProperty('${_browserPrefix}min-logical-height', value, '');
  }

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth =>
    getPropertyValue('${_browserPrefix}min-logical-width');

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value) {
    setProperty('${_browserPrefix}min-logical-width', value, '');
  }

  /** Gets the value of "min-width" */
  String get minWidth =>
    getPropertyValue('min-width');

  /** Sets the value of "min-width" */
  void set minWidth(var value) {
    setProperty('min-width', value, '');
  }

  /** Gets the value of "nbsp-mode" */
  String get nbspMode =>
    getPropertyValue('${_browserPrefix}nbsp-mode');

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value) {
    setProperty('${_browserPrefix}nbsp-mode', value, '');
  }

  /** Gets the value of "opacity" */
  String get opacity =>
    getPropertyValue('opacity');

  /** Sets the value of "opacity" */
  void set opacity(var value) {
    setProperty('opacity', value, '');
  }

  /** Gets the value of "orphans" */
  String get orphans =>
    getPropertyValue('orphans');

  /** Sets the value of "orphans" */
  void set orphans(var value) {
    setProperty('orphans', value, '');
  }

  /** Gets the value of "outline" */
  String get outline =>
    getPropertyValue('outline');

  /** Sets the value of "outline" */
  void set outline(var value) {
    setProperty('outline', value, '');
  }

  /** Gets the value of "outline-color" */
  String get outlineColor =>
    getPropertyValue('outline-color');

  /** Sets the value of "outline-color" */
  void set outlineColor(var value) {
    setProperty('outline-color', value, '');
  }

  /** Gets the value of "outline-offset" */
  String get outlineOffset =>
    getPropertyValue('outline-offset');

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value) {
    setProperty('outline-offset', value, '');
  }

  /** Gets the value of "outline-style" */
  String get outlineStyle =>
    getPropertyValue('outline-style');

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value) {
    setProperty('outline-style', value, '');
  }

  /** Gets the value of "outline-width" */
  String get outlineWidth =>
    getPropertyValue('outline-width');

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value) {
    setProperty('outline-width', value, '');
  }

  /** Gets the value of "overflow" */
  String get overflow =>
    getPropertyValue('overflow');

  /** Sets the value of "overflow" */
  void set overflow(var value) {
    setProperty('overflow', value, '');
  }

  /** Gets the value of "overflow-x" */
  String get overflowX =>
    getPropertyValue('overflow-x');

  /** Sets the value of "overflow-x" */
  void set overflowX(var value) {
    setProperty('overflow-x', value, '');
  }

  /** Gets the value of "overflow-y" */
  String get overflowY =>
    getPropertyValue('overflow-y');

  /** Sets the value of "overflow-y" */
  void set overflowY(var value) {
    setProperty('overflow-y', value, '');
  }

  /** Gets the value of "padding" */
  String get padding =>
    getPropertyValue('padding');

  /** Sets the value of "padding" */
  void set padding(var value) {
    setProperty('padding', value, '');
  }

  /** Gets the value of "padding-after" */
  String get paddingAfter =>
    getPropertyValue('${_browserPrefix}padding-after');

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value) {
    setProperty('${_browserPrefix}padding-after', value, '');
  }

  /** Gets the value of "padding-before" */
  String get paddingBefore =>
    getPropertyValue('${_browserPrefix}padding-before');

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value) {
    setProperty('${_browserPrefix}padding-before', value, '');
  }

  /** Gets the value of "padding-bottom" */
  String get paddingBottom =>
    getPropertyValue('padding-bottom');

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value) {
    setProperty('padding-bottom', value, '');
  }

  /** Gets the value of "padding-end" */
  String get paddingEnd =>
    getPropertyValue('${_browserPrefix}padding-end');

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value) {
    setProperty('${_browserPrefix}padding-end', value, '');
  }

  /** Gets the value of "padding-left" */
  String get paddingLeft =>
    getPropertyValue('padding-left');

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value) {
    setProperty('padding-left', value, '');
  }

  /** Gets the value of "padding-right" */
  String get paddingRight =>
    getPropertyValue('padding-right');

  /** Sets the value of "padding-right" */
  void set paddingRight(var value) {
    setProperty('padding-right', value, '');
  }

  /** Gets the value of "padding-start" */
  String get paddingStart =>
    getPropertyValue('${_browserPrefix}padding-start');

  /** Sets the value of "padding-start" */
  void set paddingStart(var value) {
    setProperty('${_browserPrefix}padding-start', value, '');
  }

  /** Gets the value of "padding-top" */
  String get paddingTop =>
    getPropertyValue('padding-top');

  /** Sets the value of "padding-top" */
  void set paddingTop(var value) {
    setProperty('padding-top', value, '');
  }

  /** Gets the value of "page" */
  String get page =>
    getPropertyValue('page');

  /** Sets the value of "page" */
  void set page(var value) {
    setProperty('page', value, '');
  }

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter =>
    getPropertyValue('page-break-after');

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value) {
    setProperty('page-break-after', value, '');
  }

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore =>
    getPropertyValue('page-break-before');

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value) {
    setProperty('page-break-before', value, '');
  }

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside =>
    getPropertyValue('page-break-inside');

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value) {
    setProperty('page-break-inside', value, '');
  }

  /** Gets the value of "perspective" */
  String get perspective =>
    getPropertyValue('${_browserPrefix}perspective');

  /** Sets the value of "perspective" */
  void set perspective(var value) {
    setProperty('${_browserPrefix}perspective', value, '');
  }

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin =>
    getPropertyValue('${_browserPrefix}perspective-origin');

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value) {
    setProperty('${_browserPrefix}perspective-origin', value, '');
  }

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX =>
    getPropertyValue('${_browserPrefix}perspective-origin-x');

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value) {
    setProperty('${_browserPrefix}perspective-origin-x', value, '');
  }

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY =>
    getPropertyValue('${_browserPrefix}perspective-origin-y');

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value) {
    setProperty('${_browserPrefix}perspective-origin-y', value, '');
  }

  /** Gets the value of "pointer-events" */
  String get pointerEvents =>
    getPropertyValue('pointer-events');

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value) {
    setProperty('pointer-events', value, '');
  }

  /** Gets the value of "position" */
  String get position =>
    getPropertyValue('position');

  /** Sets the value of "position" */
  void set position(var value) {
    setProperty('position', value, '');
  }

  /** Gets the value of "quotes" */
  String get quotes =>
    getPropertyValue('quotes');

  /** Sets the value of "quotes" */
  void set quotes(var value) {
    setProperty('quotes', value, '');
  }

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter =>
    getPropertyValue('${_browserPrefix}region-break-after');

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value) {
    setProperty('${_browserPrefix}region-break-after', value, '');
  }

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore =>
    getPropertyValue('${_browserPrefix}region-break-before');

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value) {
    setProperty('${_browserPrefix}region-break-before', value, '');
  }

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside =>
    getPropertyValue('${_browserPrefix}region-break-inside');

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value) {
    setProperty('${_browserPrefix}region-break-inside', value, '');
  }

  /** Gets the value of "region-overflow" */
  String get regionOverflow =>
    getPropertyValue('${_browserPrefix}region-overflow');

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value) {
    setProperty('${_browserPrefix}region-overflow', value, '');
  }

  /** Gets the value of "resize" */
  String get resize =>
    getPropertyValue('resize');

  /** Sets the value of "resize" */
  void set resize(var value) {
    setProperty('resize', value, '');
  }

  /** Gets the value of "right" */
  String get right =>
    getPropertyValue('right');

  /** Sets the value of "right" */
  void set right(var value) {
    setProperty('right', value, '');
  }

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering =>
    getPropertyValue('${_browserPrefix}rtl-ordering');

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value) {
    setProperty('${_browserPrefix}rtl-ordering', value, '');
  }

  /** Gets the value of "size" */
  String get size =>
    getPropertyValue('size');

  /** Sets the value of "size" */
  void set size(var value) {
    setProperty('size', value, '');
  }

  /** Gets the value of "speak" */
  String get speak =>
    getPropertyValue('speak');

  /** Sets the value of "speak" */
  void set speak(var value) {
    setProperty('speak', value, '');
  }

  /** Gets the value of "src" */
  String get src =>
    getPropertyValue('src');

  /** Sets the value of "src" */
  void set src(var value) {
    setProperty('src', value, '');
  }

  /** Gets the value of "table-layout" */
  String get tableLayout =>
    getPropertyValue('table-layout');

  /** Sets the value of "table-layout" */
  void set tableLayout(var value) {
    setProperty('table-layout', value, '');
  }

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor =>
    getPropertyValue('${_browserPrefix}tap-highlight-color');

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value) {
    setProperty('${_browserPrefix}tap-highlight-color', value, '');
  }

  /** Gets the value of "text-align" */
  String get textAlign =>
    getPropertyValue('text-align');

  /** Sets the value of "text-align" */
  void set textAlign(var value) {
    setProperty('text-align', value, '');
  }

  /** Gets the value of "text-combine" */
  String get textCombine =>
    getPropertyValue('${_browserPrefix}text-combine');

  /** Sets the value of "text-combine" */
  void set textCombine(var value) {
    setProperty('${_browserPrefix}text-combine', value, '');
  }

  /** Gets the value of "text-decoration" */
  String get textDecoration =>
    getPropertyValue('text-decoration');

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value) {
    setProperty('text-decoration', value, '');
  }

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect =>
    getPropertyValue('${_browserPrefix}text-decorations-in-effect');

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value) {
    setProperty('${_browserPrefix}text-decorations-in-effect', value, '');
  }

  /** Gets the value of "text-emphasis" */
  String get textEmphasis =>
    getPropertyValue('${_browserPrefix}text-emphasis');

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value) {
    setProperty('${_browserPrefix}text-emphasis', value, '');
  }

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor =>
    getPropertyValue('${_browserPrefix}text-emphasis-color');

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value) {
    setProperty('${_browserPrefix}text-emphasis-color', value, '');
  }

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition =>
    getPropertyValue('${_browserPrefix}text-emphasis-position');

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value) {
    setProperty('${_browserPrefix}text-emphasis-position', value, '');
  }

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle =>
    getPropertyValue('${_browserPrefix}text-emphasis-style');

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value) {
    setProperty('${_browserPrefix}text-emphasis-style', value, '');
  }

  /** Gets the value of "text-fill-color" */
  String get textFillColor =>
    getPropertyValue('${_browserPrefix}text-fill-color');

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value) {
    setProperty('${_browserPrefix}text-fill-color', value, '');
  }

  /** Gets the value of "text-indent" */
  String get textIndent =>
    getPropertyValue('text-indent');

  /** Sets the value of "text-indent" */
  void set textIndent(var value) {
    setProperty('text-indent', value, '');
  }

  /** Gets the value of "text-line-through" */
  String get textLineThrough =>
    getPropertyValue('text-line-through');

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value) {
    setProperty('text-line-through', value, '');
  }

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor =>
    getPropertyValue('text-line-through-color');

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value) {
    setProperty('text-line-through-color', value, '');
  }

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode =>
    getPropertyValue('text-line-through-mode');

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value) {
    setProperty('text-line-through-mode', value, '');
  }

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle =>
    getPropertyValue('text-line-through-style');

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value) {
    setProperty('text-line-through-style', value, '');
  }

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth =>
    getPropertyValue('text-line-through-width');

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value) {
    setProperty('text-line-through-width', value, '');
  }

  /** Gets the value of "text-orientation" */
  String get textOrientation =>
    getPropertyValue('${_browserPrefix}text-orientation');

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value) {
    setProperty('${_browserPrefix}text-orientation', value, '');
  }

  /** Gets the value of "text-overflow" */
  String get textOverflow =>
    getPropertyValue('text-overflow');

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value) {
    setProperty('text-overflow', value, '');
  }

  /** Gets the value of "text-overline" */
  String get textOverline =>
    getPropertyValue('text-overline');

  /** Sets the value of "text-overline" */
  void set textOverline(var value) {
    setProperty('text-overline', value, '');
  }

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor =>
    getPropertyValue('text-overline-color');

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value) {
    setProperty('text-overline-color', value, '');
  }

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode =>
    getPropertyValue('text-overline-mode');

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value) {
    setProperty('text-overline-mode', value, '');
  }

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle =>
    getPropertyValue('text-overline-style');

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value) {
    setProperty('text-overline-style', value, '');
  }

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth =>
    getPropertyValue('text-overline-width');

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value) {
    setProperty('text-overline-width', value, '');
  }

  /** Gets the value of "text-rendering" */
  String get textRendering =>
    getPropertyValue('text-rendering');

  /** Sets the value of "text-rendering" */
  void set textRendering(var value) {
    setProperty('text-rendering', value, '');
  }

  /** Gets the value of "text-security" */
  String get textSecurity =>
    getPropertyValue('${_browserPrefix}text-security');

  /** Sets the value of "text-security" */
  void set textSecurity(var value) {
    setProperty('${_browserPrefix}text-security', value, '');
  }

  /** Gets the value of "text-shadow" */
  String get textShadow =>
    getPropertyValue('text-shadow');

  /** Sets the value of "text-shadow" */
  void set textShadow(var value) {
    setProperty('text-shadow', value, '');
  }

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust =>
    getPropertyValue('${_browserPrefix}text-size-adjust');

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value) {
    setProperty('${_browserPrefix}text-size-adjust', value, '');
  }

  /** Gets the value of "text-stroke" */
  String get textStroke =>
    getPropertyValue('${_browserPrefix}text-stroke');

  /** Sets the value of "text-stroke" */
  void set textStroke(var value) {
    setProperty('${_browserPrefix}text-stroke', value, '');
  }

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor =>
    getPropertyValue('${_browserPrefix}text-stroke-color');

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value) {
    setProperty('${_browserPrefix}text-stroke-color', value, '');
  }

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth =>
    getPropertyValue('${_browserPrefix}text-stroke-width');

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value) {
    setProperty('${_browserPrefix}text-stroke-width', value, '');
  }

  /** Gets the value of "text-transform" */
  String get textTransform =>
    getPropertyValue('text-transform');

  /** Sets the value of "text-transform" */
  void set textTransform(var value) {
    setProperty('text-transform', value, '');
  }

  /** Gets the value of "text-underline" */
  String get textUnderline =>
    getPropertyValue('text-underline');

  /** Sets the value of "text-underline" */
  void set textUnderline(var value) {
    setProperty('text-underline', value, '');
  }

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor =>
    getPropertyValue('text-underline-color');

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value) {
    setProperty('text-underline-color', value, '');
  }

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode =>
    getPropertyValue('text-underline-mode');

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value) {
    setProperty('text-underline-mode', value, '');
  }

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle =>
    getPropertyValue('text-underline-style');

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value) {
    setProperty('text-underline-style', value, '');
  }

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth =>
    getPropertyValue('text-underline-width');

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value) {
    setProperty('text-underline-width', value, '');
  }

  /** Gets the value of "top" */
  String get top =>
    getPropertyValue('top');

  /** Sets the value of "top" */
  void set top(var value) {
    setProperty('top', value, '');
  }

  /** Gets the value of "transform" */
  String get transform =>
    getPropertyValue('${_browserPrefix}transform');

  /** Sets the value of "transform" */
  void set transform(var value) {
    setProperty('${_browserPrefix}transform', value, '');
  }

  /** Gets the value of "transform-origin" */
  String get transformOrigin =>
    getPropertyValue('${_browserPrefix}transform-origin');

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value) {
    setProperty('${_browserPrefix}transform-origin', value, '');
  }

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX =>
    getPropertyValue('${_browserPrefix}transform-origin-x');

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value) {
    setProperty('${_browserPrefix}transform-origin-x', value, '');
  }

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY =>
    getPropertyValue('${_browserPrefix}transform-origin-y');

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value) {
    setProperty('${_browserPrefix}transform-origin-y', value, '');
  }

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ =>
    getPropertyValue('${_browserPrefix}transform-origin-z');

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value) {
    setProperty('${_browserPrefix}transform-origin-z', value, '');
  }

  /** Gets the value of "transform-style" */
  String get transformStyle =>
    getPropertyValue('${_browserPrefix}transform-style');

  /** Sets the value of "transform-style" */
  void set transformStyle(var value) {
    setProperty('${_browserPrefix}transform-style', value, '');
  }

  /** Gets the value of "transition" */
  String get transition =>
    getPropertyValue('${_browserPrefix}transition');

  /** Sets the value of "transition" */
  void set transition(var value) {
    setProperty('${_browserPrefix}transition', value, '');
  }

  /** Gets the value of "transition-delay" */
  String get transitionDelay =>
    getPropertyValue('${_browserPrefix}transition-delay');

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value) {
    setProperty('${_browserPrefix}transition-delay', value, '');
  }

  /** Gets the value of "transition-duration" */
  String get transitionDuration =>
    getPropertyValue('${_browserPrefix}transition-duration');

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value) {
    setProperty('${_browserPrefix}transition-duration', value, '');
  }

  /** Gets the value of "transition-property" */
  String get transitionProperty =>
    getPropertyValue('${_browserPrefix}transition-property');

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value) {
    setProperty('${_browserPrefix}transition-property', value, '');
  }

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction =>
    getPropertyValue('${_browserPrefix}transition-timing-function');

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value) {
    setProperty('${_browserPrefix}transition-timing-function', value, '');
  }

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi =>
    getPropertyValue('unicode-bidi');

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value) {
    setProperty('unicode-bidi', value, '');
  }

  /** Gets the value of "unicode-range" */
  String get unicodeRange =>
    getPropertyValue('unicode-range');

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value) {
    setProperty('unicode-range', value, '');
  }

  /** Gets the value of "user-drag" */
  String get userDrag =>
    getPropertyValue('${_browserPrefix}user-drag');

  /** Sets the value of "user-drag" */
  void set userDrag(var value) {
    setProperty('${_browserPrefix}user-drag', value, '');
  }

  /** Gets the value of "user-modify" */
  String get userModify =>
    getPropertyValue('${_browserPrefix}user-modify');

  /** Sets the value of "user-modify" */
  void set userModify(var value) {
    setProperty('${_browserPrefix}user-modify', value, '');
  }

  /** Gets the value of "user-select" */
  String get userSelect =>
    getPropertyValue('${_browserPrefix}user-select');

  /** Sets the value of "user-select" */
  void set userSelect(var value) {
    setProperty('${_browserPrefix}user-select', value, '');
  }

  /** Gets the value of "vertical-align" */
  String get verticalAlign =>
    getPropertyValue('vertical-align');

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value) {
    setProperty('vertical-align', value, '');
  }

  /** Gets the value of "visibility" */
  String get visibility =>
    getPropertyValue('visibility');

  /** Sets the value of "visibility" */
  void set visibility(var value) {
    setProperty('visibility', value, '');
  }

  /** Gets the value of "white-space" */
  String get whiteSpace =>
    getPropertyValue('white-space');

  /** Sets the value of "white-space" */
  void set whiteSpace(var value) {
    setProperty('white-space', value, '');
  }

  /** Gets the value of "widows" */
  String get widows =>
    getPropertyValue('widows');

  /** Sets the value of "widows" */
  void set widows(var value) {
    setProperty('widows', value, '');
  }

  /** Gets the value of "width" */
  String get width =>
    getPropertyValue('width');

  /** Sets the value of "width" */
  void set width(var value) {
    setProperty('width', value, '');
  }

  /** Gets the value of "word-break" */
  String get wordBreak =>
    getPropertyValue('word-break');

  /** Sets the value of "word-break" */
  void set wordBreak(var value) {
    setProperty('word-break', value, '');
  }

  /** Gets the value of "word-spacing" */
  String get wordSpacing =>
    getPropertyValue('word-spacing');

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value) {
    setProperty('word-spacing', value, '');
  }

  /** Gets the value of "word-wrap" */
  String get wordWrap =>
    getPropertyValue('word-wrap');

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value) {
    setProperty('word-wrap', value, '');
  }

  /** Gets the value of "wrap-shape" */
  String get wrapShape =>
    getPropertyValue('${_browserPrefix}wrap-shape');

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value) {
    setProperty('${_browserPrefix}wrap-shape', value, '');
  }

  /** Gets the value of "writing-mode" */
  String get writingMode =>
    getPropertyValue('${_browserPrefix}writing-mode');

  /** Sets the value of "writing-mode" */
  void set writingMode(var value) {
    setProperty('${_browserPrefix}writing-mode', value, '');
  }

  /** Gets the value of "z-index" */
  String get zIndex =>
    getPropertyValue('z-index');

  /** Sets the value of "z-index" */
  void set zIndex(var value) {
    setProperty('z-index', value, '');
  }

  /** Gets the value of "zoom" */
  String get zoom =>
    getPropertyValue('zoom');

  /** Sets the value of "zoom" */
  void set zoom(var value) {
    setProperty('zoom', value, '');
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleRule
abstract class CSSStyleRule implements CSSRule {

  /** @domName CSSStyleRule.selectorText */
  String selectorText;

  /** @domName CSSStyleRule.style */
  CSSStyleDeclaration get style;
}

class _CSSStyleRuleImpl extends _CSSRuleImpl implements CSSStyleRule native "*CSSStyleRule" {

  String selectorText;

  final _CSSStyleDeclarationImpl style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleSheet
abstract class CSSStyleSheet implements StyleSheet {

  /** @domName CSSStyleSheet.cssRules */
  List<CSSRule> get cssRules;

  /** @domName CSSStyleSheet.ownerRule */
  CSSRule get ownerRule;

  /** @domName CSSStyleSheet.rules */
  List<CSSRule> get rules;

  /** @domName CSSStyleSheet.addRule */
  int addRule(String selector, String style, [int index]);

  /** @domName CSSStyleSheet.deleteRule */
  void deleteRule(int index);

  /** @domName CSSStyleSheet.insertRule */
  int insertRule(String rule, int index);

  /** @domName CSSStyleSheet.removeRule */
  void removeRule(int index);
}

class _CSSStyleSheetImpl extends _StyleSheetImpl implements CSSStyleSheet native "*CSSStyleSheet" {

  final _CSSRuleListImpl cssRules;

  final _CSSRuleImpl ownerRule;

  final _CSSRuleListImpl rules;

  int addRule(String selector, String style, [int index]) native;

  void deleteRule(int index) native;

  int insertRule(String rule, int index) native;

  void removeRule(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSTransformValue
abstract class CSSTransformValue implements List<CSSValue> {

  static const int CSS_MATRIX = 11;

  static const int CSS_MATRIX3D = 21;

  static const int CSS_PERSPECTIVE = 20;

  static const int CSS_ROTATE = 4;

  static const int CSS_ROTATE3D = 17;

  static const int CSS_ROTATEX = 14;

  static const int CSS_ROTATEY = 15;

  static const int CSS_ROTATEZ = 16;

  static const int CSS_SCALE = 5;

  static const int CSS_SCALE3D = 19;

  static const int CSS_SCALEX = 6;

  static const int CSS_SCALEY = 7;

  static const int CSS_SCALEZ = 18;

  static const int CSS_SKEW = 8;

  static const int CSS_SKEWX = 9;

  static const int CSS_SKEWY = 10;

  static const int CSS_TRANSLATE = 1;

  static const int CSS_TRANSLATE3D = 13;

  static const int CSS_TRANSLATEX = 2;

  static const int CSS_TRANSLATEY = 3;

  static const int CSS_TRANSLATEZ = 12;

  /** @domName WebKitCSSTransformValue.operationType */
  int get operationType;
}

class _CSSTransformValueImpl extends _CSSValueListImpl implements CSSTransformValue native "*WebKitCSSTransformValue" {

  final int operationType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSUnknownRule
abstract class CSSUnknownRule implements CSSRule {
}

class _CSSUnknownRuleImpl extends _CSSRuleImpl implements CSSUnknownRule native "*CSSUnknownRule" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSValue
abstract class CSSValue {

  static const int CSS_CUSTOM = 3;

  static const int CSS_INHERIT = 0;

  static const int CSS_PRIMITIVE_VALUE = 1;

  static const int CSS_VALUE_LIST = 2;

  /** @domName CSSValue.cssText */
  String cssText;

  /** @domName CSSValue.cssValueType */
  int get cssValueType;
}

class _CSSValueImpl implements CSSValue native "*CSSValue" {

  String cssText;

  final int cssValueType;
}

class _CSSValueListImpl extends _CSSValueImpl implements List<CSSValue>, JavaScriptIndexingBehavior native "*CSSValueList" {

  final int length;

  _CSSValueImpl operator[](int index) => JS("_CSSValueImpl", "#[#]", this, index);

  void operator[]=(int index, _CSSValueImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<CSSValue> mixins.
  // CSSValue is the element type.

  // From Iterable<CSSValue>:

  Iterator<CSSValue> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<CSSValue>(this);
  }

  // From Collection<CSSValue>:

  void add(CSSValue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(CSSValue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<CSSValue> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(CSSValue element) => _Collections.contains(this, element);

  void forEach(void f(CSSValue element)) => _Collections.forEach(this, f);

  Collection map(f(CSSValue element)) => _Collections.map(this, [], f);

  Collection<CSSValue> filter(bool f(CSSValue element)) =>
     _Collections.filter(this, <CSSValue>[], f);

  bool every(bool f(CSSValue element)) => _Collections.every(this, f);

  bool some(bool f(CSSValue element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<CSSValue>:

  void sort([Comparator<CSSValue> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(CSSValue element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(CSSValue element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  CSSValue get last => this[length - 1];

  CSSValue removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<CSSValue> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [CSSValue initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<CSSValue> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <CSSValue>[]);

  // -- end List<CSSValue> mixins.

  _CSSValueImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName HTMLCanvasElement
abstract class CanvasElement implements Element {

  factory CanvasElement({int width, int height}) {
    if (!?width) {
      return _Elements.createCanvasElement();
    }
    if (!?height) {
      return _Elements.createCanvasElement(width);
    }
    return _Elements.createCanvasElement(width, height);
  }

  /** @domName HTMLCanvasElement.height */
  int height;

  /** @domName HTMLCanvasElement.width */
  int width;

  /** @domName HTMLCanvasElement.getContext */
  Object getContext(String contextId);

  /** @domName HTMLCanvasElement.toDataURL */
  String toDataURL(String type, [num quality]);

  final CanvasRenderingContext2D context2d;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _CanvasElementImpl extends _ElementImpl implements CanvasElement native "*HTMLCanvasElement" {

  int height;

  int width;

  Object getContext(String contextId) native;

  String toDataURL(String type, [num quality]) native;


  _CanvasRenderingContext2DImpl get context2d => getContext('2d');
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasGradient
abstract class CanvasGradient {

  /** @domName CanvasGradient.addColorStop */
  void addColorStop(num offset, String color);
}

class _CanvasGradientImpl implements CanvasGradient native "*CanvasGradient" {

  void addColorStop(num offset, String color) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasPattern
abstract class CanvasPattern {
}

class _CanvasPatternImpl implements CanvasPattern native "*CanvasPattern" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasRenderingContext
abstract class CanvasRenderingContext {

  /** @domName CanvasRenderingContext.canvas */
  CanvasElement get canvas;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName CanvasRenderingContext2D
abstract class CanvasRenderingContext2D implements CanvasRenderingContext {

  /** @domName CanvasRenderingContext2D.fillStyle */
  dynamic fillStyle;

  /** @domName CanvasRenderingContext2D.font */
  String font;

  /** @domName CanvasRenderingContext2D.globalAlpha */
  num globalAlpha;

  /** @domName CanvasRenderingContext2D.globalCompositeOperation */
  String globalCompositeOperation;

  /** @domName CanvasRenderingContext2D.lineCap */
  String lineCap;

  /** @domName CanvasRenderingContext2D.lineDashOffset */
  num lineDashOffset;

  /** @domName CanvasRenderingContext2D.lineJoin */
  String lineJoin;

  /** @domName CanvasRenderingContext2D.lineWidth */
  num lineWidth;

  /** @domName CanvasRenderingContext2D.miterLimit */
  num miterLimit;

  /** @domName CanvasRenderingContext2D.shadowBlur */
  num shadowBlur;

  /** @domName CanvasRenderingContext2D.shadowColor */
  String shadowColor;

  /** @domName CanvasRenderingContext2D.shadowOffsetX */
  num shadowOffsetX;

  /** @domName CanvasRenderingContext2D.shadowOffsetY */
  num shadowOffsetY;

  /** @domName CanvasRenderingContext2D.strokeStyle */
  dynamic strokeStyle;

  /** @domName CanvasRenderingContext2D.textAlign */
  String textAlign;

  /** @domName CanvasRenderingContext2D.textBaseline */
  String textBaseline;

  /** @domName CanvasRenderingContext2D.webkitBackingStorePixelRatio */
  num get webkitBackingStorePixelRatio;

  /** @domName CanvasRenderingContext2D.webkitImageSmoothingEnabled */
  bool webkitImageSmoothingEnabled;

  /** @domName CanvasRenderingContext2D.webkitLineDash */
  List webkitLineDash;

  /** @domName CanvasRenderingContext2D.webkitLineDashOffset */
  num webkitLineDashOffset;

  /** @domName CanvasRenderingContext2D.arc */
  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise);

  /** @domName CanvasRenderingContext2D.arcTo */
  void arcTo(num x1, num y1, num x2, num y2, num radius);

  /** @domName CanvasRenderingContext2D.beginPath */
  void beginPath();

  /** @domName CanvasRenderingContext2D.bezierCurveTo */
  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y);

  /** @domName CanvasRenderingContext2D.clearRect */
  void clearRect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.clearShadow */
  void clearShadow();

  /** @domName CanvasRenderingContext2D.clip */
  void clip();

  /** @domName CanvasRenderingContext2D.closePath */
  void closePath();

  /** @domName CanvasRenderingContext2D.createImageData */
  ImageData createImageData(imagedata_OR_sw, [num sh]);

  /** @domName CanvasRenderingContext2D.createLinearGradient */
  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1);

  /** @domName CanvasRenderingContext2D.createPattern */
  CanvasPattern createPattern(canvas_OR_image, String repetitionType);

  /** @domName CanvasRenderingContext2D.createRadialGradient */
  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1);

  /** @domName CanvasRenderingContext2D.drawImage */
  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width, num height_OR_sh, num dx, num dy, num dw, num dh]);

  /** @domName CanvasRenderingContext2D.drawImageFromRect */
  void drawImageFromRect(ImageElement image, [num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh, String compositeOperation]);

  /** @domName CanvasRenderingContext2D.fill */
  void fill();

  /** @domName CanvasRenderingContext2D.fillRect */
  void fillRect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.fillText */
  void fillText(String text, num x, num y, [num maxWidth]);

  /** @domName CanvasRenderingContext2D.getImageData */
  ImageData getImageData(num sx, num sy, num sw, num sh);

  /** @domName CanvasRenderingContext2D.getLineDash */
  List<num> getLineDash();

  /** @domName CanvasRenderingContext2D.isPointInPath */
  bool isPointInPath(num x, num y);

  /** @domName CanvasRenderingContext2D.lineTo */
  void lineTo(num x, num y);

  /** @domName CanvasRenderingContext2D.measureText */
  TextMetrics measureText(String text);

  /** @domName CanvasRenderingContext2D.moveTo */
  void moveTo(num x, num y);

  /** @domName CanvasRenderingContext2D.putImageData */
  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);

  /** @domName CanvasRenderingContext2D.quadraticCurveTo */
  void quadraticCurveTo(num cpx, num cpy, num x, num y);

  /** @domName CanvasRenderingContext2D.rect */
  void rect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.restore */
  void restore();

  /** @domName CanvasRenderingContext2D.rotate */
  void rotate(num angle);

  /** @domName CanvasRenderingContext2D.save */
  void save();

  /** @domName CanvasRenderingContext2D.scale */
  void scale(num sx, num sy);

  /** @domName CanvasRenderingContext2D.setAlpha */
  void setAlpha(num alpha);

  /** @domName CanvasRenderingContext2D.setCompositeOperation */
  void setCompositeOperation(String compositeOperation);

  /** @domName CanvasRenderingContext2D.setLineCap */
  void setLineCap(String cap);

  /** @domName CanvasRenderingContext2D.setLineDash */
  void setLineDash(List<num> dash);

  /** @domName CanvasRenderingContext2D.setLineJoin */
  void setLineJoin(String join);

  /** @domName CanvasRenderingContext2D.setLineWidth */
  void setLineWidth(num width);

  /** @domName CanvasRenderingContext2D.setMiterLimit */
  void setMiterLimit(num limit);

  /** @domName CanvasRenderingContext2D.setShadow */
  void setShadow(num width, num height, num blur, [c_OR_color_OR_grayLevel_OR_r, num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  /** @domName CanvasRenderingContext2D.setTransform */
  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy);

  /** @domName CanvasRenderingContext2D.stroke */
  void stroke();

  /** @domName CanvasRenderingContext2D.strokeRect */
  void strokeRect(num x, num y, num width, num height, [num lineWidth]);

  /** @domName CanvasRenderingContext2D.strokeText */
  void strokeText(String text, num x, num y, [num maxWidth]);

  /** @domName CanvasRenderingContext2D.transform */
  void transform(num m11, num m12, num m21, num m22, num dx, num dy);

  /** @domName CanvasRenderingContext2D.translate */
  void translate(num tx, num ty);

  /** @domName CanvasRenderingContext2D.webkitGetImageDataHD */
  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh);

  /** @domName CanvasRenderingContext2D.webkitPutImageDataHD */
  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);


  /**
   * Sets the color used inside shapes.
   * [r], [g], [b] are 0-255, [a] is 0-1.
   */
  void setFillColorRgb(int r, int g, int b, [num a]);

  /**
   * Sets the color used inside shapes.
   * [h] is in degrees, 0-360.
   * [s], [l] are in percent, 0-100.
   * [a] is 0-1.
   */
  void setFillColorHsl(int h, num s, num l, [num a]);

  /**
   * Sets the color used for stroking shapes.
   * [r], [g], [b] are 0-255, [a] is 0-1.
   */
  void setStrokeColorRgb(int r, int g, int b, [num a]);

  /**
   * Sets the color used for stroking shapes.
   * [h] is in degrees, 0-360.
   * [s], [l] are in percent, 0-100.
   * [a] is 0-1.
   */
  void setStrokeColorHsl(int h, num s, num l, [num a]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _CanvasRenderingContext2DImpl extends _CanvasRenderingContextImpl implements CanvasRenderingContext2D native "*CanvasRenderingContext2D" {

  dynamic fillStyle;

  String font;

  num globalAlpha;

  String globalCompositeOperation;

  String lineCap;

  num lineDashOffset;

  String lineJoin;

  num lineWidth;

  num miterLimit;

  num shadowBlur;

  String shadowColor;

  num shadowOffsetX;

  num shadowOffsetY;

  dynamic strokeStyle;

  String textAlign;

  String textBaseline;

  final num webkitBackingStorePixelRatio;

  bool webkitImageSmoothingEnabled;

  List webkitLineDash;

  num webkitLineDashOffset;

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) native;

  void arcTo(num x1, num y1, num x2, num y2, num radius) native;

  void beginPath() native;

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) native;

  void clearRect(num x, num y, num width, num height) native;

  void clearShadow() native;

  void clip() native;

  void closePath() native;

  ImageData createImageData(imagedata_OR_sw, [sh]) {
    if ((imagedata_OR_sw is ImageData || imagedata_OR_sw == null) &&
        !?sh) {
      var imagedata_1 = _convertDartToNative_ImageData(imagedata_OR_sw);
      return _convertNativeToDart_ImageData(_createImageData_1(imagedata_1));
    }
    if ((imagedata_OR_sw is num || imagedata_OR_sw == null) &&
        (sh is num || sh == null)) {
      return _convertNativeToDart_ImageData(_createImageData_2(imagedata_OR_sw, sh));
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _createImageData_1(imagedata) native "createImageData";
  _createImageData_2(num sw, num sh) native "createImageData";

  _CanvasGradientImpl createLinearGradient(num x0, num y0, num x1, num y1) native;

  _CanvasPatternImpl createPattern(canvas_OR_image, String repetitionType) native;

  _CanvasGradientImpl createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) native;

  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width, num height_OR_sh, num dx, num dy, num dw, num dh]) native;

  void drawImageFromRect(_ImageElementImpl image, [num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh, String compositeOperation]) native;

  void fill() native;

  void fillRect(num x, num y, num width, num height) native;

  void fillText(String text, num x, num y, [num maxWidth]) native;

  ImageData getImageData(num sx, num sy, num sw, num sh) {
    return _convertNativeToDart_ImageData(_getImageData_1(sx, sy, sw, sh));
  }
  _getImageData_1(sx, sy, sw, sh) native "getImageData";

  List<num> getLineDash() native;

  bool isPointInPath(num x, num y) native;

  void lineTo(num x, num y) native;

  _TextMetricsImpl measureText(String text) native;

  void moveTo(num x, num y) native;

  void putImageData(ImageData imagedata, num dx, num dy, [dirtyX, dirtyY, dirtyWidth, dirtyHeight]) {
    if (!?dirtyX &&
        !?dirtyY &&
        !?dirtyWidth &&
        !?dirtyHeight) {
      var imagedata_1 = _convertDartToNative_ImageData(imagedata);
      _putImageData_1(imagedata_1, dx, dy);
      return;
    }
    if ((dirtyX is num || dirtyX == null) &&
        (dirtyY is num || dirtyY == null) &&
        (dirtyWidth is num || dirtyWidth == null) &&
        (dirtyHeight is num || dirtyHeight == null)) {
      var imagedata_2 = _convertDartToNative_ImageData(imagedata);
      _putImageData_2(imagedata_2, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
      return;
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  void _putImageData_1(imagedata, dx, dy) native "putImageData";
  void _putImageData_2(imagedata, dx, dy, num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight) native "putImageData";

  void quadraticCurveTo(num cpx, num cpy, num x, num y) native;

  void rect(num x, num y, num width, num height) native;

  void restore() native;

  void rotate(num angle) native;

  void save() native;

  void scale(num sx, num sy) native;

  void setAlpha(num alpha) native;

  void setCompositeOperation(String compositeOperation) native;

  void setLineCap(String cap) native;

  void setLineDash(List<num> dash) native;

  void setLineJoin(String join) native;

  void setLineWidth(num width) native;

  void setMiterLimit(num limit) native;

  void setShadow(num width, num height, num blur, [c_OR_color_OR_grayLevel_OR_r, num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]) native;

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) native;

  void stroke() native;

  void strokeRect(num x, num y, num width, num height, [num lineWidth]) native;

  void strokeText(String text, num x, num y, [num maxWidth]) native;

  void transform(num m11, num m12, num m21, num m22, num dx, num dy) native;

  void translate(num tx, num ty) native;

  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh) {
    return _convertNativeToDart_ImageData(_webkitGetImageDataHD_1(sx, sy, sw, sh));
  }
  _webkitGetImageDataHD_1(sx, sy, sw, sh) native "webkitGetImageDataHD";

  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [dirtyX, dirtyY, dirtyWidth, dirtyHeight]) {
    if (!?dirtyX &&
        !?dirtyY &&
        !?dirtyWidth &&
        !?dirtyHeight) {
      var imagedata_1 = _convertDartToNative_ImageData(imagedata);
      _webkitPutImageDataHD_1(imagedata_1, dx, dy);
      return;
    }
    if ((dirtyX is num || dirtyX == null) &&
        (dirtyY is num || dirtyY == null) &&
        (dirtyWidth is num || dirtyWidth == null) &&
        (dirtyHeight is num || dirtyHeight == null)) {
      var imagedata_2 = _convertDartToNative_ImageData(imagedata);
      _webkitPutImageDataHD_2(imagedata_2, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
      return;
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  void _webkitPutImageDataHD_1(imagedata, dx, dy) native "webkitPutImageDataHD";
  void _webkitPutImageDataHD_2(imagedata, dx, dy, num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight) native "webkitPutImageDataHD";


  void setFillColorRgb(int r, int g, int b, [num a = 1]) {
    this.fillStyle = 'rgba($r, $g, $b, $a)';
  }

  void setFillColorHsl(int h, num s, num l, [num a = 1]) {
    this.fillStyle = 'hsla($h, $s%, $l%, $a)';
  }

  void setStrokeColorRgb(int r, int g, int b, [num a = 1]) {
    this.strokeStyle = 'rgba($r, $g, $b, $a)';
  }

  void setStrokeColorHsl(int h, num s, num l, [num a = 1]) {
    this.strokeStyle = 'hsla($h, $s%, $l%, $a)';
  }
}

class _CanvasRenderingContextImpl implements CanvasRenderingContext native "*CanvasRenderingContext" {

  final _CanvasElementImpl canvas;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ChannelMergerNode
abstract class ChannelMergerNode implements AudioNode {
}

class _ChannelMergerNodeImpl extends _AudioNodeImpl implements ChannelMergerNode native "*ChannelMergerNode" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ChannelSplitterNode
abstract class ChannelSplitterNode implements AudioNode {
}

class _ChannelSplitterNodeImpl extends _AudioNodeImpl implements ChannelSplitterNode native "*ChannelSplitterNode" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CharacterData
abstract class CharacterData implements Node {

  /** @domName CharacterData.data */
  String data;

  /** @domName CharacterData.length */
  int get length;

  /** @domName CharacterData.appendData */
  void appendData(String data);

  /** @domName CharacterData.deleteData */
  void deleteData(int offset, int length);

  /** @domName CharacterData.insertData */
  void insertData(int offset, String data);

  /** @domName CharacterData.remove */
  void remove();

  /** @domName CharacterData.replaceData */
  void replaceData(int offset, int length, String data);

  /** @domName CharacterData.substringData */
  String substringData(int offset, int length);
}

class _CharacterDataImpl extends _NodeImpl implements CharacterData native "*CharacterData" {

  String data;

  final int length;

  void appendData(String data) native;

  void deleteData(int offset, int length) native;

  void insertData(int offset, String data) native;

  void remove() native;

  void replaceData(int offset, int length, String data) native;

  String substringData(int offset, int length) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ClientRect
abstract class ClientRect {

  /** @domName ClientRect.bottom */
  num get bottom;

  /** @domName ClientRect.height */
  num get height;

  /** @domName ClientRect.left */
  num get left;

  /** @domName ClientRect.right */
  num get right;

  /** @domName ClientRect.top */
  num get top;

  /** @domName ClientRect.width */
  num get width;
}

class _ClientRectImpl implements ClientRect native "*ClientRect" {

  final num bottom;

  final num height;

  final num left;

  final num right;

  final num top;

  final num width;
}

class _ClientRectListImpl implements List<ClientRect>, JavaScriptIndexingBehavior native "*ClientRectList" {

  final int length;

  _ClientRectImpl operator[](int index) => JS("_ClientRectImpl", "#[#]", this, index);

  void operator[]=(int index, _ClientRectImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<ClientRect> mixins.
  // ClientRect is the element type.

  // From Iterable<ClientRect>:

  Iterator<ClientRect> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<ClientRect>(this);
  }

  // From Collection<ClientRect>:

  void add(ClientRect value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(ClientRect value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<ClientRect> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(ClientRect element) => _Collections.contains(this, element);

  void forEach(void f(ClientRect element)) => _Collections.forEach(this, f);

  Collection map(f(ClientRect element)) => _Collections.map(this, [], f);

  Collection<ClientRect> filter(bool f(ClientRect element)) =>
     _Collections.filter(this, <ClientRect>[], f);

  bool every(bool f(ClientRect element)) => _Collections.every(this, f);

  bool some(bool f(ClientRect element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<ClientRect>:

  void sort([Comparator<ClientRect> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(ClientRect element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(ClientRect element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  ClientRect get last => this[length - 1];

  ClientRect removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<ClientRect> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [ClientRect initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<ClientRect> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <ClientRect>[]);

  // -- end List<ClientRect> mixins.

  _ClientRectImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Clipboard
abstract class Clipboard {

  /** @domName Clipboard.dropEffect */
  String dropEffect;

  /** @domName Clipboard.effectAllowed */
  String effectAllowed;

  /** @domName Clipboard.files */
  List<File> get files;

  /** @domName Clipboard.items */
  DataTransferItemList get items;

  /** @domName Clipboard.types */
  List get types;

  /** @domName Clipboard.clearData */
  void clearData([String type]);

  /** @domName Clipboard.getData */
  String getData(String type);

  /** @domName Clipboard.setData */
  bool setData(String type, String data);

  /** @domName Clipboard.setDragImage */
  void setDragImage(ImageElement image, int x, int y);
}

class _ClipboardImpl implements Clipboard native "*Clipboard" {

  String dropEffect;

  String effectAllowed;

  final _FileListImpl files;

  final _DataTransferItemListImpl items;

  final List types;

  void clearData([String type]) native;

  String getData(String type) native;

  bool setData(String type, String data) native;

  void setDragImage(_ImageElementImpl image, int x, int y) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CloseEvent
abstract class CloseEvent implements Event {

  /** @domName CloseEvent.code */
  int get code;

  /** @domName CloseEvent.reason */
  String get reason;

  /** @domName CloseEvent.wasClean */
  bool get wasClean;
}

class _CloseEventImpl extends _EventImpl implements CloseEvent native "*CloseEvent" {

  final int code;

  final String reason;

  final bool wasClean;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Comment
abstract class Comment implements CharacterData {
}

class _CommentImpl extends _CharacterDataImpl implements Comment native "*Comment" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CompositionEvent
abstract class CompositionEvent implements UIEvent {

  /** @domName CompositionEvent.data */
  String get data;

  /** @domName CompositionEvent.initCompositionEvent */
  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, LocalWindow viewArg, String dataArg);
}

class _CompositionEventImpl extends _UIEventImpl implements CompositionEvent native "*CompositionEvent" {

  final String data;

  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, _LocalWindowImpl viewArg, String dataArg) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Console
abstract class Console {

  /** @domName Console.memory */
  MemoryInfo get memory;

  /** @domName Console.profiles */
  List<ScriptProfile> get profiles;

  /** @domName Console.assertCondition */
  void assertCondition(bool condition, Object arg);

  /** @domName Console.count */
  void count(Object arg);

  /** @domName Console.debug */
  void debug(Object arg);

  /** @domName Console.dir */
  void dir(Object arg);

  /** @domName Console.dirxml */
  void dirxml(Object arg);

  /** @domName Console.error */
  void error(Object arg);

  /** @domName Console.group */
  void group(Object arg);

  /** @domName Console.groupCollapsed */
  void groupCollapsed(Object arg);

  /** @domName Console.groupEnd */
  void groupEnd();

  /** @domName Console.info */
  void info(Object arg);

  /** @domName Console.log */
  void log(Object arg);

  /** @domName Console.markTimeline */
  void markTimeline(Object arg);

  /** @domName Console.profile */
  void profile(String title);

  /** @domName Console.profileEnd */
  void profileEnd(String title);

  /** @domName Console.time */
  void time(String title);

  /** @domName Console.timeEnd */
  void timeEnd(String title, Object arg);

  /** @domName Console.timeStamp */
  void timeStamp(Object arg);

  /** @domName Console.trace */
  void trace(Object arg);

  /** @domName Console.warn */
  void warn(Object arg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ConsoleImpl
    // Console is sometimes a singleton bag-of-properties without a prototype.
    implements Console
    native "=(typeof console == 'undefined' ? {} : console)" {

  final _MemoryInfoImpl memory;

  final List<ScriptProfile> profiles;

  void assertCondition(bool condition, Object arg) native;

  void count(Object arg) native;

  void debug(Object arg) native;

  void dir(Object arg) native;

  void dirxml(Object arg) native;

  void error(Object arg) native;

  void group(Object arg) native;

  void groupCollapsed(Object arg) native;

  void groupEnd() native;

  void info(Object arg) native;

  void log(Object arg) native;

  void markTimeline(Object arg) native;

  void profile(String title) native;

  void profileEnd(String title) native;

  void time(String title) native;

  void timeEnd(String title, Object arg) native;

  void timeStamp(Object arg) native;

  void trace(Object arg) native;

  void warn(Object arg) native;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLContentElement
abstract class ContentElement implements Element {

  factory ContentElement() => _Elements.createContentElement();

  /** @domName HTMLContentElement.resetStyleInheritance */
  bool resetStyleInheritance;

  /** @domName HTMLContentElement.select */
  String select;

  /** @domName HTMLContentElement.getDistributedNodes */
  List<Node> getDistributedNodes();
}

class _ContentElementImpl extends _ElementImpl implements ContentElement native "*HTMLContentElement" {

  bool resetStyleInheritance;

  String select;

  List<Node> getDistributedNodes() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ConvolverNode
abstract class ConvolverNode implements AudioNode {

  /** @domName ConvolverNode.buffer */
  AudioBuffer buffer;

  /** @domName ConvolverNode.normalize */
  bool normalize;
}

class _ConvolverNodeImpl extends _AudioNodeImpl implements ConvolverNode native "*ConvolverNode" {

  _AudioBufferImpl buffer;

  bool normalize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Coordinates
abstract class Coordinates {

  /** @domName Coordinates.accuracy */
  num get accuracy;

  /** @domName Coordinates.altitude */
  num get altitude;

  /** @domName Coordinates.altitudeAccuracy */
  num get altitudeAccuracy;

  /** @domName Coordinates.heading */
  num get heading;

  /** @domName Coordinates.latitude */
  num get latitude;

  /** @domName Coordinates.longitude */
  num get longitude;

  /** @domName Coordinates.speed */
  num get speed;
}

class _CoordinatesImpl implements Coordinates native "*Coordinates" {

  final num accuracy;

  final num altitude;

  final num altitudeAccuracy;

  final num heading;

  final num latitude;

  final num longitude;

  final num speed;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Counter
abstract class Counter {

  /** @domName Counter.identifier */
  String get identifier;

  /** @domName Counter.listStyle */
  String get listStyle;

  /** @domName Counter.separator */
  String get separator;
}

class _CounterImpl implements Counter native "*Counter" {

  final String identifier;

  final String listStyle;

  final String separator;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Crypto
abstract class Crypto {

  /** @domName Crypto.getRandomValues */
  void getRandomValues(ArrayBufferView array);
}

class _CryptoImpl implements Crypto native "*Crypto" {

  void getRandomValues(_ArrayBufferViewImpl array) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName CustomEvent
abstract class CustomEvent implements Event {

  factory CustomEvent(String type, [bool canBubble = true, bool cancelable = true,
      Object detail = null]) => _CustomEventFactoryProvider.createCustomEvent(type, canBubble,
      cancelable, detail);


  /** @domName CustomEvent.detail */
  Object get detail;

  /** @domName CustomEvent.initCustomEvent */
  void $dom_initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg);
}

class _CustomEventImpl extends _EventImpl implements CustomEvent native "*CustomEvent" {

  final Object detail;

  void $dom_initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) native "initCustomEvent";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDListElement
abstract class DListElement implements Element {

  factory DListElement() => _Elements.createDListElement();

  /** @domName HTMLDListElement.compact */
  bool compact;
}

class _DListElementImpl extends _ElementImpl implements DListElement native "*HTMLDListElement" {

  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMApplicationCache
abstract class DOMApplicationCache implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DOMApplicationCacheEvents get on;

  static const int CHECKING = 2;

  static const int DOWNLOADING = 3;

  static const int IDLE = 1;

  static const int OBSOLETE = 5;

  static const int UNCACHED = 0;

  static const int UPDATEREADY = 4;

  /** @domName DOMApplicationCache.status */
  int get status;

  /** @domName DOMApplicationCache.abort */
  void abort();

  /** @domName DOMApplicationCache.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMApplicationCache.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName DOMApplicationCache.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMApplicationCache.swapCache */
  void swapCache();

  /** @domName DOMApplicationCache.update */
  void update();
}

abstract class DOMApplicationCacheEvents implements Events {

  EventListenerList get cached;

  EventListenerList get checking;

  EventListenerList get downloading;

  EventListenerList get error;

  EventListenerList get noUpdate;

  EventListenerList get obsolete;

  EventListenerList get progress;

  EventListenerList get updateReady;
}

class _DOMApplicationCacheImpl extends _EventTargetImpl implements DOMApplicationCache native "*DOMApplicationCache" {

  _DOMApplicationCacheEventsImpl get on =>
    new _DOMApplicationCacheEventsImpl(this);

  final int status;

  void abort() native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void swapCache() native;

  void update() native;
}

class _DOMApplicationCacheEventsImpl extends _EventsImpl implements DOMApplicationCacheEvents {
  _DOMApplicationCacheEventsImpl(_ptr) : super(_ptr);

  EventListenerList get cached => this['cached'];

  EventListenerList get checking => this['checking'];

  EventListenerList get downloading => this['downloading'];

  EventListenerList get error => this['error'];

  EventListenerList get noUpdate => this['noupdate'];

  EventListenerList get obsolete => this['obsolete'];

  EventListenerList get progress => this['progress'];

  EventListenerList get updateReady => this['updateready'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMError
abstract class DOMError {

  /** @domName DOMError.name */
  String get name;
}

class _DOMErrorImpl implements DOMError native "*DOMError" {

  final String name;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMException
abstract class DOMException {

  static const int ABORT_ERR = 20;

  static const int DATA_CLONE_ERR = 25;

  static const int DOMSTRING_SIZE_ERR = 2;

  static const int HIERARCHY_REQUEST_ERR = 3;

  static const int INDEX_SIZE_ERR = 1;

  static const int INUSE_ATTRIBUTE_ERR = 10;

  static const int INVALID_ACCESS_ERR = 15;

  static const int INVALID_CHARACTER_ERR = 5;

  static const int INVALID_MODIFICATION_ERR = 13;

  static const int INVALID_NODE_TYPE_ERR = 24;

  static const int INVALID_STATE_ERR = 11;

  static const int NAMESPACE_ERR = 14;

  static const int NETWORK_ERR = 19;

  static const int NOT_FOUND_ERR = 8;

  static const int NOT_SUPPORTED_ERR = 9;

  static const int NO_DATA_ALLOWED_ERR = 6;

  static const int NO_MODIFICATION_ALLOWED_ERR = 7;

  static const int QUOTA_EXCEEDED_ERR = 22;

  static const int SECURITY_ERR = 18;

  static const int SYNTAX_ERR = 12;

  static const int TIMEOUT_ERR = 23;

  static const int TYPE_MISMATCH_ERR = 17;

  static const int URL_MISMATCH_ERR = 21;

  static const int VALIDATION_ERR = 16;

  static const int WRONG_DOCUMENT_ERR = 4;

  /** @domName DOMException.code */
  int get code;

  /** @domName DOMException.message */
  String get message;

  /** @domName DOMException.name */
  String get name;

  /** @domName DOMException.toString */
  String toString();
}

class _DOMExceptionImpl implements DOMException native "*DOMException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFileSystem
abstract class DOMFileSystem {

  /** @domName DOMFileSystem.name */
  String get name;

  /** @domName DOMFileSystem.root */
  DirectoryEntry get root;
}

class _DOMFileSystemImpl implements DOMFileSystem native "*DOMFileSystem" {

  final String name;

  final _DirectoryEntryImpl root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFileSystemSync
abstract class DOMFileSystemSync {

  /** @domName DOMFileSystemSync.name */
  String get name;

  /** @domName DOMFileSystemSync.root */
  DirectoryEntrySync get root;
}

class _DOMFileSystemSyncImpl implements DOMFileSystemSync native "*DOMFileSystemSync" {

  final String name;

  final _DirectoryEntrySyncImpl root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMImplementation
abstract class DOMImplementation {

  /** @domName DOMImplementation.createCSSStyleSheet */
  CSSStyleSheet createCSSStyleSheet(String title, String media);

  /** @domName DOMImplementation.createDocument */
  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype);

  /** @domName DOMImplementation.createDocumentType */
  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId);

  /** @domName DOMImplementation.createHTMLDocument */
  Document createHTMLDocument(String title);

  /** @domName DOMImplementation.hasFeature */
  bool hasFeature(String feature, String version);
}

class _DOMImplementationImpl implements DOMImplementation native "*DOMImplementation" {

  _CSSStyleSheetImpl createCSSStyleSheet(String title, String media) native;

  _DocumentImpl createDocument(String namespaceURI, String qualifiedName, _DocumentTypeImpl doctype) native;

  _DocumentTypeImpl createDocumentType(String qualifiedName, String publicId, String systemId) native;

  _DocumentImpl createHTMLDocument(String title) native;

  bool hasFeature(String feature, String version) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MimeType
abstract class DOMMimeType {

  /** @domName MimeType.description */
  String get description;

  /** @domName MimeType.enabledPlugin */
  DOMPlugin get enabledPlugin;

  /** @domName MimeType.suffixes */
  String get suffixes;

  /** @domName MimeType.type */
  String get type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MimeTypeArray
abstract class DOMMimeTypeArray implements List<DOMMimeType> {

  /** @domName MimeTypeArray.length */
  int get length;

  /** @domName MimeTypeArray.item */
  DOMMimeType item(int index);

  /** @domName MimeTypeArray.namedItem */
  DOMMimeType namedItem(String name);
}

class _DOMMimeTypeArrayImpl implements DOMMimeTypeArray, JavaScriptIndexingBehavior native "*MimeTypeArray" {

  final int length;

  _DOMMimeTypeImpl operator[](int index) => JS("_DOMMimeTypeImpl", "#[#]", this, index);

  void operator[]=(int index, _DOMMimeTypeImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<DOMMimeType> mixins.
  // DOMMimeType is the element type.

  // From Iterable<DOMMimeType>:

  Iterator<DOMMimeType> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<DOMMimeType>(this);
  }

  // From Collection<DOMMimeType>:

  void add(DOMMimeType value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(DOMMimeType value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<DOMMimeType> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(DOMMimeType element) => _Collections.contains(this, element);

  void forEach(void f(DOMMimeType element)) => _Collections.forEach(this, f);

  Collection map(f(DOMMimeType element)) => _Collections.map(this, [], f);

  Collection<DOMMimeType> filter(bool f(DOMMimeType element)) =>
     _Collections.filter(this, <DOMMimeType>[], f);

  bool every(bool f(DOMMimeType element)) => _Collections.every(this, f);

  bool some(bool f(DOMMimeType element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<DOMMimeType>:

  void sort([Comparator<DOMMimeType> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(DOMMimeType element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(DOMMimeType element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  DOMMimeType get last => this[length - 1];

  DOMMimeType removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<DOMMimeType> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [DOMMimeType initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<DOMMimeType> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <DOMMimeType>[]);

  // -- end List<DOMMimeType> mixins.

  _DOMMimeTypeImpl item(int index) native;

  _DOMMimeTypeImpl namedItem(String name) native;
}

class _DOMMimeTypeImpl implements DOMMimeType native "*MimeType" {

  final String description;

  final _DOMPluginImpl enabledPlugin;

  final String suffixes;

  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMParser
abstract class DOMParser {

  factory DOMParser() => _DOMParserFactoryProvider.createDOMParser();

  /** @domName DOMParser.parseFromString */
  Document parseFromString(String str, String contentType);
}

class _DOMParserImpl implements DOMParser native "*DOMParser" {

  _DocumentImpl parseFromString(String str, String contentType) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Plugin
abstract class DOMPlugin {

  /** @domName Plugin.description */
  String get description;

  /** @domName Plugin.filename */
  String get filename;

  /** @domName Plugin.length */
  int get length;

  /** @domName Plugin.name */
  String get name;

  /** @domName Plugin.item */
  DOMMimeType item(int index);

  /** @domName Plugin.namedItem */
  DOMMimeType namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PluginArray
abstract class DOMPluginArray implements List<DOMPlugin> {

  /** @domName PluginArray.length */
  int get length;

  /** @domName PluginArray.item */
  DOMPlugin item(int index);

  /** @domName PluginArray.namedItem */
  DOMPlugin namedItem(String name);

  /** @domName PluginArray.refresh */
  void refresh(bool reload);
}

class _DOMPluginArrayImpl implements DOMPluginArray, JavaScriptIndexingBehavior native "*PluginArray" {

  final int length;

  _DOMPluginImpl operator[](int index) => JS("_DOMPluginImpl", "#[#]", this, index);

  void operator[]=(int index, _DOMPluginImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<DOMPlugin> mixins.
  // DOMPlugin is the element type.

  // From Iterable<DOMPlugin>:

  Iterator<DOMPlugin> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<DOMPlugin>(this);
  }

  // From Collection<DOMPlugin>:

  void add(DOMPlugin value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(DOMPlugin value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<DOMPlugin> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(DOMPlugin element) => _Collections.contains(this, element);

  void forEach(void f(DOMPlugin element)) => _Collections.forEach(this, f);

  Collection map(f(DOMPlugin element)) => _Collections.map(this, [], f);

  Collection<DOMPlugin> filter(bool f(DOMPlugin element)) =>
     _Collections.filter(this, <DOMPlugin>[], f);

  bool every(bool f(DOMPlugin element)) => _Collections.every(this, f);

  bool some(bool f(DOMPlugin element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<DOMPlugin>:

  void sort([Comparator<DOMPlugin> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(DOMPlugin element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(DOMPlugin element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  DOMPlugin get last => this[length - 1];

  DOMPlugin removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<DOMPlugin> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [DOMPlugin initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<DOMPlugin> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <DOMPlugin>[]);

  // -- end List<DOMPlugin> mixins.

  _DOMPluginImpl item(int index) native;

  _DOMPluginImpl namedItem(String name) native;

  void refresh(bool reload) native;
}

class _DOMPluginImpl implements DOMPlugin native "*Plugin" {

  final String description;

  final String filename;

  final int length;

  final String name;

  _DOMMimeTypeImpl item(int index) native;

  _DOMMimeTypeImpl namedItem(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Selection
abstract class DOMSelection {

  /** @domName Selection.anchorNode */
  Node get anchorNode;

  /** @domName Selection.anchorOffset */
  int get anchorOffset;

  /** @domName Selection.baseNode */
  Node get baseNode;

  /** @domName Selection.baseOffset */
  int get baseOffset;

  /** @domName Selection.extentNode */
  Node get extentNode;

  /** @domName Selection.extentOffset */
  int get extentOffset;

  /** @domName Selection.focusNode */
  Node get focusNode;

  /** @domName Selection.focusOffset */
  int get focusOffset;

  /** @domName Selection.isCollapsed */
  bool get isCollapsed;

  /** @domName Selection.rangeCount */
  int get rangeCount;

  /** @domName Selection.type */
  String get type;

  /** @domName Selection.addRange */
  void addRange(Range range);

  /** @domName Selection.collapse */
  void collapse(Node node, int index);

  /** @domName Selection.collapseToEnd */
  void collapseToEnd();

  /** @domName Selection.collapseToStart */
  void collapseToStart();

  /** @domName Selection.containsNode */
  bool containsNode(Node node, bool allowPartial);

  /** @domName Selection.deleteFromDocument */
  void deleteFromDocument();

  /** @domName Selection.empty */
  void empty();

  /** @domName Selection.extend */
  void extend(Node node, int offset);

  /** @domName Selection.getRangeAt */
  Range getRangeAt(int index);

  /** @domName Selection.modify */
  void modify(String alter, String direction, String granularity);

  /** @domName Selection.removeAllRanges */
  void removeAllRanges();

  /** @domName Selection.selectAllChildren */
  void selectAllChildren(Node node);

  /** @domName Selection.setBaseAndExtent */
  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset);

  /** @domName Selection.setPosition */
  void setPosition(Node node, int offset);

  /** @domName Selection.toString */
  String toString();
}

class _DOMSelectionImpl implements DOMSelection native "*Selection" {

  final _NodeImpl anchorNode;

  final int anchorOffset;

  final _NodeImpl baseNode;

  final int baseOffset;

  final _NodeImpl extentNode;

  final int extentOffset;

  final _NodeImpl focusNode;

  final int focusOffset;

  final bool isCollapsed;

  final int rangeCount;

  final String type;

  void addRange(_RangeImpl range) native;

  void collapse(_NodeImpl node, int index) native;

  void collapseToEnd() native;

  void collapseToStart() native;

  bool containsNode(_NodeImpl node, bool allowPartial) native;

  void deleteFromDocument() native;

  void empty() native;

  void extend(_NodeImpl node, int offset) native;

  _RangeImpl getRangeAt(int index) native;

  void modify(String alter, String direction, String granularity) native;

  void removeAllRanges() native;

  void selectAllChildren(_NodeImpl node) native;

  void setBaseAndExtent(_NodeImpl baseNode, int baseOffset, _NodeImpl extentNode, int extentOffset) native;

  void setPosition(_NodeImpl node, int offset) native;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMSettableTokenList
abstract class DOMSettableTokenList implements DOMTokenList {

  /** @domName DOMSettableTokenList.value */
  String value;
}

class _DOMSettableTokenListImpl extends _DOMTokenListImpl implements DOMSettableTokenList native "*DOMSettableTokenList" {

  String value;
}

class _DOMStringListImpl implements List<String>, JavaScriptIndexingBehavior native "*DOMStringList" {

  final int length;

  String operator[](int index) => JS("String", "#[#]", this, index);

  void operator[]=(int index, String value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<String> mixins.
  // String is the element type.

  // From Iterable<String>:

  Iterator<String> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<String>(this);
  }

  // From Collection<String>:

  void add(String value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  // contains() defined by IDL.

  void forEach(void f(String element)) => _Collections.forEach(this, f);

  Collection map(f(String element)) => _Collections.map(this, [], f);

  Collection<String> filter(bool f(String element)) =>
     _Collections.filter(this, <String>[], f);

  bool every(bool f(String element)) => _Collections.every(this, f);

  bool some(bool f(String element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<String>:

  void sort([Comparator<String> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(String element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(String element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  String get last => this[length - 1];

  String removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<String> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [String initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <String>[]);

  // -- end List<String> mixins.

  bool contains(String string) native;

  String item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMStringMap
abstract class DOMStringMap {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMTokenList
abstract class DOMTokenList {

  /** @domName DOMTokenList.length */
  int get length;

  /** @domName DOMTokenList.contains */
  bool contains(String token);

  /** @domName DOMTokenList.item */
  String item(int index);

  /** @domName DOMTokenList.toString */
  String toString();

  /** @domName DOMTokenList.toggle */
  bool toggle(String token, [bool force]);
}

class _DOMTokenListImpl implements DOMTokenList native "*DOMTokenList" {

  final int length;

  bool contains(String token) native;

  String item(int index) native;

  String toString() native;

  bool toggle(String token, [bool force]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName URL
abstract class DOMURL {

  factory DOMURL() => _DOMURLFactoryProvider.createDOMURL();

  /** @domName URL.createObjectURL */
  static final createObjectURL = _DOMURLImpl.createObjectURL;

  /** @domName URL.revokeObjectURL */
  static final revokeObjectURL = _DOMURLImpl.revokeObjectURL;
}

class _DOMURLImpl implements DOMURL native "*URL" {

  static String createObjectURL(blob_OR_source_OR_stream) native;

  static void revokeObjectURL(String url) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDataListElement
abstract class DataListElement implements Element {

  factory DataListElement() => _Elements.createDataListElement();

  /** @domName HTMLDataListElement.options */
  HTMLCollection get options;
}

class _DataListElementImpl extends _ElementImpl implements DataListElement native "*HTMLDataListElement" {

  final _HTMLCollectionImpl options;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataTransferItem
abstract class DataTransferItem {

  /** @domName DataTransferItem.kind */
  String get kind;

  /** @domName DataTransferItem.type */
  String get type;

  /** @domName DataTransferItem.getAsFile */
  Blob getAsFile();

  /** @domName DataTransferItem.getAsString */
  void getAsString([StringCallback callback]);

  /** @domName DataTransferItem.webkitGetAsEntry */
  Entry webkitGetAsEntry();
}

class _DataTransferItemImpl implements DataTransferItem native "*DataTransferItem" {

  final String kind;

  final String type;

  _BlobImpl getAsFile() native;

  void getAsString([StringCallback callback]) native;

  _EntryImpl webkitGetAsEntry() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataTransferItemList
abstract class DataTransferItemList {

  /** @domName DataTransferItemList.length */
  int get length;

  /** @domName DataTransferItemList.add */
  void add(data_OR_file, [String type]);

  /** @domName DataTransferItemList.clear */
  void clear();

  /** @domName DataTransferItemList.item */
  DataTransferItem item(int index);
}

class _DataTransferItemListImpl implements DataTransferItemList native "*DataTransferItemList" {

  final int length;

  void add(data_OR_file, [String type]) native;

  void clear() native;

  _DataTransferItemImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataView
abstract class DataView implements ArrayBufferView {

  factory DataView(ArrayBuffer buffer, [int byteOffset, int byteLength]) {
    if (!?byteOffset) {
      return _DataViewFactoryProvider.createDataView(buffer);
    }
    if (!?byteLength) {
      return _DataViewFactoryProvider.createDataView(buffer, byteOffset);
    }
    return _DataViewFactoryProvider.createDataView(buffer, byteOffset, byteLength);
  }

  /** @domName DataView.getFloat32 */
  num getFloat32(int byteOffset, {bool littleEndian});

  /** @domName DataView.getFloat64 */
  num getFloat64(int byteOffset, {bool littleEndian});

  /** @domName DataView.getInt16 */
  int getInt16(int byteOffset, {bool littleEndian});

  /** @domName DataView.getInt32 */
  int getInt32(int byteOffset, {bool littleEndian});

  /** @domName DataView.getInt8 */
  int getInt8(int byteOffset);

  /** @domName DataView.getUint16 */
  int getUint16(int byteOffset, {bool littleEndian});

  /** @domName DataView.getUint32 */
  int getUint32(int byteOffset, {bool littleEndian});

  /** @domName DataView.getUint8 */
  int getUint8(int byteOffset);

  /** @domName DataView.setFloat32 */
  void setFloat32(int byteOffset, num value, {bool littleEndian});

  /** @domName DataView.setFloat64 */
  void setFloat64(int byteOffset, num value, {bool littleEndian});

  /** @domName DataView.setInt16 */
  void setInt16(int byteOffset, int value, {bool littleEndian});

  /** @domName DataView.setInt32 */
  void setInt32(int byteOffset, int value, {bool littleEndian});

  /** @domName DataView.setInt8 */
  void setInt8(int byteOffset, int value);

  /** @domName DataView.setUint16 */
  void setUint16(int byteOffset, int value, {bool littleEndian});

  /** @domName DataView.setUint32 */
  void setUint32(int byteOffset, int value, {bool littleEndian});

  /** @domName DataView.setUint8 */
  void setUint8(int byteOffset, int value);
}

class _DataViewImpl extends _ArrayBufferViewImpl implements DataView native "*DataView" {

  num getFloat32(int byteOffset, {bool littleEndian}) native;

  num getFloat64(int byteOffset, {bool littleEndian}) native;

  int getInt16(int byteOffset, {bool littleEndian}) native;

  int getInt32(int byteOffset, {bool littleEndian}) native;

  int getInt8(int byteOffset) native;

  int getUint16(int byteOffset, {bool littleEndian}) native;

  int getUint32(int byteOffset, {bool littleEndian}) native;

  int getUint8(int byteOffset) native;

  void setFloat32(int byteOffset, num value, {bool littleEndian}) native;

  void setFloat64(int byteOffset, num value, {bool littleEndian}) native;

  void setInt16(int byteOffset, int value, {bool littleEndian}) native;

  void setInt32(int byteOffset, int value, {bool littleEndian}) native;

  void setInt8(int byteOffset, int value) native;

  void setUint16(int byteOffset, int value, {bool littleEndian}) native;

  void setUint32(int byteOffset, int value, {bool littleEndian}) native;

  void setUint8(int byteOffset, int value) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Database
abstract class Database {

  /** @domName Database.version */
  String get version;

  /** @domName Database.changeVersion */
  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback, SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  /** @domName Database.readTransaction */
  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  /** @domName Database.transaction */
  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void DatabaseCallback(database);

class _DatabaseImpl implements Database native "*Database" {

  final String version;

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback, SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;

  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;

  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DatabaseSync
abstract class DatabaseSync {

  /** @domName DatabaseSync.lastErrorMessage */
  String get lastErrorMessage;

  /** @domName DatabaseSync.version */
  String get version;

  /** @domName DatabaseSync.changeVersion */
  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback]);

  /** @domName DatabaseSync.readTransaction */
  void readTransaction(SQLTransactionSyncCallback callback);

  /** @domName DatabaseSync.transaction */
  void transaction(SQLTransactionSyncCallback callback);
}

class _DatabaseSyncImpl implements DatabaseSync native "*DatabaseSync" {

  final String lastErrorMessage;

  final String version;

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback]) native;

  void readTransaction(SQLTransactionSyncCallback callback) native;

  void transaction(SQLTransactionSyncCallback callback) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DedicatedWorkerContext
abstract class DedicatedWorkerContext implements WorkerContext {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DedicatedWorkerContextEvents get on;

  /** @domName DedicatedWorkerContext.postMessage */
  void postMessage(Object message, [List messagePorts]);
}

abstract class DedicatedWorkerContextEvents implements WorkerContextEvents {

  EventListenerList get message;
}

class _DedicatedWorkerContextImpl extends _WorkerContextImpl implements DedicatedWorkerContext native "*DedicatedWorkerContext" {

  _DedicatedWorkerContextEventsImpl get on =>
    new _DedicatedWorkerContextEventsImpl(this);

  void postMessage(/*any*/ message, [messagePorts]) {
    if (?messagePorts) {
      var message_1 = _convertDartToNative_SerializedScriptValue(message);
      _postMessage_1(message_1, messagePorts);
      return;
    }
    var message_2 = _convertDartToNative_SerializedScriptValue(message);
    _postMessage_2(message_2);
    return;
  }
  void _postMessage_1(message, List messagePorts) native "postMessage";
  void _postMessage_2(message) native "postMessage";
}

class _DedicatedWorkerContextEventsImpl extends _WorkerContextEventsImpl implements DedicatedWorkerContextEvents {
  _DedicatedWorkerContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message => this['message'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DelayNode
abstract class DelayNode implements AudioNode {

  /** @domName DelayNode.delayTime */
  AudioParam get delayTime;
}

class _DelayNodeImpl extends _AudioNodeImpl implements DelayNode native "*DelayNode" {

  final _AudioParamImpl delayTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDetailsElement
abstract class DetailsElement implements Element {

  factory DetailsElement() => _Elements.createDetailsElement();

  /** @domName HTMLDetailsElement.open */
  bool open;
}

class _DetailsElementImpl extends _ElementImpl implements DetailsElement native "*HTMLDetailsElement" {

  bool open;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeviceMotionEvent
abstract class DeviceMotionEvent implements Event {

  /** @domName DeviceMotionEvent.interval */
  num get interval;
}

class _DeviceMotionEventImpl extends _EventImpl implements DeviceMotionEvent native "*DeviceMotionEvent" {

  final num interval;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeviceOrientationEvent
abstract class DeviceOrientationEvent implements Event {

  /** @domName DeviceOrientationEvent.absolute */
  bool get absolute;

  /** @domName DeviceOrientationEvent.alpha */
  num get alpha;

  /** @domName DeviceOrientationEvent.beta */
  num get beta;

  /** @domName DeviceOrientationEvent.gamma */
  num get gamma;

  /** @domName DeviceOrientationEvent.initDeviceOrientationEvent */
  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute);
}

class _DeviceOrientationEventImpl extends _EventImpl implements DeviceOrientationEvent native "*DeviceOrientationEvent" {

  final bool absolute;

  final num alpha;

  final num beta;

  final num gamma;

  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDirectoryElement
abstract class DirectoryElement implements Element {

  /** @domName HTMLDirectoryElement.compact */
  bool compact;
}

class _DirectoryElementImpl extends _ElementImpl implements DirectoryElement native "*HTMLDirectoryElement" {

  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryEntry
abstract class DirectoryEntry implements Entry {

  /** @domName DirectoryEntry.createReader */
  DirectoryReader createReader();

  /** @domName DirectoryEntry.getDirectory */
  void getDirectory(String path, {Map options, EntryCallback successCallback, ErrorCallback errorCallback});

  /** @domName DirectoryEntry.getFile */
  void getFile(String path, {Map options, EntryCallback successCallback, ErrorCallback errorCallback});

  /** @domName DirectoryEntry.removeRecursively */
  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback]);
}

class _DirectoryEntryImpl extends _EntryImpl implements DirectoryEntry native "*DirectoryEntry" {

  _DirectoryReaderImpl createReader() native;

  void getDirectory(String path, {options, successCallback, errorCallback}) {
    if (?errorCallback) {
      var options_1 = _convertDartToNative_Dictionary(options);
      _getDirectory_1(path, options_1, successCallback, errorCallback);
      return;
    }
    if (?successCallback) {
      var options_2 = _convertDartToNative_Dictionary(options);
      _getDirectory_2(path, options_2, successCallback);
      return;
    }
    if (?options) {
      var options_3 = _convertDartToNative_Dictionary(options);
      _getDirectory_3(path, options_3);
      return;
    }
    _getDirectory_4(path);
    return;
  }
  void _getDirectory_1(path, options, EntryCallback successCallback, ErrorCallback errorCallback) native "getDirectory";
  void _getDirectory_2(path, options, EntryCallback successCallback) native "getDirectory";
  void _getDirectory_3(path, options) native "getDirectory";
  void _getDirectory_4(path) native "getDirectory";

  void getFile(String path, {options, successCallback, errorCallback}) {
    if (?errorCallback) {
      var options_1 = _convertDartToNative_Dictionary(options);
      _getFile_1(path, options_1, successCallback, errorCallback);
      return;
    }
    if (?successCallback) {
      var options_2 = _convertDartToNative_Dictionary(options);
      _getFile_2(path, options_2, successCallback);
      return;
    }
    if (?options) {
      var options_3 = _convertDartToNative_Dictionary(options);
      _getFile_3(path, options_3);
      return;
    }
    _getFile_4(path);
    return;
  }
  void _getFile_1(path, options, EntryCallback successCallback, ErrorCallback errorCallback) native "getFile";
  void _getFile_2(path, options, EntryCallback successCallback) native "getFile";
  void _getFile_3(path, options) native "getFile";
  void _getFile_4(path) native "getFile";

  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryEntrySync
abstract class DirectoryEntrySync implements EntrySync {

  /** @domName DirectoryEntrySync.createReader */
  DirectoryReaderSync createReader();

  /** @domName DirectoryEntrySync.getDirectory */
  DirectoryEntrySync getDirectory(String path, Map flags);

  /** @domName DirectoryEntrySync.getFile */
  FileEntrySync getFile(String path, Map flags);

  /** @domName DirectoryEntrySync.removeRecursively */
  void removeRecursively();
}

class _DirectoryEntrySyncImpl extends _EntrySyncImpl implements DirectoryEntrySync native "*DirectoryEntrySync" {

  _DirectoryReaderSyncImpl createReader() native;

  _DirectoryEntrySyncImpl getDirectory(String path, Map flags) {
    var flags_1 = _convertDartToNative_Dictionary(flags);
    return _getDirectory_1(path, flags_1);
  }
  _DirectoryEntrySyncImpl _getDirectory_1(path, flags) native "getDirectory";

  _FileEntrySyncImpl getFile(String path, Map flags) {
    var flags_1 = _convertDartToNative_Dictionary(flags);
    return _getFile_1(path, flags_1);
  }
  _FileEntrySyncImpl _getFile_1(path, flags) native "getFile";

  void removeRecursively() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryReader
abstract class DirectoryReader {

  /** @domName DirectoryReader.readEntries */
  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]);
}

class _DirectoryReaderImpl implements DirectoryReader native "*DirectoryReader" {

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryReaderSync
abstract class DirectoryReaderSync {

  /** @domName DirectoryReaderSync.readEntries */
  List<EntrySync> readEntries();
}

class _DirectoryReaderSyncImpl implements DirectoryReaderSync native "*DirectoryReaderSync" {

  _EntryArraySyncImpl readEntries() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDivElement
abstract class DivElement implements Element {

  factory DivElement() => _Elements.createDivElement();

  /** @domName HTMLDivElement.align */
  String align;
}

class _DivElementImpl extends _ElementImpl implements DivElement native "*HTMLDivElement" {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName Document
abstract class Document extends HtmlElement {


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DocumentEvents get on;

  /** @domName HTMLDocument.activeElement */
  Element get activeElement;

  /** @domName Document.body */
  Element body;

  /** @domName Document.charset */
  String charset;

  /** @domName Document.cookie */
  String cookie;

  /** @domName Document.defaultView */
  Window get window;

  /** @domName Document.documentElement */
  Element get documentElement;

  /** @domName Document.domain */
  String get domain;

  /** @domName Document.head */
  HeadElement get head;

  /** @domName Document.implementation */
  DOMImplementation get implementation;

  /** @domName Document.lastModified */
  String get lastModified;

  /** @domName Document.preferredStylesheetSet */
  String get preferredStylesheetSet;

  /** @domName Document.readyState */
  String get readyState;

  /** @domName Document.referrer */
  String get referrer;

  /** @domName Document.selectedStylesheetSet */
  String selectedStylesheetSet;

  /** @domName Document.styleSheets */
  List<StyleSheet> get styleSheets;

  /** @domName Document.title */
  String title;

  /** @domName Document.webkitCurrentFullScreenElement */
  Element get webkitCurrentFullScreenElement;

  /** @domName Document.webkitFullScreenKeyboardInputAllowed */
  bool get webkitFullScreenKeyboardInputAllowed;

  /** @domName Document.webkitFullscreenElement */
  Element get webkitFullscreenElement;

  /** @domName Document.webkitFullscreenEnabled */
  bool get webkitFullscreenEnabled;

  /** @domName Document.webkitHidden */
  bool get webkitHidden;

  /** @domName Document.webkitIsFullScreen */
  bool get webkitIsFullScreen;

  /** @domName Document.webkitPointerLockElement */
  Element get webkitPointerLockElement;

  /** @domName Document.webkitVisibilityState */
  String get webkitVisibilityState;

  /** @domName Document.caretRangeFromPoint */
  Range caretRangeFromPoint(int x, int y);

  /** @domName Document.createCDATASection */
  CDATASection createCDATASection(String data);

  /** @domName Document.createDocumentFragment */
  DocumentFragment createDocumentFragment();

  /** @domName Document.createElement */
  Element $dom_createElement(String tagName);

  /** @domName Document.createElementNS */
  Element $dom_createElementNS(String namespaceURI, String qualifiedName);

  /** @domName Document.createEvent */
  Event $dom_createEvent(String eventType);

  /** @domName Document.createRange */
  Range createRange();

  /** @domName Document.createTextNode */
  Text $dom_createTextNode(String data);

  /** @domName Document.createTouch */
  Touch createTouch(LocalWindow window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce);

  /** @domName Document.createTouchList */
  TouchList $dom_createTouchList();

  /** @domName Document.elementFromPoint */
  Element elementFromPoint(int x, int y);

  /** @domName Document.execCommand */
  bool execCommand(String command, bool userInterface, String value);

  /** @domName Document.getCSSCanvasContext */
  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height);

  /** @domName Document.getElementById */
  Element $dom_getElementById(String elementId);

  /** @domName Document.getElementsByClassName */
  List<Node> $dom_getElementsByClassName(String tagname);

  /** @domName Document.getElementsByName */
  List<Node> $dom_getElementsByName(String elementName);

  /** @domName Document.getElementsByTagName */
  List<Node> $dom_getElementsByTagName(String tagname);

  /** @domName Document.queryCommandEnabled */
  bool queryCommandEnabled(String command);

  /** @domName Document.queryCommandIndeterm */
  bool queryCommandIndeterm(String command);

  /** @domName Document.queryCommandState */
  bool queryCommandState(String command);

  /** @domName Document.queryCommandSupported */
  bool queryCommandSupported(String command);

  /** @domName Document.queryCommandValue */
  String queryCommandValue(String command);

  /** @domName Document.querySelector */
  Element $dom_querySelector(String selectors);

  /** @domName Document.querySelectorAll */
  List<Node> $dom_querySelectorAll(String selectors);

  /** @domName Document.webkitCancelFullScreen */
  void webkitCancelFullScreen();

  /** @domName Document.webkitExitFullscreen */
  void webkitExitFullscreen();

  /** @domName Document.webkitExitPointerLock */
  void webkitExitPointerLock();

}

abstract class DocumentEvents implements ElementEvents {

  EventListenerList get abort;

  EventListenerList get beforeCopy;

  EventListenerList get beforeCut;

  EventListenerList get beforePaste;

  EventListenerList get blur;

  EventListenerList get change;

  EventListenerList get click;

  EventListenerList get contextMenu;

  EventListenerList get copy;

  EventListenerList get cut;

  EventListenerList get doubleClick;

  EventListenerList get drag;

  EventListenerList get dragEnd;

  EventListenerList get dragEnter;

  EventListenerList get dragLeave;

  EventListenerList get dragOver;

  EventListenerList get dragStart;

  EventListenerList get drop;

  EventListenerList get error;

  EventListenerList get focus;

  EventListenerList get input;

  EventListenerList get invalid;

  EventListenerList get keyDown;

  EventListenerList get keyPress;

  EventListenerList get keyUp;

  EventListenerList get load;

  EventListenerList get mouseDown;

  EventListenerList get mouseMove;

  EventListenerList get mouseOut;

  EventListenerList get mouseOver;

  EventListenerList get mouseUp;

  EventListenerList get mouseWheel;

  EventListenerList get paste;

  EventListenerList get readyStateChange;

  EventListenerList get reset;

  EventListenerList get scroll;

  EventListenerList get search;

  EventListenerList get select;

  EventListenerList get selectionChange;

  EventListenerList get selectStart;

  EventListenerList get submit;

  EventListenerList get touchCancel;

  EventListenerList get touchEnd;

  EventListenerList get touchMove;

  EventListenerList get touchStart;

  EventListenerList get fullscreenChange;

  EventListenerList get fullscreenError;

  EventListenerList get pointerLockChange;

  EventListenerList get pointerLockError;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName DocumentFragment
abstract class DocumentFragment extends Element {

  factory DocumentFragment() => _DocumentFragmentFactoryProvider.createDocumentFragment();

  factory DocumentFragment.html(String html) =>
      _DocumentFragmentFactoryProvider.createDocumentFragment_html(html);

  // TODO(nweiz): enable this when XML is ported
  // /** WARNING: Currently this doesn't work on Dartium (issue 649). */
  // DocumentFragment.xml(String xml);

  factory DocumentFragment.svg(String svg) =>
      new _DocumentFragmentFactoryProvider.DocumentFragment.svg(svg);

  DocumentFragment clone(bool deep);


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  ElementEvents get on;

  /** @domName DocumentFragment.querySelector */
  Element $dom_querySelector(String selectors);

  /** @domName DocumentFragment.querySelectorAll */
  List<Node> $dom_querySelectorAll(String selectors);

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FilteredElementList implements List {
  final Node _node;
  final List<Node> _childNodes;

  _FilteredElementList(Node node): _childNodes = node.nodes, _node = node;

  // We can't memoize this, since it's possible that children will be messed
  // with externally to this class.
  //
  // TODO(nweiz): Do we really need to copy the list to make the types work out?
  List<Element> get _filtered =>
    new List.from(_childNodes.filter((n) => n is Element));

  void forEach(void f(Element element)) {
    _filtered.forEach(f);
  }

  void operator []=(int index, Element value) {
    this[index].replaceWith(value);
  }

  void set length(int newLength) {
    final len = this.length;
    if (newLength >= len) {
      return;
    } else if (newLength < 0) {
      throw new ArgumentError("Invalid list length");
    }

    removeRange(newLength - 1, len - newLength);
  }

  void add(Element value) {
    _childNodes.add(value);
  }

  void addAll(Collection<Element> collection) {
    collection.forEach(add);
  }

  void addLast(Element value) {
    add(value);
  }

  bool contains(Element element) {
    return element is Element && _childNodes.contains(element);
  }

  void sort([Comparator<Element> compare = Comparable.compare]) {
    throw new UnsupportedError('TODO(jacobr): should we impl?');
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw new UnimplementedError();
  }

  void removeRange(int start, int rangeLength) {
    _filtered.getRange(start, rangeLength).forEach((el) => el.remove());
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw new UnimplementedError();
  }

  void clear() {
    // Currently, ElementList#clear clears even non-element nodes, so we follow
    // that behavior.
    _childNodes.clear();
  }

  Element removeLast() {
    final result = this.last;
    if (result != null) {
      result.remove();
    }
    return result;
  }

  Collection map(f(Element element)) => _filtered.map(f);
  Collection<Element> filter(bool f(Element element)) => _filtered.filter(f);
  bool every(bool f(Element element)) => _filtered.every(f);
  bool some(bool f(Element element)) => _filtered.some(f);
  bool get isEmpty => _filtered.isEmpty;
  int get length => _filtered.length;
  Element operator [](int index) => _filtered[index];
  Iterator<Element> iterator() => _filtered.iterator();
  List<Element> getRange(int start, int rangeLength) =>
    _filtered.getRange(start, rangeLength);
  int indexOf(Element element, [int start = 0]) =>
    _filtered.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) {
    if (start == null) start = length - 1;
    return _filtered.lastIndexOf(element, start);
  }

  Element get last => _filtered.last;
}

Future<CSSStyleDeclaration> _emptyStyleFuture() {
  return _createMeasurementFuture(() => new Element.tag('div').style,
                                  new Completer<CSSStyleDeclaration>());
}

class EmptyElementRect implements ElementRect {
  final ClientRect client = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect offset = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect scroll = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect bounding = const _SimpleClientRect(0, 0, 0, 0);
  final List<ClientRect> clientRects = const <ClientRect>[];

  const EmptyElementRect();
}

class _FrozenCSSClassSet extends _CssClassSet {
  _FrozenCSSClassSet() : super(null);

  void _write(Set s) {
    throw new UnsupportedError(
        'frozen class set cannot be modified');
  }
  Set<String> _read() => new Set<String>();

  bool get frozen => true;
}

class _DocumentFragmentImpl extends _NodeImpl implements DocumentFragment native "*DocumentFragment" {
  List<Element> _elements;

  List<Element> get elements {
    if (_elements == null) {
      _elements = new _FilteredElementList(this);
    }
    return _elements;
  }

  // TODO: The type of value should be Collection<Element>. See http://b/5392897
  void set elements(value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    final elements = this.elements;
    elements.clear();
    elements.addAll(copy);
  }

  _ElementImpl query(String selectors) => $dom_querySelector(selectors);

  List<Element> queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  String get innerHTML {
    final e = new Element.tag("div");
    e.nodes.add(this.clone(true));
    return e.innerHTML;
  }

  String get outerHTML => innerHTML;

  // TODO(nweiz): Do we want to support some variant of innerHTML for XML and/or
  // SVG strings?
  void set innerHTML(String value) {
    this.nodes.clear();

    final e = new Element.tag("div");
    e.innerHTML = value;

    // Copy list first since we don't want liveness during iteration.
    List nodes = new List.from(e.nodes);
    this.nodes.addAll(nodes);
  }

  Node _insertAdjacentNode(String where, Node node) {
    switch (where.toLowerCase()) {
      case "beforebegin": return null;
      case "afterend": return null;
      case "afterbegin":
        var first = this.nodes.length > 0 ? this.nodes[0] : null;
        this.insertBefore(node, first);
        return node;
      case "beforeend":
        this.nodes.add(node);
        return node;
      default:
        throw new ArgumentError("Invalid position ${where}");
    }
  }

  Element insertAdjacentElement(String where, Element element)
    => this._insertAdjacentNode(where, element);

  void insertAdjacentText(String where, String text) {
    this._insertAdjacentNode(where, new Text(text));
  }

  void insertAdjacentHTML(String where, String text) {
    this._insertAdjacentNode(where, new DocumentFragment.html(text));
  }

  void addText(String text) {
    this.insertAdjacentText('beforeend', text);
  }

  void addHTML(String text) {
    this.insertAdjacentHTML('beforeend', text);
  }

  Future<ElementRect> get rect {
    return _createMeasurementFuture(() => const EmptyElementRect(),
                                    new Completer<ElementRect>());
  }

  // If we can come up with a semi-reasonable default value for an Element
  // getter, we'll use it. In general, these return the same values as an
  // element that has no parent.
  String get contentEditable => "false";
  bool get isContentEditable => false;
  bool get draggable => false;
  bool get hidden => false;
  bool get spellcheck => false;
  bool get translate => false;
  int get tabIndex => -1;
  String get id => "";
  String get title => "";
  String get tagName => "";
  String get webkitdropzone => "";
  String get webkitRegionOverflow => "";
  Element get $m_firstElementChild {
    if (elements.length > 0) {
      return elements[0];
    }
    return null;
  }
  Element get $m_lastElementChild() => elements.last;
  Element get nextElementSibling => null;
  Element get previousElementSibling => null;
  Element get offsetParent => null;
  Element get parent => null;
  Map<String, String> get attributes => const {};
  CSSClassSet get classes => new _FrozenCSSClassSet();
  Map<String, String> get dataAttributes => const {};
  CSSStyleDeclaration get style => new Element.tag('div').style;
  Future<CSSStyleDeclaration> get computedStyle =>
      _emptyStyleFuture();
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) =>
      _emptyStyleFuture();
  bool matchesSelector(String selectors) => false;

  // Imperative Element methods are made into no-ops, as they are on parentless
  // elements.
  void blur() {}
  void focus() {}
  void click() {}
  void scrollByLines(int lines) {}
  void scrollByPages(int pages) {}
  void scrollIntoView([bool centerIfNeeded]) {}
  void webkitRequestFullScreen(int flags) {}
  void webkitRequestFullscreen() {}

  // Setters throw errors rather than being no-ops because we aren't going to
  // retain the values that were set, and erroring out seems clearer.
  void set attributes(Map<String, String> value) {
    throw new UnsupportedError(
      "Attributes can't be set for document fragments.");
  }

  void set classes(Collection<String> value) {
    throw new UnsupportedError(
      "Classes can't be set for document fragments.");
  }

  void set dataAttributes(Map<String, String> value) {
    throw new UnsupportedError(
      "Data attributes can't be set for document fragments.");
  }

  void set contentEditable(String value) {
    throw new UnsupportedError(
      "Content editable can't be set for document fragments.");
  }

  String get dir {
    throw new UnsupportedError(
      "Document fragments don't support text direction.");
  }

  void set dir(String value) {
    throw new UnsupportedError(
      "Document fragments don't support text direction.");
  }

  void set draggable(bool value) {
    throw new UnsupportedError(
      "Draggable can't be set for document fragments.");
  }

  void set hidden(bool value) {
    throw new UnsupportedError(
      "Hidden can't be set for document fragments.");
  }

  void set id(String value) {
    throw new UnsupportedError(
      "ID can't be set for document fragments.");
  }

  String get lang {
    throw new UnsupportedError(
      "Document fragments don't support language.");
  }

  void set lang(String value) {
    throw new UnsupportedError(
      "Document fragments don't support language.");
  }

  void set scrollLeft(int value) {
    throw new UnsupportedError(
      "Document fragments don't support scrolling.");
  }

  void set scrollTop(int value) {
    throw new UnsupportedError(
      "Document fragments don't support scrolling.");
  }

  void set spellcheck(bool value) {
     throw new UnsupportedError(
      "Spellcheck can't be set for document fragments.");
  }

  void set translate(bool value) {
     throw new UnsupportedError(
      "Spellcheck can't be set for document fragments.");
  }

  void set tabIndex(int value) {
    throw new UnsupportedError(
      "Tab index can't be set for document fragments.");
  }

  void set title(String value) {
    throw new UnsupportedError(
      "Title can't be set for document fragments.");
  }

  void set webkitdropzone(String value) {
    throw new UnsupportedError(
      "WebKit drop zone can't be set for document fragments.");
  }

  void set webkitRegionOverflow(String value) {
    throw new UnsupportedError(
      "WebKit region overflow can't be set for document fragments.");
  }


  _ElementEventsImpl get on =>
    new _ElementEventsImpl(this);

  _ElementImpl $dom_querySelector(String selectors) native "querySelector";

  List<Node> $dom_querySelectorAll(String selectors) native "querySelectorAll";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DocumentImpl extends _NodeImpl implements Document
    native "*HTMLDocument"
{


  _DocumentEventsImpl get on =>
    new _DocumentEventsImpl(this);

  final _ElementImpl activeElement;

  _ElementImpl body;

  String charset;

  String cookie;

  Window get window => _convertNativeToDart_Window(this._window);
  Window get _window => JS("Window", "#.defaultView", this);

  final _ElementImpl documentElement;

  final String domain;

  final _HeadElementImpl head;

  final _DOMImplementationImpl implementation;

  final String lastModified;

  final String preferredStylesheetSet;

  final String readyState;

  final String referrer;

  String selectedStylesheetSet;

  final _StyleSheetListImpl styleSheets;

  String title;

  final _ElementImpl webkitCurrentFullScreenElement;

  final bool webkitFullScreenKeyboardInputAllowed;

  final _ElementImpl webkitFullscreenElement;

  final bool webkitFullscreenEnabled;

  final bool webkitHidden;

  final bool webkitIsFullScreen;

  final _ElementImpl webkitPointerLockElement;

  final String webkitVisibilityState;

  _RangeImpl caretRangeFromPoint(int x, int y) native;

  _CDATASectionImpl createCDATASection(String data) native;

  _DocumentFragmentImpl createDocumentFragment() native;

  _ElementImpl $dom_createElement(String tagName) native "createElement";

  _ElementImpl $dom_createElementNS(String namespaceURI, String qualifiedName) native "createElementNS";

  _EventImpl $dom_createEvent(String eventType) native "createEvent";

  _RangeImpl createRange() native;

  _TextImpl $dom_createTextNode(String data) native "createTextNode";

  _TouchImpl createTouch(_LocalWindowImpl window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) {
    EventTarget target_1 = _convertDartToNative_EventTarget(target);
    return _createTouch_1(window, target_1, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce);
  }
  _TouchImpl _createTouch_1(_LocalWindowImpl window, EventTarget target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce) native "createTouch";

  _TouchListImpl $dom_createTouchList() native "createTouchList";

  _ElementImpl elementFromPoint(int x, int y) native;

  bool execCommand(String command, bool userInterface, String value) native;

  _CanvasRenderingContextImpl getCSSCanvasContext(String contextId, String name, int width, int height) native;

  _ElementImpl $dom_getElementById(String elementId) native "getElementById";

  List<Node> $dom_getElementsByClassName(String tagname) native "getElementsByClassName";

  List<Node> $dom_getElementsByName(String elementName) native "getElementsByName";

  List<Node> $dom_getElementsByTagName(String tagname) native "getElementsByTagName";

  bool queryCommandEnabled(String command) native;

  bool queryCommandIndeterm(String command) native;

  bool queryCommandState(String command) native;

  bool queryCommandSupported(String command) native;

  String queryCommandValue(String command) native;

  _ElementImpl $dom_querySelector(String selectors) native "querySelector";

  List<Node> $dom_querySelectorAll(String selectors) native "querySelectorAll";

  void webkitCancelFullScreen() native;

  void webkitExitFullscreen() native;

  void webkitExitPointerLock() native;

  // TODO(jacobr): implement all Element methods not on Document.

  _ElementImpl query(String selectors) {
    // It is fine for our RegExp to detect element id query selectors to have
    // false negatives but not false positives.
    if (const RegExp("^#[_a-zA-Z]\\w*\$").hasMatch(selectors)) {
      return $dom_getElementById(selectors.substring(1));
    }
    return $dom_querySelector(selectors);
  }

  List<Element> queryAll(String selectors) {
    if (const RegExp("""^\\[name=["'][^'"]+['"]\\]\$""").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByName(
          selectors.substring(7,selectors.length - 2));
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else if (const RegExp("^[*a-zA-Z0-9]+\$").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByTagName(selectors);
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else {
      return new _FrozenElementList._wrap($dom_querySelectorAll(selectors));
    }
  }
}

class _DocumentEventsImpl extends _ElementEventsImpl implements DocumentEvents {
  _DocumentEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get beforeCopy => this['beforecopy'];

  EventListenerList get beforeCut => this['beforecut'];

  EventListenerList get beforePaste => this['beforepaste'];

  EventListenerList get blur => this['blur'];

  EventListenerList get change => this['change'];

  EventListenerList get click => this['click'];

  EventListenerList get contextMenu => this['contextmenu'];

  EventListenerList get copy => this['copy'];

  EventListenerList get cut => this['cut'];

  EventListenerList get doubleClick => this['dblclick'];

  EventListenerList get drag => this['drag'];

  EventListenerList get dragEnd => this['dragend'];

  EventListenerList get dragEnter => this['dragenter'];

  EventListenerList get dragLeave => this['dragleave'];

  EventListenerList get dragOver => this['dragover'];

  EventListenerList get dragStart => this['dragstart'];

  EventListenerList get drop => this['drop'];

  EventListenerList get error => this['error'];

  EventListenerList get focus => this['focus'];

  EventListenerList get input => this['input'];

  EventListenerList get invalid => this['invalid'];

  EventListenerList get keyDown => this['keydown'];

  EventListenerList get keyPress => this['keypress'];

  EventListenerList get keyUp => this['keyup'];

  EventListenerList get load => this['load'];

  EventListenerList get mouseDown => this['mousedown'];

  EventListenerList get mouseMove => this['mousemove'];

  EventListenerList get mouseOut => this['mouseout'];

  EventListenerList get mouseOver => this['mouseover'];

  EventListenerList get mouseUp => this['mouseup'];

  EventListenerList get mouseWheel => this['mousewheel'];

  EventListenerList get paste => this['paste'];

  EventListenerList get readyStateChange => this['readystatechange'];

  EventListenerList get reset => this['reset'];

  EventListenerList get scroll => this['scroll'];

  EventListenerList get search => this['search'];

  EventListenerList get select => this['select'];

  EventListenerList get selectionChange => this['selectionchange'];

  EventListenerList get selectStart => this['selectstart'];

  EventListenerList get submit => this['submit'];

  EventListenerList get touchCancel => this['touchcancel'];

  EventListenerList get touchEnd => this['touchend'];

  EventListenerList get touchMove => this['touchmove'];

  EventListenerList get touchStart => this['touchstart'];

  EventListenerList get fullscreenChange => this['webkitfullscreenchange'];

  EventListenerList get fullscreenError => this['webkitfullscreenerror'];

  EventListenerList get pointerLockChange => this['webkitpointerlockchange'];

  EventListenerList get pointerLockError => this['webkitpointerlockerror'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DocumentType
abstract class DocumentType implements Node {

  /** @domName DocumentType.entities */
  NamedNodeMap get entities;

  /** @domName DocumentType.internalSubset */
  String get internalSubset;

  /** @domName DocumentType.name */
  String get name;

  /** @domName DocumentType.notations */
  NamedNodeMap get notations;

  /** @domName DocumentType.publicId */
  String get publicId;

  /** @domName DocumentType.systemId */
  String get systemId;

  /** @domName DocumentType.remove */
  void remove();
}

class _DocumentTypeImpl extends _NodeImpl implements DocumentType native "*DocumentType" {

  final _NamedNodeMapImpl entities;

  final String internalSubset;

  final String name;

  final _NamedNodeMapImpl notations;

  final String publicId;

  final String systemId;

  void remove() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DynamicsCompressorNode
abstract class DynamicsCompressorNode implements AudioNode {

  /** @domName DynamicsCompressorNode.attack */
  AudioParam get attack;

  /** @domName DynamicsCompressorNode.knee */
  AudioParam get knee;

  /** @domName DynamicsCompressorNode.ratio */
  AudioParam get ratio;

  /** @domName DynamicsCompressorNode.reduction */
  AudioParam get reduction;

  /** @domName DynamicsCompressorNode.release */
  AudioParam get release;

  /** @domName DynamicsCompressorNode.threshold */
  AudioParam get threshold;
}

class _DynamicsCompressorNodeImpl extends _AudioNodeImpl implements DynamicsCompressorNode native "*DynamicsCompressorNode" {

  final _AudioParamImpl attack;

  final _AudioParamImpl knee;

  final _AudioParamImpl ratio;

  final _AudioParamImpl reduction;

  final _AudioParamImpl release;

  final _AudioParamImpl threshold;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EXTTextureFilterAnisotropic
abstract class EXTTextureFilterAnisotropic {

  static const int MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

  static const int TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;
}

class _EXTTextureFilterAnisotropicImpl implements EXTTextureFilterAnisotropic native "*EXTTextureFilterAnisotropic" {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/**
 * All your attribute manipulation needs in one place.
 * Extends the regular Map interface by automatically coercing non-string
 * values to strings.
 */
abstract class AttributeMap implements Map<String, String> {
  void operator []=(String key, value);
}

/**
 * All your element measurement needs in one place
 */
abstract class ElementRect {
  // Relative to offsetParent
  ClientRect get client;
  ClientRect get offset;
  ClientRect get scroll;
  // In global coords
  ClientRect get bounding;
  // In global coords
  List<ClientRect> get clientRects;
}

abstract class NodeSelector {
  Element query(String selectors);
  List<Element> queryAll(String selectors);
}

abstract class CSSClassSet implements Set<String> {
  /**
   * Adds the class [token] to the element if it is not on it, removes it if it
   * is.
   */
  bool toggle(String token);

  /**
   * Returns [:true:] classes cannot be added or removed from this
   * [:CSSClassSet:].
   */
  bool get frozen;
}

/// @domName Element
abstract class Element implements Node, NodeSelector {
  factory Element.html(String html) =>
      _ElementFactoryProvider.createElement_html(html);
  factory Element.tag(String tag) =>
      _ElementFactoryProvider.createElement_tag(tag);

  AttributeMap get attributes;
  void set attributes(Map<String, String> value);

  /**
   * @domName childElementCount, firstElementChild, lastElementChild,
   *   children, Node.nodes.add
   */
  List<Element> get elements;

  void set elements(Collection<Element> value);

  /** @domName className, classList */
  CSSClassSet get classes;

  void set classes(Collection<String> value);

  AttributeMap get dataAttributes;
  void set dataAttributes(Map<String, String> value);

  /**
   * Adds the specified text as a text node after the last child of this.
   */
  void addText(String text);

  /**
   * Parses the specified text as HTML and adds the resulting node after the
   * last child of this.
   */
  void addHTML(String html);

  /**
   * @domName getClientRects, getBoundingClientRect, clientHeight, clientWidth,
   * clientTop, clientLeft, offsetHeight, offsetWidth, offsetTop, offsetLeft,
   * scrollHeight, scrollWidth, scrollTop, scrollLeft
   */
  Future<ElementRect> get rect;

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> get computedStyle;

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement);

  Element clone(bool deep);

  Element get parent;

  /**
   * Experimental support for [web components][wc]. This field stores a
   * reference to the component implementation. It was inspired by Mozilla's
   * [x-tags][] project. Please note: in the future it may be possible to
   * `extend Element` from your class, in which case this field will be
   * deprecated and will simply return this [Element] object.
   *
   * [wc]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html
   * [x-tags]: http://x-tags.org/
   */
  var xtag;


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  ElementEvents get on;

  /** @domName HTMLElement.children */
  HTMLCollection get $dom_children;

  /** @domName HTMLElement.contentEditable */
  String contentEditable;

  /** @domName HTMLElement.dir */
  String dir;

  /** @domName HTMLElement.draggable */
  bool draggable;

  /** @domName HTMLElement.hidden */
  bool hidden;

  /** @domName HTMLElement.id */
  String id;

  /** @domName HTMLElement.innerHTML */
  String innerHTML;

  /** @domName HTMLElement.isContentEditable */
  bool get isContentEditable;

  /** @domName HTMLElement.lang */
  String lang;

  /** @domName HTMLElement.outerHTML */
  String get outerHTML;

  /** @domName HTMLElement.spellcheck */
  bool spellcheck;

  /** @domName HTMLElement.tabIndex */
  int tabIndex;

  /** @domName HTMLElement.title */
  String title;

  /** @domName HTMLElement.translate */
  bool translate;

  /** @domName HTMLElement.webkitdropzone */
  String webkitdropzone;

  /** @domName HTMLElement.click */
  void click();

  /** @domName HTMLElement.insertAdjacentElement */
  Element insertAdjacentElement(String where, Element element);

  /** @domName HTMLElement.insertAdjacentHTML */
  void insertAdjacentHTML(String where, String html);

  /** @domName HTMLElement.insertAdjacentText */
  void insertAdjacentText(String where, String text);

  static const int ALLOW_KEYBOARD_INPUT = 1;

  /** @domName Element.childElementCount */
  int get $dom_childElementCount;

  /** @domName Element.className */
  String $dom_className;

  /** @domName Element.clientHeight */
  int get clientHeight;

  /** @domName Element.clientLeft */
  int get clientLeft;

  /** @domName Element.clientTop */
  int get clientTop;

  /** @domName Element.clientWidth */
  int get clientWidth;

  /** @domName Element.dataset */
  Map<String, String> get dataset;

  /** @domName Element.firstElementChild */
  Element get $dom_firstElementChild;

  /** @domName Element.lastElementChild */
  Element get $dom_lastElementChild;

  /** @domName Element.nextElementSibling */
  Element get nextElementSibling;

  /** @domName Element.offsetHeight */
  int get offsetHeight;

  /** @domName Element.offsetLeft */
  int get offsetLeft;

  /** @domName Element.offsetParent */
  Element get offsetParent;

  /** @domName Element.offsetTop */
  int get offsetTop;

  /** @domName Element.offsetWidth */
  int get offsetWidth;

  /** @domName Element.previousElementSibling */
  Element get previousElementSibling;

  /** @domName Element.scrollHeight */
  int get scrollHeight;

  /** @domName Element.scrollLeft */
  int scrollLeft;

  /** @domName Element.scrollTop */
  int scrollTop;

  /** @domName Element.scrollWidth */
  int get scrollWidth;

  /** @domName Element.style */
  CSSStyleDeclaration get style;

  /** @domName Element.tagName */
  String get tagName;

  /** @domName Element.blur */
  void blur();

  /** @domName Element.focus */
  void focus();

  /** @domName Element.getAttribute */
  String $dom_getAttribute(String name);

  /** @domName Element.getBoundingClientRect */
  ClientRect getBoundingClientRect();

  /** @domName Element.getClientRects */
  List<ClientRect> getClientRects();

  /** @domName Element.getElementsByClassName */
  List<Node> $dom_getElementsByClassName(String name);

  /** @domName Element.getElementsByTagName */
  List<Node> $dom_getElementsByTagName(String name);

  /** @domName Element.hasAttribute */
  bool $dom_hasAttribute(String name);

  /** @domName Element.querySelector */
  Element $dom_querySelector(String selectors);

  /** @domName Element.querySelectorAll */
  List<Node> $dom_querySelectorAll(String selectors);

  /** @domName Element.remove */
  void remove();

  /** @domName Element.removeAttribute */
  void $dom_removeAttribute(String name);

  /** @domName Element.scrollByLines */
  void scrollByLines(int lines);

  /** @domName Element.scrollByPages */
  void scrollByPages(int pages);

  /** @domName Element.scrollIntoViewIfNeeded */
  void scrollIntoView([bool centerIfNeeded]);

  /** @domName Element.setAttribute */
  void $dom_setAttribute(String name, String value);

  /** @domName Element.webkitMatchesSelector */
  bool matchesSelector(String selectors);

  /** @domName Element.webkitRequestFullScreen */
  void webkitRequestFullScreen(int flags);

  /** @domName Element.webkitRequestFullscreen */
  void webkitRequestFullscreen();

  /** @domName Element.webkitRequestPointerLock */
  void webkitRequestPointerLock();

}

abstract class ElementEvents implements Events {

  EventListenerList get abort;

  EventListenerList get beforeCopy;

  EventListenerList get beforeCut;

  EventListenerList get beforePaste;

  EventListenerList get blur;

  EventListenerList get change;

  EventListenerList get click;

  EventListenerList get contextMenu;

  EventListenerList get copy;

  EventListenerList get cut;

  EventListenerList get doubleClick;

  EventListenerList get drag;

  EventListenerList get dragEnd;

  EventListenerList get dragEnter;

  EventListenerList get dragLeave;

  EventListenerList get dragOver;

  EventListenerList get dragStart;

  EventListenerList get drop;

  EventListenerList get error;

  EventListenerList get focus;

  EventListenerList get input;

  EventListenerList get invalid;

  EventListenerList get keyDown;

  EventListenerList get keyPress;

  EventListenerList get keyUp;

  EventListenerList get load;

  EventListenerList get mouseDown;

  EventListenerList get mouseMove;

  EventListenerList get mouseOut;

  EventListenerList get mouseOver;

  EventListenerList get mouseUp;

  EventListenerList get mouseWheel;

  EventListenerList get paste;

  EventListenerList get reset;

  EventListenerList get scroll;

  EventListenerList get search;

  EventListenerList get select;

  EventListenerList get selectStart;

  EventListenerList get submit;

  EventListenerList get touchCancel;

  EventListenerList get touchEnd;

  EventListenerList get touchEnter;

  EventListenerList get touchLeave;

  EventListenerList get touchMove;

  EventListenerList get touchStart;

  EventListenerList get transitionEnd;

  EventListenerList get fullscreenChange;

  EventListenerList get fullscreenError;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): use _Lists.dart to remove some of the duplicated
// functionality.
class _ChildrenElementList implements List {
  // Raw Element.
  final _ElementImpl _element;
  final _HTMLCollectionImpl _childElements;

  _ChildrenElementList._wrap(_ElementImpl element)
    : _childElements = element.$dom_children,
      _element = element;

  List<Element> _toList() {
    final output = new List(_childElements.length);
    for (int i = 0, len = _childElements.length; i < len; i++) {
      output[i] = _childElements[i];
    }
    return output;
  }

  bool contains(Element element) => _childElements.contains(element);

  void forEach(void f(Element element)) {
    for (_ElementImpl element in _childElements) {
      f(element);
    }
  }

  List<Element> filter(bool f(Element element)) {
    final output = [];
    forEach((Element element) {
      if (f(element)) {
        output.add(element);
      }
    });
    return new _FrozenElementList._wrap(output);
  }

  bool every(bool f(Element element)) {
    for (Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for (Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  bool get isEmpty {
    return _element.$dom_firstElementChild == null;
  }

  int get length {
    return _childElements.length;
  }

  _ElementImpl operator [](int index) {
    return _childElements[index];
  }

  void operator []=(int index, _ElementImpl value) {
    _element.$dom_replaceChild(value, _childElements[index]);
  }

   void set length(int newLength) {
     // TODO(jacobr): remove children when length is reduced.
     throw new UnsupportedError('');
   }

  Element add(_ElementImpl value) {
    _element.$dom_appendChild(value);
    return value;
  }

  Element addLast(_ElementImpl value) => add(value);

  Iterator<Element> iterator() => _toList().iterator();

  void addAll(Collection<Element> collection) {
    for (_ElementImpl element in collection) {
      _element.$dom_appendChild(element);
    }
  }

  void sort([Comparator<Element> compare = Comparable.compare]) {
    throw new UnsupportedError('TODO(jacobr): should we impl?');
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw new UnimplementedError();
  }

  void removeRange(int start, int rangeLength) {
    throw new UnimplementedError();
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw new UnimplementedError();
  }

  List getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(_Lists.getRange(this, start, rangeLength,
        []));

  int indexOf(Element element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Element element, [int start = null]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  void clear() {
    // It is unclear if we want to keep non element nodes?
    _element.text = '';
  }

  Element removeLast() {
    final result = this.last;
    if (result != null) {
      _element.$dom_removeChild(result);
    }
    return result;
  }

  Element get last {
    return _element.$dom_lastElementChild;
  }
}

// TODO(jacobr): this is an inefficient implementation but it is hard to see
// a better option given that we cannot quite force NodeList to be an
// ElementList as there are valid cases where a NodeList JavaScript object
// contains Node objects that are not Elements.
class _FrozenElementList implements List {
  final List<Node> _nodeList;

  _FrozenElementList._wrap(this._nodeList);

  Element get first {
    return _nodeList[0];
  }

  bool contains(Element element) {
    for (Element el in this) {
      if (el == element) return true;
    }
    return false;
  }

  void forEach(void f(Element element)) {
    for (Element el in this) {
      f(el);
    }
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  List<Element> filter(bool f(Element element)) {
    final out = [];
    for (Element el in this) {
      if (f(el)) out.add(el);
    }
    return out;
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  bool get isEmpty => _nodeList.isEmpty;

  int get length => _nodeList.length;

  Element operator [](int index) => _nodeList[index];

  void operator []=(int index, Element value) {
    throw new UnsupportedError('');
  }

  void set length(int newLength) {
    _nodeList.length = newLength;
  }

  void add(Element value) {
    throw new UnsupportedError('');
  }

  void addLast(Element value) {
    throw new UnsupportedError('');
  }

  Iterator<Element> iterator() => new _FrozenElementListIterator(this);

  void addAll(Collection<Element> collection) {
    throw new UnsupportedError('');
  }

  void sort([Comparator<Element> compare = Comparable.compare]) {
    throw new UnsupportedError('');
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw new UnsupportedError('');
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError('');
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw new UnsupportedError('');
  }

  List<Element> getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(_nodeList.getRange(start, rangeLength));

  int indexOf(Element element, [int start = 0]) =>
    _nodeList.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) =>
    _nodeList.lastIndexOf(element, start);

  void clear() {
    throw new UnsupportedError('');
  }

  Element removeLast() {
    throw new UnsupportedError('');
  }

  Element get last => _nodeList.last;
}

class _FrozenElementListIterator implements Iterator<Element> {
  final _FrozenElementList _list;
  int _index = 0;

  _FrozenElementListIterator(this._list);

  /**
   * Gets the next element in the iteration. Throws a
   * [StateError("No more elements")] if no element is left.
   */
  Element next() {
    if (!hasNext) {
      throw new StateError("No more elements");
    }

    return _list[_index++];
  }

  /**
   * Returns whether the [Iterator] has elements left.
   */
  bool get hasNext => _index < _list.length;
}

class _ElementAttributeMap implements AttributeMap {

  final _ElementImpl _element;

  _ElementAttributeMap(this._element);

  bool containsValue(String value) {
    final attributes = _element.$dom_attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      if(value == attributes[i].value) {
        return true;
      }
    }
    return false;
  }

  bool containsKey(String key) {
    return _element.$dom_hasAttribute(key);
  }

  String operator [](String key) {
    return _element.$dom_getAttribute(key);
  }

  void operator []=(String key, value) {
    _element.$dom_setAttribute(key, '$value');
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      this[key] = ifAbsent();
    }
    return this[key];
  }

  String remove(String key) {
    String value = _element.$dom_getAttribute(key);
    _element.$dom_removeAttribute(key);
    return value;
  }

  void clear() {
    final attributes = _element.$dom_attributes;
    for (int i = attributes.length - 1; i >= 0; i--) {
      remove(attributes[i].name);
    }
  }

  void forEach(void f(String key, String value)) {
    final attributes = _element.$dom_attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      final item = attributes[i];
      f(item.name, item.value);
    }
  }

  Collection<String> get keys {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.$dom_attributes;
    final keys = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      keys[i] = attributes[i].name;
    }
    return keys;
  }

  Collection<String> get values {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.$dom_attributes;
    final values = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      values[i] = attributes[i].value;
    }
    return values;
  }

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length {
    return _element.$dom_attributes.length;
  }

  /**
   * Returns true if there is no {key, value} pair in the map.
   */
  bool get isEmpty {
    return length == 0;
  }
}

/**
 * Provides a Map abstraction on top of data-* attributes, similar to the
 * dataSet in the old DOM.
 */
class _DataAttributeMap implements AttributeMap {

  final Map<String, String> $dom_attributes;

  _DataAttributeMap(this.$dom_attributes);

  // interface Map

  // TODO: Use lazy iterator when it is available on Map.
  bool containsValue(String value) => values.some((v) => v == value);

  bool containsKey(String key) => $dom_attributes.containsKey(_attr(key));

  String operator [](String key) => $dom_attributes[_attr(key)];

  void operator []=(String key, value) {
    $dom_attributes[_attr(key)] = '$value';
  }

  String putIfAbsent(String key, String ifAbsent()) =>
    $dom_attributes.putIfAbsent(_attr(key), ifAbsent);

  String remove(String key) => $dom_attributes.remove(_attr(key));

  void clear() {
    // Needs to operate on a snapshot since we are mutating the collection.
    for (String key in keys) {
      remove(key);
    }
  }

  void forEach(void f(String key, String value)) {
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        f(_strip(key), value);
      }
    });
  }

  Collection<String> get keys {
    final keys = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        keys.add(_strip(key));
      }
    });
    return keys;
  }

  Collection<String> get values {
    final values = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        values.add(value);
      }
    });
    return values;
  }

  int get length => keys.length;

  // TODO: Use lazy iterator when it is available on Map.
  bool get isEmpty => length == 0;

  // Helpers.
  String _attr(String key) => 'data-$key';
  bool _matches(String key) => key.startsWith('data-');
  String _strip(String key) => key.substring(5);
}

class _CssClassSet implements CSSClassSet {

  final _ElementImpl _element;

  _CssClassSet(this._element);

  String toString() => _formatSet(_read());

  // interface Iterable - BEGIN
  Iterator<String> iterator() => _read().iterator();
  // interface Iterable - END

  // interface Collection - BEGIN
  void forEach(void f(String element)) {
    _read().forEach(f);
  }

  Collection map(f(String element)) => _read().map(f);

  Collection<String> filter(bool f(String element)) => _read().filter(f);

  bool every(bool f(String element)) => _read().every(f);

  bool some(bool f(String element)) => _read().some(f);

  bool get isEmpty => _read().isEmpty;

  bool get frozen => false;

  int get length =>_read().length;

  // interface Collection - END

  // interface Set - BEGIN
  bool contains(String value) => _read().contains(value);

  void add(String value) {
    // TODO - figure out if we need to do any validation here
    // or if the browser natively does enough
    _modify((s) => s.add(value));
  }

  bool remove(String value) {
    Set<String> s = _read();
    bool result = s.remove(value);
    _write(s);
    return result;
  }

  bool toggle(String value) {
    Set<String> s = _read();
    bool result = false;
    if (s.contains(value)) {
      s.remove(value);
    } else {
      s.add(value);
      result = true;
    }
    _write(s);
    return result;
  }

  void addAll(Collection<String> collection) {
    // TODO - see comment above about validation
    _modify((s) => s.addAll(collection));
  }

  void removeAll(Collection<String> collection) {
    _modify((s) => s.removeAll(collection));
  }

  bool isSubsetOf(Collection<String> collection) =>
    _read().isSubsetOf(collection);

  bool containsAll(Collection<String> collection) =>
    _read().containsAll(collection);

  Set<String> intersection(Collection<String> other) =>
    _read().intersection(other);

  void clear() {
    _modify((s) => s.clear());
  }
  // interface Set - END

  /**
   * Helper method used to modify the set of css classes on this element.
   *
   *   f - callback with:
   *      s - a Set of all the css class name currently on this element.
   *
   *   After f returns, the modified set is written to the
   *       className property of this element.
   */
  void _modify( f(Set<String> s)) {
    Set<String> s = _read();
    f(s);
    _write(s);
  }

  /**
   * Read the class names from the Element class property,
   * and put them into a set (duplicates are discarded).
   */
  Set<String> _read() {
    // TODO(mattsh) simplify this once split can take regex.
    Set<String> s = new Set<String>();
    for (String name in _classname().split(' ')) {
      String trimmed = name.trim();
      if (!trimmed.isEmpty) {
        s.add(trimmed);
      }
    }
    return s;
  }

  /**
   * Read the class names as a space-separated string. This is meant to be
   * overridden by subclasses.
   */
  String _classname() => _element.$dom_className;

  /**
   * Join all the elements of a set into one string and write
   * back to the element.
   */
  void _write(Set s) {
    _element.$dom_className = _formatSet(s);
  }

  String _formatSet(Set<String> s) {
    // TODO(mattsh) should be able to pass Set to String.joins http:/b/5398605
    List list = new List.from(s);
    return Strings.join(list, ' ');
  }
}

class _SimpleClientRect implements ClientRect {
  final num left;
  final num top;
  final num width;
  final num height;
  num get right => left + width;
  num get bottom => top + height;

  const _SimpleClientRect(this.left, this.top, this.width, this.height);

  bool operator ==(ClientRect other) {
    return other != null && left == other.left && top == other.top
        && width == other.width && height == other.height;
  }

  String toString() => "($left, $top, $width, $height)";
}

// TODO(jacobr): we cannot currently be lazy about calculating the client
// rects as we must perform all measurement queries at a safe point to avoid
// triggering unneeded layouts.
/**
 * All your element measurement needs in one place
 * @domName none
 */
class _ElementRectImpl implements ElementRect {
  final ClientRect client;
  final ClientRect offset;
  final ClientRect scroll;

  // TODO(jacobr): should we move these outside of ElementRect to avoid the
  // overhead of computing them every time even though they are rarely used.
  final _ClientRectImpl _boundingClientRect;
  final _ClientRectListImpl _clientRects;

  _ElementRectImpl(_ElementImpl element) :
    client = new _SimpleClientRect(element.clientLeft,
                                  element.clientTop,
                                  element.clientWidth,
                                  element.clientHeight),
    offset = new _SimpleClientRect(element.offsetLeft,
                                  element.offsetTop,
                                  element.offsetWidth,
                                  element.offsetHeight),
    scroll = new _SimpleClientRect(element.scrollLeft,
                                  element.scrollTop,
                                  element.scrollWidth,
                                  element.scrollHeight),
    _boundingClientRect = element.getBoundingClientRect(),
    _clientRects = element.getClientRects();

  _ClientRectImpl get bounding => _boundingClientRect;

  // TODO(jacobr): cleanup.
  List<ClientRect> get clientRects {
    final out = new List(_clientRects.length);
    for (num i = 0; i < _clientRects.length; i++) {
      out[i] = _clientRects.item(i);
    }
    return out;
  }
}

class _ElementImpl extends _NodeImpl implements Element native "*Element" {

  /**
   * @domName Element.hasAttribute, Element.getAttribute, Element.setAttribute,
   *   Element.removeAttribute
   */
  _ElementAttributeMap get attributes => new _ElementAttributeMap(this);

  void set attributes(Map<String, String> value) {
    Map<String, String> attributes = this.attributes;
    attributes.clear();
    for (String key in value.keys) {
      attributes[key] = value[key];
    }
  }

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  List<Element> get elements => new _ChildrenElementList._wrap(this);

  _ElementImpl query(String selectors) => $dom_querySelector(selectors);

  List<Element> queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  _CssClassSet get classes => new _CssClassSet(this);

  void set classes(Collection<String> value) {
    _CssClassSet classSet = classes;
    classSet.clear();
    classSet.addAll(value);
  }

  Map<String, String> get dataAttributes =>
    new _DataAttributeMap(attributes);

  void set dataAttributes(Map<String, String> value) {
    final dataAttributes = this.dataAttributes;
    dataAttributes.clear();
    for (String key in value.keys) {
      dataAttributes[key] = value[key];
    }
  }

  Future<ElementRect> get rect {
    return _createMeasurementFuture(
        () => new _ElementRectImpl(this),
        new Completer<ElementRect>());
  }

  Future<CSSStyleDeclaration> get computedStyle {
     // TODO(jacobr): last param should be null, see b/5045788
     return getComputedStyle('');
  }

  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) {
    return _createMeasurementFuture(
        () => _window.$dom_getComputedStyle(this, pseudoElement),
        new Completer<CSSStyleDeclaration>());
  }

  void addText(String text) {
    this.insertAdjacentText('beforeend', text);
  }

  void addHTML(String text) {
    this.insertAdjacentHTML('beforeend', text);
  }

  // Hooks to support custom WebComponents.
  var xtag;

  // TODO(vsm): Implement noSuchMethod or similar for dart2js.

  /** @domName Element.insertAdjacentText */
  void insertAdjacentText(String where, String text) {
    if (JS('bool', '!!#.insertAdjacentText', this)) {
      _insertAdjacentText(where, text);
    } else {
      _insertAdjacentNode(where, new Text(text));
    }
  }

  void _insertAdjacentText(String where, String text)
      native 'insertAdjacentText';

  /** @domName Element.insertAdjacentHTML */
  void insertAdjacentHTML(String where, String text) {
    if (JS('bool', '!!#.insertAdjacentHTML', this)) {
      _insertAdjacentHTML(where, text);
    } else {
      _insertAdjacentNode(where, new DocumentFragment.html(text));
    }
  }

  void _insertAdjacentHTML(String where, String text)
      native 'insertAdjacentHTML';

  /** @domName Element.insertAdjacentHTML */
  Element insertAdjacentElement(String where, Element element) {
    if (JS('bool', '!!#.insertAdjacentElement', this)) {
      _insertAdjacentElement(where, element);
    } else {
      _insertAdjacentNode(where, element);
    }
    return element;
  }

  void _insertAdjacentElement(String where, Element element)
      native 'insertAdjacentElement';

  void _insertAdjacentNode(String where, Node node) {
    switch (where.toLowerCase()) {
      case 'beforebegin':
        this.parent.insertBefore(node, this);
        break;
      case 'afterbegin':
        var first = this.nodes.length > 0 ? this.nodes[0] : null;
        this.insertBefore(node, first);
        break;
      case 'beforeend':
        this.nodes.add(node);
        break;
      case 'afterend':
        this.parent.insertBefore(node, this.nextNode);
        break;
      default:
        throw new ArgumentError("Invalid position ${where}");
    }
  }


  _ElementEventsImpl get on =>
    new _ElementEventsImpl(this);

  _HTMLCollectionImpl get $dom_children => JS("_HTMLCollectionImpl", "#.children", this);

  String contentEditable;

  String dir;

  bool draggable;

  bool hidden;

  String id;

  String innerHTML;

  final bool isContentEditable;

  String lang;

  final String outerHTML;

  bool spellcheck;

  int tabIndex;

  String title;

  bool translate;

  String webkitdropzone;

  void click() native;

  int get $dom_childElementCount => JS("int", "#.childElementCount", this);

  String get $dom_className => JS("String", "#.className", this);

  void set $dom_className(String value) {
    JS("void", "#.className = #", this, value);
  }

  final int clientHeight;

  final int clientLeft;

  final int clientTop;

  final int clientWidth;

  final Map<String, String> dataset;

  _ElementImpl get $dom_firstElementChild => JS("_ElementImpl", "#.firstElementChild", this);

  _ElementImpl get $dom_lastElementChild => JS("_ElementImpl", "#.lastElementChild", this);

  final _ElementImpl nextElementSibling;

  final int offsetHeight;

  final int offsetLeft;

  final _ElementImpl offsetParent;

  final int offsetTop;

  final int offsetWidth;

  final _ElementImpl previousElementSibling;

  final int scrollHeight;

  int scrollLeft;

  int scrollTop;

  final int scrollWidth;

  final _CSSStyleDeclarationImpl style;

  final String tagName;

  void blur() native;

  void focus() native;

  String $dom_getAttribute(String name) native "getAttribute";

  _ClientRectImpl getBoundingClientRect() native;

  _ClientRectListImpl getClientRects() native;

  List<Node> $dom_getElementsByClassName(String name) native "getElementsByClassName";

  List<Node> $dom_getElementsByTagName(String name) native "getElementsByTagName";

  bool $dom_hasAttribute(String name) native "hasAttribute";

  _ElementImpl $dom_querySelector(String selectors) native "querySelector";

  List<Node> $dom_querySelectorAll(String selectors) native "querySelectorAll";

  void $dom_removeAttribute(String name) native "removeAttribute";

  void scrollByLines(int lines) native;

  void scrollByPages(int pages) native;

  void scrollIntoView([bool centerIfNeeded]) native "scrollIntoViewIfNeeded";

  void $dom_setAttribute(String name, String value) native "setAttribute";

  bool matchesSelector(String selectors) native "webkitMatchesSelector";

  void webkitRequestFullScreen(int flags) native;

  void webkitRequestFullscreen() native;

  void webkitRequestPointerLock() native;

}

// Temporary dispatch hook to support WebComponents.
Function dynamicUnknownElementDispatcher;

final _START_TAG_REGEXP = const RegExp('<(\\w+)');
class _ElementFactoryProvider {
  static final _CUSTOM_PARENT_TAG_MAP = const {
    'body' : 'html',
    'head' : 'html',
    'caption' : 'table',
    'td': 'tr',
    'colgroup': 'table',
    'col' : 'colgroup',
    'tr' : 'tbody',
    'tbody' : 'table',
    'tfoot' : 'table',
    'thead' : 'table',
    'track' : 'audio',
  };

  /** @domName Document.createElement */
  static Element createElement_html(String html) {
    // TODO(jacobr): this method can be made more robust and performant.
    // 1) Cache the dummy parent elements required to use innerHTML rather than
    //    creating them every call.
    // 2) Verify that the html does not contain leading or trailing text nodes.
    // 3) Verify that the html does not contain both <head> and <body> tags.
    // 4) Detatch the created element from its dummy parent.
    String parentTag = 'div';
    String tag;
    final match = _START_TAG_REGEXP.firstMatch(html);
    if (match != null) {
      tag = match.group(1).toLowerCase();
      if (_CUSTOM_PARENT_TAG_MAP.containsKey(tag)) {
        parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
      }
    }
    final _ElementImpl temp = new Element.tag(parentTag);
    temp.innerHTML = html;

    Element element;
    if (temp.elements.length == 1) {
      element = temp.elements[0];
    } else if (parentTag == 'html' && temp.elements.length == 2) {
      // Work around for edge case in WebKit and possibly other browsers where
      // both body and head elements are created even though the inner html
      // only contains a head or body element.
      element = temp.elements[tag == 'head' ? 0 : 1];
    } else {
      throw new ArgumentError('HTML had ${temp.elements.length} '
          'top level elements but 1 expected');
    }
    element.remove();
    return element;
  }

  /** @domName Document.createElement */
  // Optimization to improve performance until the dart2js compiler inlines this
  // method.
  static Element createElement_tag(String tag) =>
      JS('Element', 'document.createElement(#)', tag);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ElementEventsImpl extends _EventsImpl implements ElementEvents {
  _ElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get beforeCopy => this['beforecopy'];

  EventListenerList get beforeCut => this['beforecut'];

  EventListenerList get beforePaste => this['beforepaste'];

  EventListenerList get blur => this['blur'];

  EventListenerList get change => this['change'];

  EventListenerList get click => this['click'];

  EventListenerList get contextMenu => this['contextmenu'];

  EventListenerList get copy => this['copy'];

  EventListenerList get cut => this['cut'];

  EventListenerList get doubleClick => this['dblclick'];

  EventListenerList get drag => this['drag'];

  EventListenerList get dragEnd => this['dragend'];

  EventListenerList get dragEnter => this['dragenter'];

  EventListenerList get dragLeave => this['dragleave'];

  EventListenerList get dragOver => this['dragover'];

  EventListenerList get dragStart => this['dragstart'];

  EventListenerList get drop => this['drop'];

  EventListenerList get error => this['error'];

  EventListenerList get focus => this['focus'];

  EventListenerList get input => this['input'];

  EventListenerList get invalid => this['invalid'];

  EventListenerList get keyDown => this['keydown'];

  EventListenerList get keyPress => this['keypress'];

  EventListenerList get keyUp => this['keyup'];

  EventListenerList get load => this['load'];

  EventListenerList get mouseDown => this['mousedown'];

  EventListenerList get mouseMove => this['mousemove'];

  EventListenerList get mouseOut => this['mouseout'];

  EventListenerList get mouseOver => this['mouseover'];

  EventListenerList get mouseUp => this['mouseup'];

  EventListenerList get paste => this['paste'];

  EventListenerList get reset => this['reset'];

  EventListenerList get scroll => this['scroll'];

  EventListenerList get search => this['search'];

  EventListenerList get select => this['select'];

  EventListenerList get selectStart => this['selectstart'];

  EventListenerList get submit => this['submit'];

  EventListenerList get touchCancel => this['touchcancel'];

  EventListenerList get touchEnd => this['touchend'];

  EventListenerList get touchEnter => this['touchenter'];

  EventListenerList get touchLeave => this['touchleave'];

  EventListenerList get touchMove => this['touchmove'];

  EventListenerList get touchStart => this['touchstart'];

  EventListenerList get transitionEnd => this['webkitTransitionEnd'];

  EventListenerList get fullscreenChange => this['webkitfullscreenchange'];

  EventListenerList get fullscreenError => this['webkitfullscreenerror'];

  EventListenerList get mouseWheel {
    if (JS('bool', '#.onwheel !== undefined', _ptr)) {
      // W3C spec, and should be IE9+, but IE has a bug exposing onwheel.
      return this['wheel'];
    } else if (JS('bool', '#.onmousewheel !== undefined', _ptr)) {
      // Chrome & IE
      return this['mousewheel'];
    } else {
      // Firefox
      return this['DOMMouseScroll'];
    }
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ElementTimeControl
abstract class ElementTimeControl {

  /** @domName ElementTimeControl.beginElement */
  void beginElement();

  /** @domName ElementTimeControl.beginElementAt */
  void beginElementAt(num offset);

  /** @domName ElementTimeControl.endElement */
  void endElement();

  /** @domName ElementTimeControl.endElementAt */
  void endElementAt(num offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ElementTraversal
abstract class ElementTraversal {

  /** @domName ElementTraversal.childElementCount */
  int get childElementCount;

  /** @domName ElementTraversal.firstElementChild */
  Element get firstElementChild;

  /** @domName ElementTraversal.lastElementChild */
  Element get lastElementChild;

  /** @domName ElementTraversal.nextElementSibling */
  Element get nextElementSibling;

  /** @domName ElementTraversal.previousElementSibling */
  Element get previousElementSibling;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLEmbedElement
abstract class EmbedElement implements Element {

  factory EmbedElement() => _Elements.createEmbedElement();

  /** @domName HTMLEmbedElement.align */
  String align;

  /** @domName HTMLEmbedElement.height */
  String height;

  /** @domName HTMLEmbedElement.name */
  String name;

  /** @domName HTMLEmbedElement.src */
  String src;

  /** @domName HTMLEmbedElement.type */
  String type;

  /** @domName HTMLEmbedElement.width */
  String width;
}

class _EmbedElementImpl extends _ElementImpl implements EmbedElement native "*HTMLEmbedElement" {

  String align;

  String height;

  String name;

  String src;

  String type;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntityReference
abstract class EntityReference implements Node {
}

class _EntityReferenceImpl extends _NodeImpl implements EntityReference native "*EntityReference" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void EntriesCallback(List<Entry> entries);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Entry
abstract class Entry {

  /** @domName Entry.filesystem */
  DOMFileSystem get filesystem;

  /** @domName Entry.fullPath */
  String get fullPath;

  /** @domName Entry.isDirectory */
  bool get isDirectory;

  /** @domName Entry.isFile */
  bool get isFile;

  /** @domName Entry.name */
  String get name;

  /** @domName Entry.copyTo */
  void copyTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.getMetadata */
  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName Entry.getParent */
  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.moveTo */
  void moveTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.remove */
  void remove(VoidCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName Entry.toURL */
  String toURL();
}

class _EntryArrayImpl implements List<Entry>, JavaScriptIndexingBehavior native "*EntryArray" {

  final int length;

  _EntryImpl operator[](int index) => JS("_EntryImpl", "#[#]", this, index);

  void operator[]=(int index, _EntryImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Entry> mixins.
  // Entry is the element type.

  // From Iterable<Entry>:

  Iterator<Entry> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Entry>(this);
  }

  // From Collection<Entry>:

  void add(Entry value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Entry value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Entry> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Entry element) => _Collections.contains(this, element);

  void forEach(void f(Entry element)) => _Collections.forEach(this, f);

  Collection map(f(Entry element)) => _Collections.map(this, [], f);

  Collection<Entry> filter(bool f(Entry element)) =>
     _Collections.filter(this, <Entry>[], f);

  bool every(bool f(Entry element)) => _Collections.every(this, f);

  bool some(bool f(Entry element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Entry>:

  void sort([Comparator<Entry> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Entry element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Entry element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Entry get last => this[length - 1];

  Entry removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Entry> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Entry initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Entry> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Entry>[]);

  // -- end List<Entry> mixins.

  _EntryImpl item(int index) native;
}

class _EntryArraySyncImpl implements List<EntrySync>, JavaScriptIndexingBehavior native "*EntryArraySync" {

  final int length;

  _EntrySyncImpl operator[](int index) => JS("_EntrySyncImpl", "#[#]", this, index);

  void operator[]=(int index, _EntrySyncImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<EntrySync> mixins.
  // EntrySync is the element type.

  // From Iterable<EntrySync>:

  Iterator<EntrySync> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<EntrySync>(this);
  }

  // From Collection<EntrySync>:

  void add(EntrySync value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(EntrySync value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<EntrySync> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(EntrySync element) => _Collections.contains(this, element);

  void forEach(void f(EntrySync element)) => _Collections.forEach(this, f);

  Collection map(f(EntrySync element)) => _Collections.map(this, [], f);

  Collection<EntrySync> filter(bool f(EntrySync element)) =>
     _Collections.filter(this, <EntrySync>[], f);

  bool every(bool f(EntrySync element)) => _Collections.every(this, f);

  bool some(bool f(EntrySync element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<EntrySync>:

  void sort([Comparator<EntrySync> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(EntrySync element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(EntrySync element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  EntrySync get last => this[length - 1];

  EntrySync removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<EntrySync> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [EntrySync initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<EntrySync> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <EntrySync>[]);

  // -- end List<EntrySync> mixins.

  _EntrySyncImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void EntryCallback(Entry entry);

class _EntryImpl implements Entry native "*Entry" {

  final _DOMFileSystemImpl filesystem;

  final String fullPath;

  final bool isDirectory;

  final bool isFile;

  final String name;

  void copyTo(_DirectoryEntryImpl parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]) native;

  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback]) native;

  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]) native;

  void moveTo(_DirectoryEntryImpl parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]) native;

  void remove(VoidCallback successCallback, [ErrorCallback errorCallback]) native;

  String toURL() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntrySync
abstract class EntrySync {

  /** @domName EntrySync.filesystem */
  DOMFileSystemSync get filesystem;

  /** @domName EntrySync.fullPath */
  String get fullPath;

  /** @domName EntrySync.isDirectory */
  bool get isDirectory;

  /** @domName EntrySync.isFile */
  bool get isFile;

  /** @domName EntrySync.name */
  String get name;

  /** @domName EntrySync.copyTo */
  EntrySync copyTo(DirectoryEntrySync parent, String name);

  /** @domName EntrySync.getMetadata */
  Metadata getMetadata();

  /** @domName EntrySync.getParent */
  EntrySync getParent();

  /** @domName EntrySync.moveTo */
  EntrySync moveTo(DirectoryEntrySync parent, String name);

  /** @domName EntrySync.remove */
  void remove();

  /** @domName EntrySync.toURL */
  String toURL();
}

class _EntrySyncImpl implements EntrySync native "*EntrySync" {

  final _DOMFileSystemSyncImpl filesystem;

  final String fullPath;

  final bool isDirectory;

  final bool isFile;

  final String name;

  _EntrySyncImpl copyTo(_DirectoryEntrySyncImpl parent, String name) native;

  _MetadataImpl getMetadata() native;

  _EntrySyncImpl getParent() native;

  _EntrySyncImpl moveTo(_DirectoryEntrySyncImpl parent, String name) native;

  void remove() native;

  String toURL() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void ErrorCallback(FileError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ErrorEvent
abstract class ErrorEvent implements Event {

  /** @domName ErrorEvent.filename */
  String get filename;

  /** @domName ErrorEvent.lineno */
  int get lineno;

  /** @domName ErrorEvent.message */
  String get message;
}

class _ErrorEventImpl extends _EventImpl implements ErrorEvent native "*ErrorEvent" {

  final String filename;

  final int lineno;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName Event
abstract class Event {

  // In JS, canBubble and cancelable are technically required parameters to
  // init*Event. In practice, though, if they aren't provided they simply
  // default to false (since that's Boolean(undefined)).
  //
  // Contrary to JS, we default canBubble and cancelable to true, since that's
  // what people want most of the time anyway.
  factory Event(String type, [bool canBubble = true, bool cancelable = true]) =>
      _EventFactoryProvider.createEvent(type, canBubble, cancelable);

  static const int AT_TARGET = 2;

  static const int BLUR = 8192;

  static const int BUBBLING_PHASE = 3;

  static const int CAPTURING_PHASE = 1;

  static const int CHANGE = 32768;

  static const int CLICK = 64;

  static const int DBLCLICK = 128;

  static const int DRAGDROP = 2048;

  static const int FOCUS = 4096;

  static const int KEYDOWN = 256;

  static const int KEYPRESS = 1024;

  static const int KEYUP = 512;

  static const int MOUSEDOWN = 1;

  static const int MOUSEDRAG = 32;

  static const int MOUSEMOVE = 16;

  static const int MOUSEOUT = 8;

  static const int MOUSEOVER = 4;

  static const int MOUSEUP = 2;

  static const int NONE = 0;

  static const int SELECT = 16384;

  /** @domName Event.bubbles */
  bool get bubbles;

  /** @domName Event.cancelBubble */
  bool cancelBubble;

  /** @domName Event.cancelable */
  bool get cancelable;

  /** @domName Event.clipboardData */
  Clipboard get clipboardData;

  /** @domName Event.currentTarget */
  EventTarget get currentTarget;

  /** @domName Event.defaultPrevented */
  bool get defaultPrevented;

  /** @domName Event.eventPhase */
  int get eventPhase;

  /** @domName Event.returnValue */
  bool returnValue;

  /** @domName Event.srcElement */
  EventTarget get srcElement;

  /** @domName Event.target */
  EventTarget get target;

  /** @domName Event.timeStamp */
  int get timeStamp;

  /** @domName Event.type */
  String get type;

  /** @domName Event.initEvent */
  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg);

  /** @domName Event.preventDefault */
  void preventDefault();

  /** @domName Event.stopImmediatePropagation */
  void stopImmediatePropagation();

  /** @domName Event.stopPropagation */
  void stopPropagation();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EventException
abstract class EventException {

  static const int DISPATCH_REQUEST_ERR = 1;

  static const int UNSPECIFIED_EVENT_TYPE_ERR = 0;

  /** @domName EventException.code */
  int get code;

  /** @domName EventException.message */
  String get message;

  /** @domName EventException.name */
  String get name;

  /** @domName EventException.toString */
  String toString();
}

class _EventExceptionImpl implements EventException native "*EventException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}

class _EventImpl implements Event native "*Event" {

  final bool bubbles;

  bool cancelBubble;

  final bool cancelable;

  final _ClipboardImpl clipboardData;

  EventTarget get currentTarget => _convertNativeToDart_EventTarget(this._currentTarget);
  EventTarget get _currentTarget => JS("EventTarget", "#.currentTarget", this);

  final bool defaultPrevented;

  final int eventPhase;

  bool returnValue;

  EventTarget get srcElement => _convertNativeToDart_EventTarget(this._srcElement);
  EventTarget get _srcElement => JS("EventTarget", "#.srcElement", this);

  EventTarget get target => _convertNativeToDart_EventTarget(this._target);
  EventTarget get _target => JS("EventTarget", "#.target", this);

  final int timeStamp;

  final String type;

  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) native "initEvent";

  void preventDefault() native;

  void stopImmediatePropagation() native;

  void stopPropagation() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EventSource
abstract class EventSource implements EventTarget {

  factory EventSource(String scriptUrl) => _EventSourceFactoryProvider.createEventSource(scriptUrl);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  EventSourceEvents get on;

  static const int CLOSED = 2;

  static const int CONNECTING = 0;

  static const int OPEN = 1;

  /** @domName EventSource.URL */
  String get URL;

  /** @domName EventSource.readyState */
  int get readyState;

  /** @domName EventSource.url */
  String get url;

  /** @domName EventSource.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName EventSource.close */
  void close();

  /** @domName EventSource.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName EventSource.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class EventSourceEvents implements Events {

  EventListenerList get error;

  EventListenerList get message;

  EventListenerList get open;
}

class _EventSourceImpl extends _EventTargetImpl implements EventSource native "*EventSource" {

  _EventSourceEventsImpl get on =>
    new _EventSourceEventsImpl(this);

  final String URL;

  final int readyState;

  final String url;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void close() native;

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _EventSourceEventsImpl extends _EventsImpl implements EventSourceEvents {
  _EventSourceEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error => this['error'];

  EventListenerList get message => this['message'];

  EventListenerList get open => this['open'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


abstract class EventListenerList {
  EventListenerList add(EventListener handler, [bool useCapture]);

  EventListenerList remove(EventListener handler, [bool useCapture]);

  bool dispatch(Event evt);
}

abstract class Events {
  EventListenerList operator [](String type);
}

/// @domName EventTarget
abstract class EventTarget {

  /** @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent */
  abstract Events get on;

  /** @domName EventTarget.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName EventTarget.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName EventTarget.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventsImpl implements Events {
  /* Raw event target. */
  // TODO(jacobr): it would be nice if we could specify this as
  // _EventTargetImpl or EventTarget
  final _ptr;

  _EventsImpl(this._ptr);

  _EventListenerListImpl operator [](String type) {
    return new _EventListenerListImpl(_ptr, type);
  }
}

class _EventListenerListImpl implements EventListenerList {

  // TODO(jacobr): make this _EventTargetImpl
  final _ptr;
  final String _type;

  _EventListenerListImpl(this._ptr, this._type);

  // TODO(jacobr): implement equals.

  _EventListenerListImpl add(EventListener listener,
      [bool useCapture = false]) {
    _add(listener, useCapture);
    return this;
  }

  _EventListenerListImpl remove(EventListener listener,
      [bool useCapture = false]) {
    _remove(listener, useCapture);
    return this;
  }

  bool dispatch(Event evt) {
    return _ptr.$dom_dispatchEvent(evt);
  }

  void _add(EventListener listener, bool useCapture) {
    _ptr.$dom_addEventListener(_type, listener, useCapture);
  }

  void _remove(EventListener listener, bool useCapture) {
    _ptr.$dom_removeEventListener(_type, listener, useCapture);
  }
}


class _EventTargetImpl implements EventTarget native "*EventTarget" {

  Events get on => new _EventsImpl(this);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFieldSetElement
abstract class FieldSetElement implements Element {

  factory FieldSetElement() => _Elements.createFieldSetElement();

  /** @domName HTMLFieldSetElement.disabled */
  bool disabled;

  /** @domName HTMLFieldSetElement.elements */
  HTMLCollection get elements;

  /** @domName HTMLFieldSetElement.form */
  FormElement get form;

  /** @domName HTMLFieldSetElement.name */
  String name;

  /** @domName HTMLFieldSetElement.type */
  String get type;

  /** @domName HTMLFieldSetElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLFieldSetElement.validity */
  ValidityState get validity;

  /** @domName HTMLFieldSetElement.willValidate */
  bool get willValidate;

  /** @domName HTMLFieldSetElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLFieldSetElement.setCustomValidity */
  void setCustomValidity(String error);
}

class _FieldSetElementImpl extends _ElementImpl implements FieldSetElement native "*HTMLFieldSetElement" {

  bool disabled;

  final _HTMLCollectionImpl elements;

  final _FormElementImpl form;

  String name;

  final String type;

  final String validationMessage;

  final _ValidityStateImpl validity;

  final bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName File
abstract class File implements Blob {

  /** @domName File.lastModifiedDate */
  Date get lastModifiedDate;

  /** @domName File.name */
  String get name;

  /** @domName File.webkitRelativePath */
  String get webkitRelativePath;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void FileCallback(File file);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileEntry
abstract class FileEntry implements Entry {

  /** @domName FileEntry.createWriter */
  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName FileEntry.file */
  void file(FileCallback successCallback, [ErrorCallback errorCallback]);
}

class _FileEntryImpl extends _EntryImpl implements FileEntry native "*FileEntry" {

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]) native;

  void file(FileCallback successCallback, [ErrorCallback errorCallback]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileEntrySync
abstract class FileEntrySync implements EntrySync {

  /** @domName FileEntrySync.createWriter */
  FileWriterSync createWriter();

  /** @domName FileEntrySync.file */
  File file();
}

class _FileEntrySyncImpl extends _EntrySyncImpl implements FileEntrySync native "*FileEntrySync" {

  _FileWriterSyncImpl createWriter() native;

  _FileImpl file() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileError
abstract class FileError {

  static const int ABORT_ERR = 3;

  static const int ENCODING_ERR = 5;

  static const int INVALID_MODIFICATION_ERR = 9;

  static const int INVALID_STATE_ERR = 7;

  static const int NOT_FOUND_ERR = 1;

  static const int NOT_READABLE_ERR = 4;

  static const int NO_MODIFICATION_ALLOWED_ERR = 6;

  static const int PATH_EXISTS_ERR = 12;

  static const int QUOTA_EXCEEDED_ERR = 10;

  static const int SECURITY_ERR = 2;

  static const int SYNTAX_ERR = 8;

  static const int TYPE_MISMATCH_ERR = 11;

  /** @domName FileError.code */
  int get code;
}

class _FileErrorImpl implements FileError native "*FileError" {

  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileException
abstract class FileException {

  static const int ABORT_ERR = 3;

  static const int ENCODING_ERR = 5;

  static const int INVALID_MODIFICATION_ERR = 9;

  static const int INVALID_STATE_ERR = 7;

  static const int NOT_FOUND_ERR = 1;

  static const int NOT_READABLE_ERR = 4;

  static const int NO_MODIFICATION_ALLOWED_ERR = 6;

  static const int PATH_EXISTS_ERR = 12;

  static const int QUOTA_EXCEEDED_ERR = 10;

  static const int SECURITY_ERR = 2;

  static const int SYNTAX_ERR = 8;

  static const int TYPE_MISMATCH_ERR = 11;

  /** @domName FileException.code */
  int get code;

  /** @domName FileException.message */
  String get message;

  /** @domName FileException.name */
  String get name;

  /** @domName FileException.toString */
  String toString();
}

class _FileExceptionImpl implements FileException native "*FileException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}

class _FileImpl extends _BlobImpl implements File native "*File" {

  final Date lastModifiedDate;

  final String name;

  final String webkitRelativePath;
}

class _FileListImpl implements List<File>, JavaScriptIndexingBehavior native "*FileList" {

  final int length;

  _FileImpl operator[](int index) => JS("_FileImpl", "#[#]", this, index);

  void operator[]=(int index, _FileImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<File> mixins.
  // File is the element type.

  // From Iterable<File>:

  Iterator<File> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<File>(this);
  }

  // From Collection<File>:

  void add(File value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(File value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<File> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(File element) => _Collections.contains(this, element);

  void forEach(void f(File element)) => _Collections.forEach(this, f);

  Collection map(f(File element)) => _Collections.map(this, [], f);

  Collection<File> filter(bool f(File element)) =>
     _Collections.filter(this, <File>[], f);

  bool every(bool f(File element)) => _Collections.every(this, f);

  bool some(bool f(File element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<File>:

  void sort([Comparator<File> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(File element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(File element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  File get last => this[length - 1];

  File removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<File> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [File initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<File> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <File>[]);

  // -- end List<File> mixins.

  _FileImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileReader
abstract class FileReader implements EventTarget {

  factory FileReader() => _FileReaderFactoryProvider.createFileReader();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FileReaderEvents get on;

  static const int DONE = 2;

  static const int EMPTY = 0;

  static const int LOADING = 1;

  /** @domName FileReader.error */
  FileError get error;

  /** @domName FileReader.readyState */
  int get readyState;

  /** @domName FileReader.result */
  Object get result;

  /** @domName FileReader.abort */
  void abort();

  /** @domName FileReader.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileReader.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName FileReader.readAsArrayBuffer */
  void readAsArrayBuffer(Blob blob);

  /** @domName FileReader.readAsBinaryString */
  void readAsBinaryString(Blob blob);

  /** @domName FileReader.readAsDataURL */
  void readAsDataURL(Blob blob);

  /** @domName FileReader.readAsText */
  void readAsText(Blob blob, [String encoding]);

  /** @domName FileReader.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class FileReaderEvents implements Events {

  EventListenerList get abort;

  EventListenerList get error;

  EventListenerList get load;

  EventListenerList get loadEnd;

  EventListenerList get loadStart;

  EventListenerList get progress;
}

class _FileReaderImpl extends _EventTargetImpl implements FileReader native "*FileReader" {

  _FileReaderEventsImpl get on =>
    new _FileReaderEventsImpl(this);

  final _FileErrorImpl error;

  final int readyState;

  final Object result;

  void abort() native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void readAsArrayBuffer(_BlobImpl blob) native;

  void readAsBinaryString(_BlobImpl blob) native;

  void readAsDataURL(_BlobImpl blob) native;

  void readAsText(_BlobImpl blob, [String encoding]) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _FileReaderEventsImpl extends _EventsImpl implements FileReaderEvents {
  _FileReaderEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get error => this['error'];

  EventListenerList get load => this['load'];

  EventListenerList get loadEnd => this['loadend'];

  EventListenerList get loadStart => this['loadstart'];

  EventListenerList get progress => this['progress'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileReaderSync
abstract class FileReaderSync {

  factory FileReaderSync() => _FileReaderSyncFactoryProvider.createFileReaderSync();

  /** @domName FileReaderSync.readAsArrayBuffer */
  ArrayBuffer readAsArrayBuffer(Blob blob);

  /** @domName FileReaderSync.readAsBinaryString */
  String readAsBinaryString(Blob blob);

  /** @domName FileReaderSync.readAsDataURL */
  String readAsDataURL(Blob blob);

  /** @domName FileReaderSync.readAsText */
  String readAsText(Blob blob, [String encoding]);
}

class _FileReaderSyncImpl implements FileReaderSync native "*FileReaderSync" {

  _ArrayBufferImpl readAsArrayBuffer(_BlobImpl blob) native;

  String readAsBinaryString(_BlobImpl blob) native;

  String readAsDataURL(_BlobImpl blob) native;

  String readAsText(_BlobImpl blob, [String encoding]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void FileSystemCallback(DOMFileSystem fileSystem);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileWriter
abstract class FileWriter implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FileWriterEvents get on;

  static const int DONE = 2;

  static const int INIT = 0;

  static const int WRITING = 1;

  /** @domName FileWriter.error */
  FileError get error;

  /** @domName FileWriter.length */
  int get length;

  /** @domName FileWriter.position */
  int get position;

  /** @domName FileWriter.readyState */
  int get readyState;

  /** @domName FileWriter.abort */
  void abort();

  /** @domName FileWriter.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileWriter.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName FileWriter.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileWriter.seek */
  void seek(int position);

  /** @domName FileWriter.truncate */
  void truncate(int size);

  /** @domName FileWriter.write */
  void write(Blob data);
}

abstract class FileWriterEvents implements Events {

  EventListenerList get abort;

  EventListenerList get error;

  EventListenerList get progress;

  EventListenerList get write;

  EventListenerList get writeEnd;

  EventListenerList get writeStart;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void FileWriterCallback(FileWriter fileWriter);

class _FileWriterImpl extends _EventTargetImpl implements FileWriter native "*FileWriter" {

  _FileWriterEventsImpl get on =>
    new _FileWriterEventsImpl(this);

  final _FileErrorImpl error;

  final int length;

  final int position;

  final int readyState;

  void abort() native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void seek(int position) native;

  void truncate(int size) native;

  void write(_BlobImpl data) native;
}

class _FileWriterEventsImpl extends _EventsImpl implements FileWriterEvents {
  _FileWriterEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get error => this['error'];

  EventListenerList get progress => this['progress'];

  EventListenerList get write => this['write'];

  EventListenerList get writeEnd => this['writeend'];

  EventListenerList get writeStart => this['writestart'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileWriterSync
abstract class FileWriterSync {

  /** @domName FileWriterSync.length */
  int get length;

  /** @domName FileWriterSync.position */
  int get position;

  /** @domName FileWriterSync.seek */
  void seek(int position);

  /** @domName FileWriterSync.truncate */
  void truncate(int size);

  /** @domName FileWriterSync.write */
  void write(Blob data);
}

class _FileWriterSyncImpl implements FileWriterSync native "*FileWriterSync" {

  final int length;

  final int position;

  void seek(int position) native;

  void truncate(int size) native;

  void write(_BlobImpl data) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Float32Array
abstract class Float32Array implements ArrayBufferView, List<num> {

  factory Float32Array(int length) =>
    _TypedArrayFactoryProvider.createFloat32Array(length);

  factory Float32Array.fromList(List<num> list) =>
    _TypedArrayFactoryProvider.createFloat32Array_fromList(list);

  factory Float32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createFloat32Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 4;

  /** @domName Float32Array.length */
  int get length;

  /** @domName Float32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Float32Array.subarray */
  Float32Array subarray(int start, [int end]);
}

class _Float32ArrayImpl extends _ArrayBufferViewImpl implements Float32Array, List<num>, JavaScriptIndexingBehavior native "*Float32Array" {

  final int length;

  num operator[](int index) => JS("num", "#[#]", this, index);

  void operator[]=(int index, num value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<num>(this);
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(num element) => _Collections.contains(this, element);

  void forEach(void f(num element)) => _Collections.forEach(this, f);

  Collection map(f(num element)) => _Collections.map(this, [], f);

  Collection<num> filter(bool f(num element)) =>
     _Collections.filter(this, <num>[], f);

  bool every(bool f(num element)) => _Collections.every(this, f);

  bool some(bool f(num element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<num>:

  void sort([Comparator<num> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  num get last => this[length - 1];

  num removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Float32ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Float64Array
abstract class Float64Array implements ArrayBufferView, List<num> {

  factory Float64Array(int length) =>
    _TypedArrayFactoryProvider.createFloat64Array(length);

  factory Float64Array.fromList(List<num> list) =>
    _TypedArrayFactoryProvider.createFloat64Array_fromList(list);

  factory Float64Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createFloat64Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 8;

  /** @domName Float64Array.length */
  int get length;

  /** @domName Float64Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Float64Array.subarray */
  Float64Array subarray(int start, [int end]);
}

class _Float64ArrayImpl extends _ArrayBufferViewImpl implements Float64Array, List<num>, JavaScriptIndexingBehavior native "*Float64Array" {

  final int length;

  num operator[](int index) => JS("num", "#[#]", this, index);

  void operator[]=(int index, num value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<num>(this);
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(num element) => _Collections.contains(this, element);

  void forEach(void f(num element)) => _Collections.forEach(this, f);

  Collection map(f(num element)) => _Collections.map(this, [], f);

  Collection<num> filter(bool f(num element)) =>
     _Collections.filter(this, <num>[], f);

  bool every(bool f(num element)) => _Collections.every(this, f);

  bool some(bool f(num element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<num>:

  void sort([Comparator<num> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  num get last => this[length - 1];

  num removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Float64ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFontElement
abstract class FontElement implements Element {

  /** @domName HTMLFontElement.color */
  String color;

  /** @domName HTMLFontElement.face */
  String face;

  /** @domName HTMLFontElement.size */
  String size;
}

class _FontElementImpl extends _ElementImpl implements FontElement native "*HTMLFontElement" {

  String color;

  String face;

  String size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FormData
abstract class FormData {

  factory FormData([FormElement form]) {
    if (!?form) {
      return _FormDataFactoryProvider.createFormData();
    }
    return _FormDataFactoryProvider.createFormData(form);
  }

  /** @domName FormData.append */
  void append(String name, String value, String filename);
}

class _FormDataImpl implements FormData native "*FormData" {

  void append(String name, String value, String filename) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFormElement
abstract class FormElement implements Element {

  factory FormElement() => _Elements.createFormElement();

  /** @domName HTMLFormElement.acceptCharset */
  String acceptCharset;

  /** @domName HTMLFormElement.action */
  String action;

  /** @domName HTMLFormElement.autocomplete */
  String autocomplete;

  /** @domName HTMLFormElement.encoding */
  String encoding;

  /** @domName HTMLFormElement.enctype */
  String enctype;

  /** @domName HTMLFormElement.length */
  int get length;

  /** @domName HTMLFormElement.method */
  String method;

  /** @domName HTMLFormElement.name */
  String name;

  /** @domName HTMLFormElement.noValidate */
  bool noValidate;

  /** @domName HTMLFormElement.target */
  String target;

  /** @domName HTMLFormElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLFormElement.reset */
  void reset();

  /** @domName HTMLFormElement.submit */
  void submit();
}

class _FormElementImpl extends _ElementImpl implements FormElement native "*HTMLFormElement" {

  String acceptCharset;

  String action;

  String autocomplete;

  String encoding;

  String enctype;

  final int length;

  String method;

  String name;

  bool noValidate;

  String target;

  bool checkValidity() native;

  void reset() native;

  void submit() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFrameElement
abstract class FrameElement implements Element {

  /** @domName HTMLFrameElement.contentWindow */
  Window get contentWindow;

  /** @domName HTMLFrameElement.frameBorder */
  String frameBorder;

  /** @domName HTMLFrameElement.height */
  int get height;

  /** @domName HTMLFrameElement.location */
  String location;

  /** @domName HTMLFrameElement.longDesc */
  String longDesc;

  /** @domName HTMLFrameElement.marginHeight */
  String marginHeight;

  /** @domName HTMLFrameElement.marginWidth */
  String marginWidth;

  /** @domName HTMLFrameElement.name */
  String name;

  /** @domName HTMLFrameElement.noResize */
  bool noResize;

  /** @domName HTMLFrameElement.scrolling */
  String scrolling;

  /** @domName HTMLFrameElement.src */
  String src;

  /** @domName HTMLFrameElement.width */
  int get width;
}

class _FrameElementImpl extends _ElementImpl implements FrameElement native "*HTMLFrameElement" {

  Window get contentWindow => _convertNativeToDart_Window(this._contentWindow);
  Window get _contentWindow => JS("Window", "#.contentWindow", this);

  String frameBorder;

  final int height;

  String location;

  String longDesc;

  String marginHeight;

  String marginWidth;

  String name;

  bool noResize;

  String scrolling;

  String src;

  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFrameSetElement
abstract class FrameSetElement implements Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FrameSetElementEvents get on;

  /** @domName HTMLFrameSetElement.cols */
  String cols;

  /** @domName HTMLFrameSetElement.rows */
  String rows;
}

abstract class FrameSetElementEvents implements ElementEvents {

  EventListenerList get beforeUnload;

  EventListenerList get blur;

  EventListenerList get error;

  EventListenerList get focus;

  EventListenerList get hashChange;

  EventListenerList get load;

  EventListenerList get message;

  EventListenerList get offline;

  EventListenerList get online;

  EventListenerList get popState;

  EventListenerList get resize;

  EventListenerList get storage;

  EventListenerList get unload;
}

class _FrameSetElementImpl extends _ElementImpl implements FrameSetElement native "*HTMLFrameSetElement" {

  _FrameSetElementEventsImpl get on =>
    new _FrameSetElementEventsImpl(this);

  String cols;

  String rows;
}

class _FrameSetElementEventsImpl extends _ElementEventsImpl implements FrameSetElementEvents {
  _FrameSetElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get beforeUnload => this['beforeunload'];

  EventListenerList get blur => this['blur'];

  EventListenerList get error => this['error'];

  EventListenerList get focus => this['focus'];

  EventListenerList get hashChange => this['hashchange'];

  EventListenerList get load => this['load'];

  EventListenerList get message => this['message'];

  EventListenerList get offline => this['offline'];

  EventListenerList get online => this['online'];

  EventListenerList get popState => this['popstate'];

  EventListenerList get resize => this['resize'];

  EventListenerList get storage => this['storage'];

  EventListenerList get unload => this['unload'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName GainNode
abstract class GainNode implements AudioNode {

  /** @domName GainNode.gain */
  AudioGain get gain;
}

class _GainNodeImpl extends _AudioNodeImpl implements GainNode native "*GainNode" {

  final _AudioGainImpl gain;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Gamepad
abstract class Gamepad {

  /** @domName Gamepad.axes */
  List<num> get axes;

  /** @domName Gamepad.buttons */
  List<num> get buttons;

  /** @domName Gamepad.id */
  String get id;

  /** @domName Gamepad.index */
  int get index;

  /** @domName Gamepad.timestamp */
  int get timestamp;
}

class _GamepadImpl implements Gamepad native "*Gamepad" {

  final List<num> axes;

  final List<num> buttons;

  final String id;

  final int index;

  final int timestamp;
}

class _GamepadListImpl implements List<Gamepad>, JavaScriptIndexingBehavior native "*GamepadList" {

  final int length;

  _GamepadImpl operator[](int index) => JS("_GamepadImpl", "#[#]", this, index);

  void operator[]=(int index, _GamepadImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Gamepad> mixins.
  // Gamepad is the element type.

  // From Iterable<Gamepad>:

  Iterator<Gamepad> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Gamepad>(this);
  }

  // From Collection<Gamepad>:

  void add(Gamepad value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Gamepad value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Gamepad> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Gamepad element) => _Collections.contains(this, element);

  void forEach(void f(Gamepad element)) => _Collections.forEach(this, f);

  Collection map(f(Gamepad element)) => _Collections.map(this, [], f);

  Collection<Gamepad> filter(bool f(Gamepad element)) =>
     _Collections.filter(this, <Gamepad>[], f);

  bool every(bool f(Gamepad element)) => _Collections.every(this, f);

  bool some(bool f(Gamepad element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Gamepad>:

  void sort([Comparator<Gamepad> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Gamepad element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Gamepad element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Gamepad get last => this[length - 1];

  Gamepad removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Gamepad> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Gamepad initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Gamepad> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Gamepad>[]);

  // -- end List<Gamepad> mixins.

  _GamepadImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Geolocation
abstract class Geolocation {

  /** @domName Geolocation.clearWatch */
  void clearWatch(int watchId);

  /** @domName Geolocation.getCurrentPosition */
  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback, Object options]);

  /** @domName Geolocation.watchPosition */
  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback, Object options]);
}

class _GeolocationImpl implements Geolocation native "*Geolocation" {

  void clearWatch(int watchId) native;

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback, Object options]) native;

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback, Object options]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Geoposition
abstract class Geoposition {

  /** @domName Geoposition.coords */
  Coordinates get coords;

  /** @domName Geoposition.timestamp */
  int get timestamp;
}

class _GeopositionImpl implements Geoposition native "*Geoposition" {

  final _CoordinatesImpl coords;

  final int timestamp;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHRElement
abstract class HRElement implements Element {

  factory HRElement() => _Elements.createHRElement();

  /** @domName HTMLHRElement.align */
  String align;

  /** @domName HTMLHRElement.noShade */
  bool noShade;

  /** @domName HTMLHRElement.size */
  String size;

  /** @domName HTMLHRElement.width */
  String width;
}

class _HRElementImpl extends _ElementImpl implements HRElement native "*HTMLHRElement" {

  String align;

  bool noShade;

  String size;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAllCollection
abstract class HTMLAllCollection implements List<Node> {

  /** @domName HTMLAllCollection.length */
  int get length;

  /** @domName HTMLAllCollection.item */
  Node item(int index);

  /** @domName HTMLAllCollection.namedItem */
  Node namedItem(String name);

  /** @domName HTMLAllCollection.tags */
  List<Node> tags(String name);
}

class _HTMLAllCollectionImpl implements HTMLAllCollection, JavaScriptIndexingBehavior native "*HTMLAllCollection" {

  final int length;

  _NodeImpl operator[](int index) => JS("_NodeImpl", "#[#]", this, index);

  void operator[]=(int index, _NodeImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Node element) => _Collections.contains(this, element);

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     _Collections.filter(this, <Node>[], f);

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Node>:

  void sort([Comparator<Node> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Node get last => this[length - 1];

  Node removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  _NodeImpl item(int index) native;

  _NodeImpl namedItem(String name) native;

  List<Node> tags(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLCollection
abstract class HTMLCollection implements List<Node> {

  /** @domName HTMLCollection.length */
  int get length;

  /** @domName HTMLCollection.item */
  Node item(int index);

  /** @domName HTMLCollection.namedItem */
  Node namedItem(String name);
}

class _HTMLCollectionImpl implements HTMLCollection, JavaScriptIndexingBehavior native "*HTMLCollection" {

  final int length;

  _NodeImpl operator[](int index) => JS("_NodeImpl", "#[#]", this, index);

  void operator[]=(int index, _NodeImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Node element) => _Collections.contains(this, element);

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     _Collections.filter(this, <Node>[], f);

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Node>:

  void sort([Comparator<Node> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Node get last => this[length - 1];

  Node removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  _NodeImpl item(int index) native;

  _NodeImpl namedItem(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptionsCollection
abstract class HTMLOptionsCollection implements HTMLCollection {

  /** @domName HTMLOptionsCollection.length */
  int length;

  /** @domName HTMLOptionsCollection.selectedIndex */
  int selectedIndex;

  /** @domName HTMLOptionsCollection.remove */
  void remove(int index);
}

class _HTMLOptionsCollectionImpl extends _HTMLCollectionImpl implements HTMLOptionsCollection native "*HTMLOptionsCollection" {

  // Shadowing definition.
  int get length => JS("int", "#.length", this);

  void set length(int value) {
    JS("void", "#.length = #", this, value);
  }

  int selectedIndex;

  void remove(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HashChangeEvent
abstract class HashChangeEvent implements Event {

  /** @domName HashChangeEvent.newURL */
  String get newURL;

  /** @domName HashChangeEvent.oldURL */
  String get oldURL;

  /** @domName HashChangeEvent.initHashChangeEvent */
  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL);
}

class _HashChangeEventImpl extends _EventImpl implements HashChangeEvent native "*HashChangeEvent" {

  final String newURL;

  final String oldURL;

  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHeadElement
abstract class HeadElement implements Element {

  factory HeadElement() => _Elements.createHeadElement();

  /** @domName HTMLHeadElement.profile */
  String profile;
}

class _HeadElementImpl extends _ElementImpl implements HeadElement native "*HTMLHeadElement" {

  String profile;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHeadingElement
abstract class HeadingElement implements Element {

  factory HeadingElement.h1() => _Elements.createHeadingElement_h1();

  factory HeadingElement.h2() => _Elements.createHeadingElement_h2();

  factory HeadingElement.h3() => _Elements.createHeadingElement_h3();

  factory HeadingElement.h4() => _Elements.createHeadingElement_h4();

  factory HeadingElement.h5() => _Elements.createHeadingElement_h5();

  factory HeadingElement.h6() => _Elements.createHeadingElement_h6();

  /** @domName HTMLHeadingElement.align */
  String align;
}

class _HeadingElementImpl extends _ElementImpl implements HeadingElement native "*HTMLHeadingElement" {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHtmlElement
abstract class HtmlElement implements Element {

  factory HtmlElement() => _Elements.createHtmlElement();
}

class _HtmlElementImpl extends _ElementImpl implements HtmlElement native "*HTMLHtmlElement" {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName XMLHttpRequest
abstract class HttpRequest implements EventTarget {
  factory HttpRequest.get(String url, onSuccess(HttpRequest request)) =>
      _HttpRequestFactoryProvider.createHttpRequest_get(url, onSuccess);

  factory HttpRequest.getWithCredentials(String url, onSuccess(HttpRequest request)) =>
      _HttpRequestFactoryProvider.createHttpRequest_getWithCredentials(url, onSuccess);

  factory HttpRequest() => _HttpRequestFactoryProvider.createHttpRequest();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  HttpRequestEvents get on;

  static const int DONE = 4;

  static const int HEADERS_RECEIVED = 2;

  static const int LOADING = 3;

  static const int OPENED = 1;

  static const int UNSENT = 0;

  /** @domName XMLHttpRequest.readyState */
  int get readyState;

  /** @domName XMLHttpRequest.response */
  Object get response;

  /** @domName XMLHttpRequest.responseText */
  String get responseText;

  /** @domName XMLHttpRequest.responseType */
  String responseType;

  /** @domName XMLHttpRequest.responseXML */
  Document get responseXML;

  /** @domName XMLHttpRequest.status */
  int get status;

  /** @domName XMLHttpRequest.statusText */
  String get statusText;

  /** @domName XMLHttpRequest.upload */
  HttpRequestUpload get upload;

  /** @domName XMLHttpRequest.withCredentials */
  bool withCredentials;

  /** @domName XMLHttpRequest.abort */
  void abort();

  /** @domName XMLHttpRequest.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequest.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName XMLHttpRequest.getAllResponseHeaders */
  String getAllResponseHeaders();

  /** @domName XMLHttpRequest.getResponseHeader */
  String getResponseHeader(String header);

  /** @domName XMLHttpRequest.open */
  void open(String method, String url, [bool async, String user, String password]);

  /** @domName XMLHttpRequest.overrideMimeType */
  void overrideMimeType(String override);

  /** @domName XMLHttpRequest.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequest.send */
  void send([data]);

  /** @domName XMLHttpRequest.setRequestHeader */
  void setRequestHeader(String header, String value);
}

abstract class HttpRequestEvents implements Events {

  EventListenerList get abort;

  EventListenerList get error;

  EventListenerList get load;

  EventListenerList get loadEnd;

  EventListenerList get loadStart;

  EventListenerList get progress;

  EventListenerList get readyStateChange;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestException
abstract class HttpRequestException {

  static const int ABORT_ERR = 102;

  static const int NETWORK_ERR = 101;

  /** @domName XMLHttpRequestException.code */
  int get code;

  /** @domName XMLHttpRequestException.message */
  String get message;

  /** @domName XMLHttpRequestException.name */
  String get name;

  /** @domName XMLHttpRequestException.toString */
  String toString();
}

class _HttpRequestExceptionImpl implements HttpRequestException native "*XMLHttpRequestException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}

class _HttpRequestImpl extends _EventTargetImpl implements HttpRequest native "*XMLHttpRequest" {

  _HttpRequestEventsImpl get on =>
    new _HttpRequestEventsImpl(this);

  final int readyState;

  final Object response;

  final String responseText;

  String responseType;

  final _DocumentImpl responseXML;

  final int status;

  final String statusText;

  final _HttpRequestUploadImpl upload;

  bool withCredentials;

  void abort() native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  String getAllResponseHeaders() native;

  String getResponseHeader(String header) native;

  void open(String method, String url, [bool async, String user, String password]) native;

  void overrideMimeType(String override) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void send([data]) native;

  void setRequestHeader(String header, String value) native;
}

class _HttpRequestEventsImpl extends _EventsImpl implements HttpRequestEvents {
  _HttpRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get error => this['error'];

  EventListenerList get load => this['load'];

  EventListenerList get loadEnd => this['loadend'];

  EventListenerList get loadStart => this['loadstart'];

  EventListenerList get progress => this['progress'];

  EventListenerList get readyStateChange => this['readystatechange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestProgressEvent
abstract class HttpRequestProgressEvent implements ProgressEvent {

  /** @domName XMLHttpRequestProgressEvent.position */
  int get position;

  /** @domName XMLHttpRequestProgressEvent.totalSize */
  int get totalSize;
}

class _HttpRequestProgressEventImpl extends _ProgressEventImpl implements HttpRequestProgressEvent native "*XMLHttpRequestProgressEvent" {

  final int position;

  final int totalSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestUpload
abstract class HttpRequestUpload implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  HttpRequestUploadEvents get on;

  /** @domName XMLHttpRequestUpload.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequestUpload.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName XMLHttpRequestUpload.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class HttpRequestUploadEvents implements Events {

  EventListenerList get abort;

  EventListenerList get error;

  EventListenerList get load;

  EventListenerList get loadEnd;

  EventListenerList get loadStart;

  EventListenerList get progress;
}

class _HttpRequestUploadImpl extends _EventTargetImpl implements HttpRequestUpload native "*XMLHttpRequestUpload" {

  _HttpRequestUploadEventsImpl get on =>
    new _HttpRequestUploadEventsImpl(this);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _HttpRequestUploadEventsImpl extends _EventsImpl implements HttpRequestUploadEvents {
  _HttpRequestUploadEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get error => this['error'];

  EventListenerList get load => this['load'];

  EventListenerList get loadEnd => this['loadend'];

  EventListenerList get loadStart => this['loadstart'];

  EventListenerList get progress => this['progress'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBAny
abstract class IDBAny {
}

class _IDBAnyImpl implements IDBAny native "*IDBAny" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBCursor
abstract class IDBCursor {

  static const int NEXT = 0;

  static const int NEXT_NO_DUPLICATE = 1;

  static const int PREV = 2;

  static const int PREV_NO_DUPLICATE = 3;

  /** @domName IDBCursor.direction */
  String get direction;

  /** @domName IDBCursor.key */
  Object get key;

  /** @domName IDBCursor.primaryKey */
  Object get primaryKey;

  /** @domName IDBCursor.source */
  dynamic get source;

  /** @domName IDBCursor.advance */
  void advance(int count);

  /** @domName IDBCursor.continueFunction */
  void continueFunction([/*IDBKey*/ key]);

  /** @domName IDBCursor.delete */
  IDBRequest delete();

  /** @domName IDBCursor.update */
  IDBRequest update(Object value);
}

class _IDBCursorImpl implements IDBCursor native "*IDBCursor" {

  final String direction;

  final Object key;

  final Object primaryKey;

  final dynamic source;

  void advance(int count) native;

  void continueFunction([key]) {
    if (?key) {
      var key_1 = _convertDartToNative_IDBKey(key);
      _continueFunction_1(key_1);
      return;
    }
    _continueFunction_2();
    return;
  }
  void _continueFunction_1(key) native "continue";
  void _continueFunction_2() native "continue";

  _IDBRequestImpl delete() native;

  _IDBRequestImpl update(/*any*/ value) {
    var value_1 = _convertDartToNative_SerializedScriptValue(value);
    return _update_1(value_1);
  }
  _IDBRequestImpl _update_1(value) native "update";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBCursorWithValue
abstract class IDBCursorWithValue implements IDBCursor {

  /** @domName IDBCursorWithValue.value */
  Object get value;
}

class _IDBCursorWithValueImpl extends _IDBCursorImpl implements IDBCursorWithValue native "*IDBCursorWithValue" {

  final Object value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBDatabase
abstract class IDBDatabase implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBDatabaseEvents get on;

  /** @domName IDBDatabase.name */
  String get name;

  /** @domName IDBDatabase.objectStoreNames */
  List<String> get objectStoreNames;

  /** @domName IDBDatabase.version */
  dynamic get version;

  /** @domName IDBDatabase.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBDatabase.close */
  void close();

  /** @domName IDBDatabase.createObjectStore */
  IDBObjectStore createObjectStore(String name, [Map options]);

  /** @domName IDBDatabase.deleteObjectStore */
  void deleteObjectStore(String name);

  /** @domName IDBDatabase.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBDatabase.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBDatabase.setVersion */
  IDBVersionChangeRequest setVersion(String version);

  /** @domName IDBDatabase.transaction */
  IDBTransaction transaction(storeName_OR_storeNames, String mode);
}

abstract class IDBDatabaseEvents implements Events {

  EventListenerList get abort;

  EventListenerList get error;

  EventListenerList get versionChange;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBDatabaseException
abstract class IDBDatabaseException {

  static const int ABORT_ERR = 20;

  static const int CONSTRAINT_ERR = 4;

  static const int DATA_ERR = 5;

  static const int NON_TRANSIENT_ERR = 2;

  static const int NOT_ALLOWED_ERR = 6;

  static const int NOT_FOUND_ERR = 8;

  static const int NO_ERR = 0;

  static const int QUOTA_ERR = 22;

  static const int READ_ONLY_ERR = 9;

  static const int TIMEOUT_ERR = 23;

  static const int TRANSACTION_INACTIVE_ERR = 7;

  static const int UNKNOWN_ERR = 1;

  static const int VER_ERR = 12;

  /** @domName IDBDatabaseException.code */
  int get code;

  /** @domName IDBDatabaseException.message */
  String get message;

  /** @domName IDBDatabaseException.name */
  String get name;

  /** @domName IDBDatabaseException.toString */
  String toString();
}

class _IDBDatabaseExceptionImpl implements IDBDatabaseException native "*IDBDatabaseException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _IDBDatabaseImpl extends _EventTargetImpl implements IDBDatabase native "*IDBDatabase" {

  _IDBTransactionImpl transaction(storeName_OR_storeNames, String mode) {
    if (mode != 'readonly' && mode != 'readwrite') {
      throw new ArgumentError(mode);
    }

    // TODO(sra): Ensure storeName_OR_storeNames is a string or List<String>,
    // and copy to JavaScript array if necessary.

    if (_transaction_fn != null) {
      return _transaction_fn(this, storeName_OR_storeNames, mode);
    }

    // Try and create a transaction with a string mode.  Browsers that expect a
    // numeric mode tend to convert the string into a number.  This fails
    // silently, resulting in zero ('readonly').
    var txn = _transaction(storeName_OR_storeNames, mode);
    if (_hasNumericMode(txn)) {
      _transaction_fn = _transaction_numeric_mode;
      txn = _transaction_fn(this, storeName_OR_storeNames, mode);
    } else {
      _transaction_fn = _transaction_string_mode;
    }
    return txn;
  }

  static _IDBTransactionImpl _transaction_string_mode(_IDBDatabaseImpl db, stores, mode) {
    return db._transaction(stores, mode);
  }

  static _IDBTransactionImpl _transaction_numeric_mode(_IDBDatabaseImpl db, stores, mode) {
    int intMode;
    if (mode == 'readonly') intMode = IDBTransaction.READ_ONLY;
    if (mode == 'readwrite') intMode = IDBTransaction.READ_WRITE;
    return db._transaction(stores, intMode);
  }

  _IDBTransactionImpl _transaction(stores, mode) native 'transaction';

  static bool _hasNumericMode(txn) =>
      JS('bool', 'typeof(#.mode) === "number"', txn);


  _IDBDatabaseEventsImpl get on =>
    new _IDBDatabaseEventsImpl(this);

  final String name;

  final _DOMStringListImpl objectStoreNames;

  final dynamic version;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void close() native;

  _IDBObjectStoreImpl createObjectStore(String name, [options]) {
    if (?options) {
      var options_1 = _convertDartToNative_Dictionary(options);
      return _createObjectStore_1(name, options_1);
    }
    return _createObjectStore_2(name);
  }
  _IDBObjectStoreImpl _createObjectStore_1(name, options) native "createObjectStore";
  _IDBObjectStoreImpl _createObjectStore_2(name) native "createObjectStore";

  void deleteObjectStore(String name) native;

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  _IDBVersionChangeRequestImpl setVersion(String version) native;
}

// TODO(sra): This should be a static member of _IDBTransactionImpl but dart2js
// can't handle that.  Move it back after dart2js is completely done.
var _transaction_fn;  // Assigned one of the static methods.

class _IDBDatabaseEventsImpl extends _EventsImpl implements IDBDatabaseEvents {
  _IDBDatabaseEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get error => this['error'];

  EventListenerList get versionChange => this['versionchange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBFactory
abstract class IDBFactory {

  /** @domName IDBFactory.cmp */
  int cmp(/*IDBKey*/ first, /*IDBKey*/ second);

  /** @domName IDBFactory.deleteDatabase */
  IDBVersionChangeRequest deleteDatabase(String name);

  /** @domName IDBFactory.open */
  IDBOpenDBRequest open(String name, [int version]);

  /** @domName IDBFactory.webkitGetDatabaseNames */
  IDBRequest webkitGetDatabaseNames();
}

class _IDBFactoryImpl implements IDBFactory native "*IDBFactory" {

  int cmp(/*IDBKey*/ first, /*IDBKey*/ second) {
    var first_1 = _convertDartToNative_IDBKey(first);
    var second_2 = _convertDartToNative_IDBKey(second);
    return _cmp_1(first_1, second_2);
  }
  int _cmp_1(first, second) native "cmp";

  _IDBVersionChangeRequestImpl deleteDatabase(String name) native;

  _IDBOpenDBRequestImpl open(String name, [int version]) native;

  _IDBRequestImpl webkitGetDatabaseNames() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBIndex
abstract class IDBIndex {

  /** @domName IDBIndex.keyPath */
  dynamic get keyPath;

  /** @domName IDBIndex.multiEntry */
  bool get multiEntry;

  /** @domName IDBIndex.name */
  String get name;

  /** @domName IDBIndex.objectStore */
  IDBObjectStore get objectStore;

  /** @domName IDBIndex.unique */
  bool get unique;

  /** @domName IDBIndex.count */
  IDBRequest count([key_OR_range]);

  /** @domName IDBIndex.get */
  IDBRequest get(key);

  /** @domName IDBIndex.getKey */
  IDBRequest getKey(key);

  /** @domName IDBIndex.openCursor */
  IDBRequest openCursor([key_OR_range, String direction]);

  /** @domName IDBIndex.openKeyCursor */
  IDBRequest openKeyCursor([key_OR_range, String direction]);
}

class _IDBIndexImpl implements IDBIndex native "*IDBIndex" {

  final dynamic keyPath;

  final bool multiEntry;

  final String name;

  final _IDBObjectStoreImpl objectStore;

  final bool unique;

  _IDBRequestImpl count([key_OR_range]) {
    if (!?key_OR_range) {
      return _count_1();
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null)) {
      return _count_2(key_OR_range);
    }
    if (?key_OR_range) {
      var key_1 = _convertDartToNative_IDBKey(key_OR_range);
      return _count_3(key_1);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _count_1() native "count";
  _IDBRequestImpl _count_2(_IDBKeyRangeImpl range) native "count";
  _IDBRequestImpl _count_3(key) native "count";

  _IDBRequestImpl get(key) {
    if ((key is IDBKeyRange || key == null)) {
      return _get_1(key);
    }
    if (?key) {
      var key_1 = _convertDartToNative_IDBKey(key);
      return _get_2(key_1);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _get_1(_IDBKeyRangeImpl key) native "get";
  _IDBRequestImpl _get_2(key) native "get";

  _IDBRequestImpl getKey(key) {
    if ((key is IDBKeyRange || key == null)) {
      return _getKey_1(key);
    }
    if (?key) {
      var key_1 = _convertDartToNative_IDBKey(key);
      return _getKey_2(key_1);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _getKey_1(_IDBKeyRangeImpl key) native "getKey";
  _IDBRequestImpl _getKey_2(key) native "getKey";

  _IDBRequestImpl openCursor([key_OR_range, direction]) {
    if (!?key_OR_range &&
        !?direction) {
      return _openCursor_1();
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null) &&
        !?direction) {
      return _openCursor_2(key_OR_range);
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null) &&
        (direction is String || direction == null)) {
      return _openCursor_3(key_OR_range, direction);
    }
    if (?key_OR_range &&
        !?direction) {
      var key_1 = _convertDartToNative_IDBKey(key_OR_range);
      return _openCursor_4(key_1);
    }
    if (?key_OR_range &&
        (direction is String || direction == null)) {
      var key_2 = _convertDartToNative_IDBKey(key_OR_range);
      return _openCursor_5(key_2, direction);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _openCursor_1() native "openCursor";
  _IDBRequestImpl _openCursor_2(_IDBKeyRangeImpl range) native "openCursor";
  _IDBRequestImpl _openCursor_3(_IDBKeyRangeImpl range, String direction) native "openCursor";
  _IDBRequestImpl _openCursor_4(key) native "openCursor";
  _IDBRequestImpl _openCursor_5(key, String direction) native "openCursor";

  _IDBRequestImpl openKeyCursor([key_OR_range, direction]) {
    if (!?key_OR_range &&
        !?direction) {
      return _openKeyCursor_1();
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null) &&
        !?direction) {
      return _openKeyCursor_2(key_OR_range);
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null) &&
        (direction is String || direction == null)) {
      return _openKeyCursor_3(key_OR_range, direction);
    }
    if (?key_OR_range &&
        !?direction) {
      var key_1 = _convertDartToNative_IDBKey(key_OR_range);
      return _openKeyCursor_4(key_1);
    }
    if (?key_OR_range &&
        (direction is String || direction == null)) {
      var key_2 = _convertDartToNative_IDBKey(key_OR_range);
      return _openKeyCursor_5(key_2, direction);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _openKeyCursor_1() native "openKeyCursor";
  _IDBRequestImpl _openKeyCursor_2(_IDBKeyRangeImpl range) native "openKeyCursor";
  _IDBRequestImpl _openKeyCursor_3(_IDBKeyRangeImpl range, String direction) native "openKeyCursor";
  _IDBRequestImpl _openKeyCursor_4(key) native "openKeyCursor";
  _IDBRequestImpl _openKeyCursor_5(key, String direction) native "openKeyCursor";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBKey
abstract class IDBKey {
}

class _IDBKeyImpl implements IDBKey native "*IDBKey" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName IDBKeyRange
abstract class IDBKeyRange {

  /**
   * @domName IDBKeyRange.only
   */
  factory IDBKeyRange.only(/*IDBKey*/ value) =>
      _IDBKeyRangeFactoryProvider.createIDBKeyRange_only(value);

  /**
   * @domName IDBKeyRange.lowerBound
   */
  factory IDBKeyRange.lowerBound(/*IDBKey*/ bound, [bool open = false]) =>
      _IDBKeyRangeFactoryProvider.createIDBKeyRange_lowerBound(bound, open);

  /**
   * @domName IDBKeyRange.upperBound
   */
  factory IDBKeyRange.upperBound(/*IDBKey*/ bound, [bool open = false]) =>
      _IDBKeyRangeFactoryProvider.createIDBKeyRange_upperBound(bound, open);

  /**
   * @domName IDBKeyRange.bound
   */
  factory IDBKeyRange.bound(/*IDBKey*/ lower, /*IDBKey*/ upper,
                            [bool lowerOpen = false, bool upperOpen = false]) =>
      _IDBKeyRangeFactoryProvider.createIDBKeyRange_bound(
          lower, upper, lowerOpen, upperOpen);


  /** @domName IDBKeyRange.lower */
  dynamic get lower;

  /** @domName IDBKeyRange.lowerOpen */
  bool get lowerOpen;

  /** @domName IDBKeyRange.upper */
  dynamic get upper;

  /** @domName IDBKeyRange.upperOpen */
  bool get upperOpen;

  /** @domName IDBKeyRange.bound_ */
  static final bound_ = _IDBKeyRangeImpl.bound_;

  /** @domName IDBKeyRange.lowerBound_ */
  static final lowerBound_ = _IDBKeyRangeImpl.lowerBound_;

  /** @domName IDBKeyRange.only_ */
  static final only_ = _IDBKeyRangeImpl.only_;

  /** @domName IDBKeyRange.upperBound_ */
  static final upperBound_ = _IDBKeyRangeImpl.upperBound_;
}

class _IDBKeyRangeImpl implements IDBKeyRange native "*IDBKeyRange" {

  dynamic get lower => _convertNativeToDart_IDBKey(this._lower);
  dynamic get _lower => JS("dynamic", "#.lower", this);

  final bool lowerOpen;

  dynamic get upper => _convertNativeToDart_IDBKey(this._upper);
  dynamic get _upper => JS("dynamic", "#.upper", this);

  final bool upperOpen;

  static _IDBKeyRangeImpl bound_(/*IDBKey*/ lower, /*IDBKey*/ upper, [lowerOpen, upperOpen]) {
    if (?upperOpen) {
      var lower_1 = _convertDartToNative_IDBKey(lower);
      var upper_2 = _convertDartToNative_IDBKey(upper);
      return _bound__1(lower_1, upper_2, lowerOpen, upperOpen);
    }
    if (?lowerOpen) {
      var lower_3 = _convertDartToNative_IDBKey(lower);
      var upper_4 = _convertDartToNative_IDBKey(upper);
      return _bound__2(lower_3, upper_4, lowerOpen);
    }
    var lower_5 = _convertDartToNative_IDBKey(lower);
    var upper_6 = _convertDartToNative_IDBKey(upper);
    return _bound__3(lower_5, upper_6);
  }
  _IDBKeyRangeImpl _bound__1(lower, upper, bool lowerOpen, bool upperOpen) native "bound";
  _IDBKeyRangeImpl _bound__2(lower, upper, bool lowerOpen) native "bound";
  _IDBKeyRangeImpl _bound__3(lower, upper) native "bound";

  static _IDBKeyRangeImpl lowerBound_(/*IDBKey*/ bound, [open]) {
    if (?open) {
      var bound_1 = _convertDartToNative_IDBKey(bound);
      return _lowerBound__1(bound_1, open);
    }
    var bound_2 = _convertDartToNative_IDBKey(bound);
    return _lowerBound__2(bound_2);
  }
  _IDBKeyRangeImpl _lowerBound__1(bound, bool open) native "lowerBound";
  _IDBKeyRangeImpl _lowerBound__2(bound) native "lowerBound";

  static _IDBKeyRangeImpl only_(/*IDBKey*/ value) {
    var value_1 = _convertDartToNative_IDBKey(value);
    return _only__1(value_1);
  }
  _IDBKeyRangeImpl _only__1(value) native "only";

  static _IDBKeyRangeImpl upperBound_(/*IDBKey*/ bound, [open]) {
    if (?open) {
      var bound_1 = _convertDartToNative_IDBKey(bound);
      return _upperBound__1(bound_1, open);
    }
    var bound_2 = _convertDartToNative_IDBKey(bound);
    return _upperBound__2(bound_2);
  }
  _IDBKeyRangeImpl _upperBound__1(bound, bool open) native "upperBound";
  _IDBKeyRangeImpl _upperBound__2(bound) native "upperBound";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBObjectStore
abstract class IDBObjectStore {

  /** @domName IDBObjectStore.autoIncrement */
  bool get autoIncrement;

  /** @domName IDBObjectStore.indexNames */
  List<String> get indexNames;

  /** @domName IDBObjectStore.keyPath */
  dynamic get keyPath;

  /** @domName IDBObjectStore.name */
  String get name;

  /** @domName IDBObjectStore.transaction */
  IDBTransaction get transaction;

  /** @domName IDBObjectStore.add */
  IDBRequest add(Object value, [/*IDBKey*/ key]);

  /** @domName IDBObjectStore.clear */
  IDBRequest clear();

  /** @domName IDBObjectStore.count */
  IDBRequest count([key_OR_range]);

  /** @domName IDBObjectStore.createIndex */
  IDBIndex createIndex(String name, keyPath, [Map options]);

  /** @domName IDBObjectStore.delete */
  IDBRequest delete(key_OR_keyRange);

  /** @domName IDBObjectStore.deleteIndex */
  void deleteIndex(String name);

  /** @domName IDBObjectStore.getObject */
  IDBRequest getObject(key);

  /** @domName IDBObjectStore.index */
  IDBIndex index(String name);

  /** @domName IDBObjectStore.openCursor */
  IDBRequest openCursor([key_OR_range, String direction]);

  /** @domName IDBObjectStore.put */
  IDBRequest put(Object value, [/*IDBKey*/ key]);
}

class _IDBObjectStoreImpl implements IDBObjectStore native "*IDBObjectStore" {

  final bool autoIncrement;

  final _DOMStringListImpl indexNames;

  final dynamic keyPath;

  final String name;

  final _IDBTransactionImpl transaction;

  _IDBRequestImpl add(/*any*/ value, [key]) {
    if (?key) {
      var value_1 = _convertDartToNative_SerializedScriptValue(value);
      var key_2 = _convertDartToNative_IDBKey(key);
      return _add_1(value_1, key_2);
    }
    var value_3 = _convertDartToNative_SerializedScriptValue(value);
    return _add_2(value_3);
  }
  _IDBRequestImpl _add_1(value, key) native "add";
  _IDBRequestImpl _add_2(value) native "add";

  _IDBRequestImpl clear() native;

  _IDBRequestImpl count([key_OR_range]) {
    if (!?key_OR_range) {
      return _count_1();
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null)) {
      return _count_2(key_OR_range);
    }
    if (?key_OR_range) {
      var key_1 = _convertDartToNative_IDBKey(key_OR_range);
      return _count_3(key_1);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _count_1() native "count";
  _IDBRequestImpl _count_2(_IDBKeyRangeImpl range) native "count";
  _IDBRequestImpl _count_3(key) native "count";

  _IDBIndexImpl createIndex(String name, keyPath, [options]) {
    if ((keyPath is List<String> || keyPath == null) &&
        !?options) {
      List keyPath_1 = _convertDartToNative_StringArray(keyPath);
      return _createIndex_1(name, keyPath_1);
    }
    if ((keyPath is List<String> || keyPath == null) &&
        (options is Map || options == null)) {
      List keyPath_2 = _convertDartToNative_StringArray(keyPath);
      var options_3 = _convertDartToNative_Dictionary(options);
      return _createIndex_2(name, keyPath_2, options_3);
    }
    if ((keyPath is String || keyPath == null) &&
        !?options) {
      return _createIndex_3(name, keyPath);
    }
    if ((keyPath is String || keyPath == null) &&
        (options is Map || options == null)) {
      var options_4 = _convertDartToNative_Dictionary(options);
      return _createIndex_4(name, keyPath, options_4);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBIndexImpl _createIndex_1(name, List keyPath) native "createIndex";
  _IDBIndexImpl _createIndex_2(name, List keyPath, options) native "createIndex";
  _IDBIndexImpl _createIndex_3(name, String keyPath) native "createIndex";
  _IDBIndexImpl _createIndex_4(name, String keyPath, options) native "createIndex";

  _IDBRequestImpl delete(key_OR_keyRange) {
    if ((key_OR_keyRange is IDBKeyRange || key_OR_keyRange == null)) {
      return _delete_1(key_OR_keyRange);
    }
    if (?key_OR_keyRange) {
      var key_1 = _convertDartToNative_IDBKey(key_OR_keyRange);
      return _delete_2(key_1);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _delete_1(_IDBKeyRangeImpl keyRange) native "delete";
  _IDBRequestImpl _delete_2(key) native "delete";

  void deleteIndex(String name) native;

  _IDBRequestImpl getObject(key) {
    if ((key is IDBKeyRange || key == null)) {
      return _getObject_1(key);
    }
    if (?key) {
      var key_1 = _convertDartToNative_IDBKey(key);
      return _getObject_2(key_1);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _getObject_1(_IDBKeyRangeImpl key) native "get";
  _IDBRequestImpl _getObject_2(key) native "get";

  _IDBIndexImpl index(String name) native;

  _IDBRequestImpl openCursor([key_OR_range, direction]) {
    if (!?key_OR_range &&
        !?direction) {
      return _openCursor_1();
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null) &&
        !?direction) {
      return _openCursor_2(key_OR_range);
    }
    if ((key_OR_range is IDBKeyRange || key_OR_range == null) &&
        (direction is String || direction == null)) {
      return _openCursor_3(key_OR_range, direction);
    }
    if (?key_OR_range &&
        !?direction) {
      var key_1 = _convertDartToNative_IDBKey(key_OR_range);
      return _openCursor_4(key_1);
    }
    if (?key_OR_range &&
        (direction is String || direction == null)) {
      var key_2 = _convertDartToNative_IDBKey(key_OR_range);
      return _openCursor_5(key_2, direction);
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  _IDBRequestImpl _openCursor_1() native "openCursor";
  _IDBRequestImpl _openCursor_2(_IDBKeyRangeImpl range) native "openCursor";
  _IDBRequestImpl _openCursor_3(_IDBKeyRangeImpl range, String direction) native "openCursor";
  _IDBRequestImpl _openCursor_4(key) native "openCursor";
  _IDBRequestImpl _openCursor_5(key, String direction) native "openCursor";

  _IDBRequestImpl put(/*any*/ value, [key]) {
    if (?key) {
      var value_1 = _convertDartToNative_SerializedScriptValue(value);
      var key_2 = _convertDartToNative_IDBKey(key);
      return _put_1(value_1, key_2);
    }
    var value_3 = _convertDartToNative_SerializedScriptValue(value);
    return _put_2(value_3);
  }
  _IDBRequestImpl _put_1(value, key) native "put";
  _IDBRequestImpl _put_2(value) native "put";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBOpenDBRequest
abstract class IDBOpenDBRequest implements IDBRequest, EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBOpenDBRequestEvents get on;
}

abstract class IDBOpenDBRequestEvents implements IDBRequestEvents {

  EventListenerList get blocked;

  EventListenerList get upgradeNeeded;
}

class _IDBOpenDBRequestImpl extends _IDBRequestImpl implements IDBOpenDBRequest native "*IDBOpenDBRequest" {

  _IDBOpenDBRequestEventsImpl get on =>
    new _IDBOpenDBRequestEventsImpl(this);
}

class _IDBOpenDBRequestEventsImpl extends _IDBRequestEventsImpl implements IDBOpenDBRequestEvents {
  _IDBOpenDBRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get blocked => this['blocked'];

  EventListenerList get upgradeNeeded => this['upgradeneeded'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBRequest
abstract class IDBRequest implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBRequestEvents get on;

  /** @domName IDBRequest.error */
  DOMError get error;

  /** @domName IDBRequest.errorCode */
  int get errorCode;

  /** @domName IDBRequest.readyState */
  String get readyState;

  /** @domName IDBRequest.result */
  dynamic get result;

  /** @domName IDBRequest.source */
  dynamic get source;

  /** @domName IDBRequest.transaction */
  IDBTransaction get transaction;

  /** @domName IDBRequest.webkitErrorMessage */
  String get webkitErrorMessage;

  /** @domName IDBRequest.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBRequest.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBRequest.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class IDBRequestEvents implements Events {

  EventListenerList get error;

  EventListenerList get success;
}

class _IDBRequestImpl extends _EventTargetImpl implements IDBRequest native "*IDBRequest" {

  _IDBRequestEventsImpl get on =>
    new _IDBRequestEventsImpl(this);

  final _DOMErrorImpl error;

  final int errorCode;

  final String readyState;

  dynamic get result => _convertNativeToDart_IDBAny(this._result);
  dynamic get _result => JS("dynamic", "#.result", this);

  final dynamic source;

  final _IDBTransactionImpl transaction;

  final String webkitErrorMessage;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _IDBRequestEventsImpl extends _EventsImpl implements IDBRequestEvents {
  _IDBRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error => this['error'];

  EventListenerList get success => this['success'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBTransaction
abstract class IDBTransaction implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBTransactionEvents get on;

  static const int READ_ONLY = 0;

  static const int READ_WRITE = 1;

  static const int VERSION_CHANGE = 2;

  /** @domName IDBTransaction.db */
  IDBDatabase get db;

  /** @domName IDBTransaction.error */
  DOMError get error;

  /** @domName IDBTransaction.mode */
  String get mode;

  /** @domName IDBTransaction.abort */
  void abort();

  /** @domName IDBTransaction.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBTransaction.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBTransaction.objectStore */
  IDBObjectStore objectStore(String name);

  /** @domName IDBTransaction.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class IDBTransactionEvents implements Events {

  EventListenerList get abort;

  EventListenerList get complete;

  EventListenerList get error;
}

class _IDBTransactionImpl extends _EventTargetImpl implements IDBTransaction native "*IDBTransaction" {

  _IDBTransactionEventsImpl get on =>
    new _IDBTransactionEventsImpl(this);

  final _IDBDatabaseImpl db;

  final _DOMErrorImpl error;

  final String mode;

  void abort() native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  _IDBObjectStoreImpl objectStore(String name) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _IDBTransactionEventsImpl extends _EventsImpl implements IDBTransactionEvents {
  _IDBTransactionEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get complete => this['complete'];

  EventListenerList get error => this['error'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBVersionChangeEvent
abstract class IDBUpgradeNeededEvent implements Event {

  /** @domName IDBVersionChangeEvent.newVersion */
  int get newVersion;

  /** @domName IDBVersionChangeEvent.oldVersion */
  int get oldVersion;
}

class _IDBUpgradeNeededEventImpl extends _EventImpl implements IDBUpgradeNeededEvent native "*IDBVersionChangeEvent" {

  final int newVersion;

  final int oldVersion;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBVersionChangeEvent
abstract class IDBVersionChangeEvent implements Event {

  /** @domName IDBVersionChangeEvent.version */
  String get version;
}

class _IDBVersionChangeEventImpl extends _EventImpl implements IDBVersionChangeEvent native "*IDBVersionChangeEvent" {

  final String version;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBVersionChangeRequest
abstract class IDBVersionChangeRequest implements IDBRequest, EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBVersionChangeRequestEvents get on;
}

abstract class IDBVersionChangeRequestEvents implements IDBRequestEvents {

  EventListenerList get blocked;
}

class _IDBVersionChangeRequestImpl extends _IDBRequestImpl implements IDBVersionChangeRequest native "*IDBVersionChangeRequest" {

  _IDBVersionChangeRequestEventsImpl get on =>
    new _IDBVersionChangeRequestEventsImpl(this);
}

class _IDBVersionChangeRequestEventsImpl extends _IDBRequestEventsImpl implements IDBVersionChangeRequestEvents {
  _IDBVersionChangeRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get blocked => this['blocked'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLIFrameElement
abstract class IFrameElement implements Element {

  factory IFrameElement() => _Elements.createIFrameElement();

  /** @domName HTMLIFrameElement.align */
  String align;

  /** @domName HTMLIFrameElement.contentWindow */
  Window get contentWindow;

  /** @domName HTMLIFrameElement.frameBorder */
  String frameBorder;

  /** @domName HTMLIFrameElement.height */
  String height;

  /** @domName HTMLIFrameElement.longDesc */
  String longDesc;

  /** @domName HTMLIFrameElement.marginHeight */
  String marginHeight;

  /** @domName HTMLIFrameElement.marginWidth */
  String marginWidth;

  /** @domName HTMLIFrameElement.name */
  String name;

  /** @domName HTMLIFrameElement.sandbox */
  String sandbox;

  /** @domName HTMLIFrameElement.scrolling */
  String scrolling;

  /** @domName HTMLIFrameElement.src */
  String src;

  /** @domName HTMLIFrameElement.srcdoc */
  String srcdoc;

  /** @domName HTMLIFrameElement.width */
  String width;
}

class _IFrameElementImpl extends _ElementImpl implements IFrameElement native "*HTMLIFrameElement" {

  String align;

  Window get contentWindow => _convertNativeToDart_Window(this._contentWindow);
  Window get _contentWindow => JS("Window", "#.contentWindow", this);

  String frameBorder;

  String height;

  String longDesc;

  String marginHeight;

  String marginWidth;

  String name;

  String sandbox;

  String scrolling;

  String src;

  String srcdoc;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void IceCallback(IceCandidate candidate, bool moreToFollow, PeerConnection00 source);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IceCandidate
abstract class IceCandidate {

  factory IceCandidate(String label, String candidateLine) => _IceCandidateFactoryProvider.createIceCandidate(label, candidateLine);

  /** @domName IceCandidate.label */
  String get label;

  /** @domName IceCandidate.toSdp */
  String toSdp();
}

class _IceCandidateImpl implements IceCandidate native "*IceCandidate" {

  final String label;

  String toSdp() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ImageData
abstract class ImageData {

  /** @domName ImageData.data */
  Uint8ClampedArray get data;

  /** @domName ImageData.height */
  int get height;

  /** @domName ImageData.width */
  int get width;
}

class _ImageDataImpl implements ImageData native "*ImageData" {

  final _Uint8ClampedArrayImpl data;

  final int height;

  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLImageElement
abstract class ImageElement implements Element {

  factory ImageElement({String src, int width, int height}) {
    if (!?src) {
      return _Elements.createImageElement();
    }
    if (!?width) {
      return _Elements.createImageElement(src);
    }
    if (!?height) {
      return _Elements.createImageElement(src, width);
    }
    return _Elements.createImageElement(src, width, height);
  }

  /** @domName HTMLImageElement.align */
  String align;

  /** @domName HTMLImageElement.alt */
  String alt;

  /** @domName HTMLImageElement.border */
  String border;

  /** @domName HTMLImageElement.complete */
  bool get complete;

  /** @domName HTMLImageElement.crossOrigin */
  String crossOrigin;

  /** @domName HTMLImageElement.height */
  int height;

  /** @domName HTMLImageElement.hspace */
  int hspace;

  /** @domName HTMLImageElement.isMap */
  bool isMap;

  /** @domName HTMLImageElement.longDesc */
  String longDesc;

  /** @domName HTMLImageElement.lowsrc */
  String lowsrc;

  /** @domName HTMLImageElement.name */
  String name;

  /** @domName HTMLImageElement.naturalHeight */
  int get naturalHeight;

  /** @domName HTMLImageElement.naturalWidth */
  int get naturalWidth;

  /** @domName HTMLImageElement.src */
  String src;

  /** @domName HTMLImageElement.useMap */
  String useMap;

  /** @domName HTMLImageElement.vspace */
  int vspace;

  /** @domName HTMLImageElement.width */
  int width;

  /** @domName HTMLImageElement.x */
  int get x;

  /** @domName HTMLImageElement.y */
  int get y;
}

class _ImageElementImpl extends _ElementImpl implements ImageElement native "*HTMLImageElement" {

  String align;

  String alt;

  String border;

  final bool complete;

  String crossOrigin;

  int height;

  int hspace;

  bool isMap;

  String longDesc;

  String lowsrc;

  String name;

  final int naturalHeight;

  final int naturalWidth;

  String src;

  String useMap;

  int vspace;

  int width;

  final int x;

  final int y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLInputElement
abstract class InputElement implements Element {

  factory InputElement({String type}) {
    if (!?type) {
      return _Elements.createInputElement();
    }
    return _Elements.createInputElement(type);
  }

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  InputElementEvents get on;

  /** @domName HTMLInputElement.accept */
  String accept;

  /** @domName HTMLInputElement.align */
  String align;

  /** @domName HTMLInputElement.alt */
  String alt;

  /** @domName HTMLInputElement.autocomplete */
  String autocomplete;

  /** @domName HTMLInputElement.autofocus */
  bool autofocus;

  /** @domName HTMLInputElement.checked */
  bool checked;

  /** @domName HTMLInputElement.defaultChecked */
  bool defaultChecked;

  /** @domName HTMLInputElement.defaultValue */
  String defaultValue;

  /** @domName HTMLInputElement.dirName */
  String dirName;

  /** @domName HTMLInputElement.disabled */
  bool disabled;

  /** @domName HTMLInputElement.files */
  List<File> files;

  /** @domName HTMLInputElement.form */
  FormElement get form;

  /** @domName HTMLInputElement.formAction */
  String formAction;

  /** @domName HTMLInputElement.formEnctype */
  String formEnctype;

  /** @domName HTMLInputElement.formMethod */
  String formMethod;

  /** @domName HTMLInputElement.formNoValidate */
  bool formNoValidate;

  /** @domName HTMLInputElement.formTarget */
  String formTarget;

  /** @domName HTMLInputElement.height */
  int height;

  /** @domName HTMLInputElement.incremental */
  bool incremental;

  /** @domName HTMLInputElement.indeterminate */
  bool indeterminate;

  /** @domName HTMLInputElement.labels */
  List<Node> get labels;

  /** @domName HTMLInputElement.list */
  Element get list;

  /** @domName HTMLInputElement.max */
  String max;

  /** @domName HTMLInputElement.maxLength */
  int maxLength;

  /** @domName HTMLInputElement.min */
  String min;

  /** @domName HTMLInputElement.multiple */
  bool multiple;

  /** @domName HTMLInputElement.name */
  String name;

  /** @domName HTMLInputElement.pattern */
  String pattern;

  /** @domName HTMLInputElement.placeholder */
  String placeholder;

  /** @domName HTMLInputElement.readOnly */
  bool readOnly;

  /** @domName HTMLInputElement.required */
  bool required;

  /** @domName HTMLInputElement.selectionDirection */
  String selectionDirection;

  /** @domName HTMLInputElement.selectionEnd */
  int selectionEnd;

  /** @domName HTMLInputElement.selectionStart */
  int selectionStart;

  /** @domName HTMLInputElement.size */
  int size;

  /** @domName HTMLInputElement.src */
  String src;

  /** @domName HTMLInputElement.step */
  String step;

  /** @domName HTMLInputElement.type */
  String type;

  /** @domName HTMLInputElement.useMap */
  String useMap;

  /** @domName HTMLInputElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLInputElement.validity */
  ValidityState get validity;

  /** @domName HTMLInputElement.value */
  String value;

  /** @domName HTMLInputElement.valueAsDate */
  Date valueAsDate;

  /** @domName HTMLInputElement.valueAsNumber */
  num valueAsNumber;

  /** @domName HTMLInputElement.webkitEntries */
  List<Entry> get webkitEntries;

  /** @domName HTMLInputElement.webkitGrammar */
  bool webkitGrammar;

  /** @domName HTMLInputElement.webkitSpeech */
  bool webkitSpeech;

  /** @domName HTMLInputElement.webkitdirectory */
  bool webkitdirectory;

  /** @domName HTMLInputElement.width */
  int width;

  /** @domName HTMLInputElement.willValidate */
  bool get willValidate;

  /** @domName HTMLInputElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLInputElement.select */
  void select();

  /** @domName HTMLInputElement.setCustomValidity */
  void setCustomValidity(String error);

  /** @domName HTMLInputElement.setRangeText */
  void setRangeText(String replacement, [int start, int end, String selectionMode]);

  /** @domName HTMLInputElement.setSelectionRange */
  void setSelectionRange(int start, int end, [String direction]);

  /** @domName HTMLInputElement.stepDown */
  void stepDown([int n]);

  /** @domName HTMLInputElement.stepUp */
  void stepUp([int n]);
}

abstract class InputElementEvents implements ElementEvents {

  EventListenerList get speechChange;
}

class _InputElementImpl extends _ElementImpl implements InputElement native "*HTMLInputElement" {

  _InputElementEventsImpl get on =>
    new _InputElementEventsImpl(this);

  String accept;

  String align;

  String alt;

  String autocomplete;

  bool autofocus;

  bool checked;

  bool defaultChecked;

  String defaultValue;

  String dirName;

  bool disabled;

  _FileListImpl files;

  final _FormElementImpl form;

  String formAction;

  String formEnctype;

  String formMethod;

  bool formNoValidate;

  String formTarget;

  int height;

  bool incremental;

  bool indeterminate;

  final List<Node> labels;

  final _ElementImpl list;

  String max;

  int maxLength;

  String min;

  bool multiple;

  String name;

  String pattern;

  String placeholder;

  bool readOnly;

  bool required;

  String selectionDirection;

  int selectionEnd;

  int selectionStart;

  int size;

  String src;

  String step;

  String type;

  String useMap;

  final String validationMessage;

  final _ValidityStateImpl validity;

  String value;

  Date valueAsDate;

  num valueAsNumber;

  final _EntryArrayImpl webkitEntries;

  bool webkitGrammar;

  bool webkitSpeech;

  bool webkitdirectory;

  int width;

  final bool willValidate;

  bool checkValidity() native;

  void select() native;

  void setCustomValidity(String error) native;

  void setRangeText(String replacement, [int start, int end, String selectionMode]) native;

  void setSelectionRange(int start, int end, [String direction]) native;

  void stepDown([int n]) native;

  void stepUp([int n]) native;
}

class _InputElementEventsImpl extends _ElementEventsImpl implements InputElementEvents {
  _InputElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get speechChange => this['webkitSpeechChange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int16Array
abstract class Int16Array implements ArrayBufferView, List<int> {

  factory Int16Array(int length) =>
    _TypedArrayFactoryProvider.createInt16Array(length);

  factory Int16Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createInt16Array_fromList(list);

  factory Int16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createInt16Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 2;

  /** @domName Int16Array.length */
  int get length;

  /** @domName Int16Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int16Array.subarray */
  Int16Array subarray(int start, [int end]);
}

class _Int16ArrayImpl extends _ArrayBufferViewImpl implements Int16Array, List<int>, JavaScriptIndexingBehavior native "*Int16Array" {

  final int length;

  int operator[](int index) => JS("int", "#[#]", this, index);

  void operator[]=(int index, int value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(int element) => _Collections.contains(this, element);

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<int>:

  void sort([Comparator<int> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int get last => this[length - 1];

  int removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Int16ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int32Array
abstract class Int32Array implements ArrayBufferView, List<int> {

  factory Int32Array(int length) =>
    _TypedArrayFactoryProvider.createInt32Array(length);

  factory Int32Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createInt32Array_fromList(list);

  factory Int32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createInt32Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 4;

  /** @domName Int32Array.length */
  int get length;

  /** @domName Int32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int32Array.subarray */
  Int32Array subarray(int start, [int end]);
}

class _Int32ArrayImpl extends _ArrayBufferViewImpl implements Int32Array, List<int>, JavaScriptIndexingBehavior native "*Int32Array" {

  final int length;

  int operator[](int index) => JS("int", "#[#]", this, index);

  void operator[]=(int index, int value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(int element) => _Collections.contains(this, element);

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<int>:

  void sort([Comparator<int> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int get last => this[length - 1];

  int removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Int32ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int8Array
abstract class Int8Array implements ArrayBufferView, List<int> {

  factory Int8Array(int length) =>
    _TypedArrayFactoryProvider.createInt8Array(length);

  factory Int8Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createInt8Array_fromList(list);

  factory Int8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createInt8Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 1;

  /** @domName Int8Array.length */
  int get length;

  /** @domName Int8Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int8Array.subarray */
  Int8Array subarray(int start, [int end]);
}

class _Int8ArrayImpl extends _ArrayBufferViewImpl implements Int8Array, List<int>, JavaScriptIndexingBehavior native "*Int8Array" {

  final int length;

  int operator[](int index) => JS("int", "#[#]", this, index);

  void operator[]=(int index, int value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(int element) => _Collections.contains(this, element);

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<int>:

  void sort([Comparator<int> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int get last => this[length - 1];

  int removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Int8ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName JavaScriptCallFrame
abstract class JavaScriptCallFrame {

  static const int CATCH_SCOPE = 4;

  static const int CLOSURE_SCOPE = 3;

  static const int GLOBAL_SCOPE = 0;

  static const int LOCAL_SCOPE = 1;

  static const int WITH_SCOPE = 2;

  /** @domName JavaScriptCallFrame.caller */
  JavaScriptCallFrame get caller;

  /** @domName JavaScriptCallFrame.column */
  int get column;

  /** @domName JavaScriptCallFrame.functionName */
  String get functionName;

  /** @domName JavaScriptCallFrame.line */
  int get line;

  /** @domName JavaScriptCallFrame.scopeChain */
  List get scopeChain;

  /** @domName JavaScriptCallFrame.sourceID */
  int get sourceID;

  /** @domName JavaScriptCallFrame.thisObject */
  Object get thisObject;

  /** @domName JavaScriptCallFrame.type */
  String get type;

  /** @domName JavaScriptCallFrame.evaluate */
  void evaluate(String script);

  /** @domName JavaScriptCallFrame.restart */
  Object restart();

  /** @domName JavaScriptCallFrame.scopeType */
  int scopeType(int scopeIndex);
}

class _JavaScriptCallFrameImpl implements JavaScriptCallFrame native "*JavaScriptCallFrame" {

  final _JavaScriptCallFrameImpl caller;

  final int column;

  final String functionName;

  final int line;

  final List scopeChain;

  final int sourceID;

  final Object thisObject;

  final String type;

  void evaluate(String script) native;

  Object restart() native;

  int scopeType(int scopeIndex) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName KeyboardEvent
abstract class KeyboardEvent implements UIEvent {

  /** @domName KeyboardEvent.altGraphKey */
  bool get altGraphKey;

  /** @domName KeyboardEvent.altKey */
  bool get altKey;

  /** @domName KeyboardEvent.ctrlKey */
  bool get ctrlKey;

  /** @domName KeyboardEvent.keyIdentifier */
  String get keyIdentifier;

  /** @domName KeyboardEvent.keyLocation */
  int get keyLocation;

  /** @domName KeyboardEvent.metaKey */
  bool get metaKey;

  /** @domName KeyboardEvent.shiftKey */
  bool get shiftKey;

  /** @domName KeyboardEvent.initKeyboardEvent */
  void initKeyboardEvent(String type, bool canBubble, bool cancelable, LocalWindow view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey);
}

class _KeyboardEventImpl extends _UIEventImpl implements KeyboardEvent native "*KeyboardEvent" {

  final bool altGraphKey;

  final bool altKey;

  final bool ctrlKey;

  final String keyIdentifier;

  final int keyLocation;

  final bool metaKey;

  final bool shiftKey;

  void initKeyboardEvent(String type, bool canBubble, bool cancelable, _LocalWindowImpl view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLKeygenElement
abstract class KeygenElement implements Element {

  factory KeygenElement() => _Elements.createKeygenElement();

  /** @domName HTMLKeygenElement.autofocus */
  bool autofocus;

  /** @domName HTMLKeygenElement.challenge */
  String challenge;

  /** @domName HTMLKeygenElement.disabled */
  bool disabled;

  /** @domName HTMLKeygenElement.form */
  FormElement get form;

  /** @domName HTMLKeygenElement.keytype */
  String keytype;

  /** @domName HTMLKeygenElement.labels */
  List<Node> get labels;

  /** @domName HTMLKeygenElement.name */
  String name;

  /** @domName HTMLKeygenElement.type */
  String get type;

  /** @domName HTMLKeygenElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLKeygenElement.validity */
  ValidityState get validity;

  /** @domName HTMLKeygenElement.willValidate */
  bool get willValidate;

  /** @domName HTMLKeygenElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLKeygenElement.setCustomValidity */
  void setCustomValidity(String error);
}

class _KeygenElementImpl extends _ElementImpl implements KeygenElement native "*HTMLKeygenElement" {

  bool autofocus;

  String challenge;

  bool disabled;

  final _FormElementImpl form;

  String keytype;

  final List<Node> labels;

  String name;

  final String type;

  final String validationMessage;

  final _ValidityStateImpl validity;

  final bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLIElement
abstract class LIElement implements Element {

  factory LIElement() => _Elements.createLIElement();

  /** @domName HTMLLIElement.type */
  String type;

  /** @domName HTMLLIElement.value */
  int value;
}

class _LIElementImpl extends _ElementImpl implements LIElement native "*HTMLLIElement" {

  String type;

  int value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLabelElement
abstract class LabelElement implements Element {

  factory LabelElement() => _Elements.createLabelElement();

  /** @domName HTMLLabelElement.control */
  Element get control;

  /** @domName HTMLLabelElement.form */
  FormElement get form;

  /** @domName HTMLLabelElement.htmlFor */
  String htmlFor;
}

class _LabelElementImpl extends _ElementImpl implements LabelElement native "*HTMLLabelElement" {

  final _ElementImpl control;

  final _FormElementImpl form;

  String htmlFor;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLegendElement
abstract class LegendElement implements Element {

  factory LegendElement() => _Elements.createLegendElement();

  /** @domName HTMLLegendElement.align */
  String align;

  /** @domName HTMLLegendElement.form */
  FormElement get form;
}

class _LegendElementImpl extends _ElementImpl implements LegendElement native "*HTMLLegendElement" {

  String align;

  final _FormElementImpl form;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLinkElement
abstract class LinkElement implements Element {

  factory LinkElement() => _Elements.createLinkElement();

  /** @domName HTMLLinkElement.charset */
  String charset;

  /** @domName HTMLLinkElement.disabled */
  bool disabled;

  /** @domName HTMLLinkElement.href */
  String href;

  /** @domName HTMLLinkElement.hreflang */
  String hreflang;

  /** @domName HTMLLinkElement.media */
  String media;

  /** @domName HTMLLinkElement.rel */
  String rel;

  /** @domName HTMLLinkElement.rev */
  String rev;

  /** @domName HTMLLinkElement.sheet */
  StyleSheet get sheet;

  /** @domName HTMLLinkElement.sizes */
  DOMSettableTokenList sizes;

  /** @domName HTMLLinkElement.target */
  String target;

  /** @domName HTMLLinkElement.type */
  String type;
}

class _LinkElementImpl extends _ElementImpl implements LinkElement native "*HTMLLinkElement" {

  String charset;

  bool disabled;

  String href;

  String hreflang;

  String media;

  String rel;

  String rev;

  final _StyleSheetImpl sheet;

  _DOMSettableTokenListImpl sizes;

  String target;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName History
abstract class LocalHistory implements History {

  /** @domName History.length */
  int get length;

  /** @domName History.state */
  dynamic get state;

  /** @domName History.back */
  void back();

  /** @domName History.forward */
  void forward();

  /** @domName History.go */
  void go(int distance);

  /** @domName History.pushState */
  void pushState(Object data, String title, [String url]);

  /** @domName History.replaceState */
  void replaceState(Object data, String title, [String url]);
}

class _LocalHistoryImpl implements LocalHistory native "*History" {

  final int length;

  final dynamic state;

  void back() native;

  void forward() native;

  void go(int distance) native;

  void pushState(Object data, String title, [String url]) native;

  void replaceState(Object data, String title, [String url]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Location
abstract class LocalLocation implements Location {

  /** @domName Location.ancestorOrigins */
  List<String> get ancestorOrigins;

  /** @domName Location.hash */
  String hash;

  /** @domName Location.host */
  String host;

  /** @domName Location.hostname */
  String hostname;

  /** @domName Location.href */
  String href;

  /** @domName Location.origin */
  String get origin;

  /** @domName Location.pathname */
  String pathname;

  /** @domName Location.port */
  String port;

  /** @domName Location.protocol */
  String protocol;

  /** @domName Location.search */
  String search;

  /** @domName Location.assign */
  void assign(String url);

  /** @domName Location.reload */
  void reload();

  /** @domName Location.replace */
  void replace(String url);

  /** @domName Location.toString */
  String toString();
}

class _LocalLocationImpl implements LocalLocation native "*Location" {

  final _DOMStringListImpl ancestorOrigins;

  String hash;

  String host;

  String hostname;

  String href;

  final String origin;

  String pathname;

  String port;

  String protocol;

  String search;

  void assign(String url) native;

  void reload() native;

  void replace(String url) native;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName LocalMediaStream
abstract class LocalMediaStream implements MediaStream, EventTarget {

  /** @domName LocalMediaStream.stop */
  void stop();
}

class _LocalMediaStreamImpl extends _MediaStreamImpl implements LocalMediaStream native "*LocalMediaStream" {

  void stop() native;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName Window
abstract class LocalWindow implements EventTarget, Window {

  /**
   * Register a [port] on this window under the given [name].  This
   * port may be retrieved by any isolate (or JavaScript script)
   * running in this window.
   */
  void registerPort(String name, SendPortSync port);

  /**
   * Lookup a port by its [name].  Return null if no port is
   * registered under [name].
   */
  SendPortSync lookupPort(String name);

  /**
   * Executes a [callback] after the next batch of browser layout measurements
   * has completed or would have completed if any browser layout measurements
   * had been scheduled.
   */
  void requestLayoutFrame(TimeoutHandler callback);

  /**
   * Creates a new object URL for the specified object. The URL will be
   * available until revokeObjectUrl is called.
   * [object] can be a Blob, MediaStream or MediaSource.
   */
  String createObjectUrl(object);

  /** @domName DOMURL.revokeObjectURL */
  void revokeObjectUrl(String objectUrl);


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  LocalWindowEvents get on;

  static const int PERSISTENT = 1;

  static const int TEMPORARY = 0;

  /** @domName Window.applicationCache */
  DOMApplicationCache get applicationCache;

  /** @domName Window.clientInformation */
  Navigator get clientInformation;

  /** @domName Window.closed */
  bool get closed;

  /** @domName Window.console */
  Console get console;

  /** @domName Window.crypto */
  Crypto get crypto;

  /** @domName Window.defaultStatus */
  String defaultStatus;

  /** @domName Window.defaultstatus */
  String defaultstatus;

  /** @domName Window.devicePixelRatio */
  num get devicePixelRatio;

  /** @domName Window.document */
  Document get document;

  /** @domName Window.event */
  Event get event;

  /** @domName Window.history */
  LocalHistory get history;

  /** @domName DOMWindow.indexedDB */
  IDBFactory get indexedDB;

  /** @domName Window.innerHeight */
  int get innerHeight;

  /** @domName Window.innerWidth */
  int get innerWidth;

  /** @domName Window.localStorage */
  Storage get localStorage;

  /** @domName Window.location */
  LocalLocation location;

  /** @domName Window.locationbar */
  BarInfo get locationbar;

  /** @domName Window.menubar */
  BarInfo get menubar;

  /** @domName Window.name */
  String name;

  /** @domName Window.navigator */
  Navigator get navigator;

  /** @domName Window.offscreenBuffering */
  bool get offscreenBuffering;

  /** @domName Window.opener */
  Window get opener;

  /** @domName Window.outerHeight */
  int get outerHeight;

  /** @domName Window.outerWidth */
  int get outerWidth;

  /** @domName DOMWindow.pagePopupController */
  PagePopupController get pagePopupController;

  /** @domName Window.pageXOffset */
  int get pageXOffset;

  /** @domName Window.pageYOffset */
  int get pageYOffset;

  /** @domName Window.parent */
  Window get parent;

  /** @domName Window.performance */
  Performance get performance;

  /** @domName Window.personalbar */
  BarInfo get personalbar;

  /** @domName Window.screen */
  Screen get screen;

  /** @domName Window.screenLeft */
  int get screenLeft;

  /** @domName Window.screenTop */
  int get screenTop;

  /** @domName Window.screenX */
  int get screenX;

  /** @domName Window.screenY */
  int get screenY;

  /** @domName Window.scrollX */
  int get scrollX;

  /** @domName Window.scrollY */
  int get scrollY;

  /** @domName Window.scrollbars */
  BarInfo get scrollbars;

  /** @domName Window.self */
  Window get self;

  /** @domName Window.sessionStorage */
  Storage get sessionStorage;

  /** @domName Window.status */
  String status;

  /** @domName Window.statusbar */
  BarInfo get statusbar;

  /** @domName Window.styleMedia */
  StyleMedia get styleMedia;

  /** @domName Window.toolbar */
  BarInfo get toolbar;

  /** @domName Window.top */
  Window get top;

  /** @domName DOMWindow.webkitIndexedDB */
  IDBFactory get webkitIndexedDB;

  /** @domName DOMWindow.webkitNotifications */
  NotificationCenter get webkitNotifications;

  /** @domName DOMWindow.webkitStorageInfo */
  StorageInfo get webkitStorageInfo;

  /** @domName Window.window */
  Window get window;

  /** @domName Window.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Window.alert */
  void alert(String message);

  /** @domName Window.atob */
  String atob(String string);

  /** @domName Window.blur */
  void blur();

  /** @domName Window.btoa */
  String btoa(String string);

  /** @domName Window.cancelAnimationFrame */
  void cancelAnimationFrame(int id);

  /** @domName Window.captureEvents */
  void captureEvents();

  /** @domName Window.clearInterval */
  void clearInterval(int handle);

  /** @domName Window.clearTimeout */
  void clearTimeout(int handle);

  /** @domName Window.close */
  void close();

  /** @domName Window.confirm */
  bool confirm(String message);

  /** @domName Window.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName Window.find */
  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog);

  /** @domName Window.focus */
  void focus();

  /** @domName Window.getComputedStyle */
  CSSStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement);

  /** @domName Window.getMatchedCSSRules */
  List<CSSRule> getMatchedCSSRules(Element element, String pseudoElement);

  /** @domName Window.getSelection */
  DOMSelection getSelection();

  /** @domName Window.matchMedia */
  MediaQueryList matchMedia(String query);

  /** @domName Window.moveBy */
  void moveBy(num x, num y);

  /** @domName Window.moveTo */
  void moveTo(num x, num y);

  /** @domName Window.open */
  Window open(String url, String name, [String options]);

  /** @domName DOMWindow.openDatabase */
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName Window.postMessage */
  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts]);

  /** @domName Window.print */
  void print();

  /** @domName Window.prompt */
  String prompt(String message, String defaultValue);

  /** @domName Window.releaseEvents */
  void releaseEvents();

  /** @domName Window.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Window.requestAnimationFrame */
  int requestAnimationFrame(RequestAnimationFrameCallback callback);

  /** @domName Window.resizeBy */
  void resizeBy(num x, num y);

  /** @domName Window.resizeTo */
  void resizeTo(num width, num height);

  /** @domName Window.scroll */
  void scroll(int x, int y);

  /** @domName Window.scrollBy */
  void scrollBy(int x, int y);

  /** @domName Window.scrollTo */
  void scrollTo(int x, int y);

  /** @domName Window.setInterval */
  int setInterval(TimeoutHandler handler, int timeout);

  /** @domName Window.setTimeout */
  int setTimeout(TimeoutHandler handler, int timeout);

  /** @domName Window.showModalDialog */
  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]);

  /** @domName Window.stop */
  void stop();

  /** @domName Window.webkitCancelAnimationFrame */
  void webkitCancelAnimationFrame(int id);

  /** @domName Window.webkitConvertPointFromNodeToPage */
  Point webkitConvertPointFromNodeToPage(Node node, Point p);

  /** @domName Window.webkitConvertPointFromPageToNode */
  Point webkitConvertPointFromPageToNode(Node node, Point p);

  /** @domName Window.webkitRequestAnimationFrame */
  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback);

  /** @domName DOMWindow.webkitRequestFileSystem */
  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName DOMWindow.webkitResolveLocalFileSystemURL */
  void webkitResolveLocalFileSystemURL(String url, EntryCallback successCallback, [ErrorCallback errorCallback]);

}

abstract class LocalWindowEvents implements Events {

  EventListenerList get abort;

  EventListenerList get beforeUnload;

  EventListenerList get blur;

  EventListenerList get canPlay;

  EventListenerList get canPlayThrough;

  EventListenerList get change;

  EventListenerList get click;

  EventListenerList get contextMenu;

  EventListenerList get doubleClick;

  EventListenerList get deviceMotion;

  EventListenerList get deviceOrientation;

  EventListenerList get drag;

  EventListenerList get dragEnd;

  EventListenerList get dragEnter;

  EventListenerList get dragLeave;

  EventListenerList get dragOver;

  EventListenerList get dragStart;

  EventListenerList get drop;

  EventListenerList get durationChange;

  EventListenerList get emptied;

  EventListenerList get ended;

  EventListenerList get error;

  EventListenerList get focus;

  EventListenerList get hashChange;

  EventListenerList get input;

  EventListenerList get invalid;

  EventListenerList get keyDown;

  EventListenerList get keyPress;

  EventListenerList get keyUp;

  EventListenerList get load;

  EventListenerList get loadedData;

  EventListenerList get loadedMetadata;

  EventListenerList get loadStart;

  EventListenerList get message;

  EventListenerList get mouseDown;

  EventListenerList get mouseMove;

  EventListenerList get mouseOut;

  EventListenerList get mouseOver;

  EventListenerList get mouseUp;

  EventListenerList get mouseWheel;

  EventListenerList get offline;

  EventListenerList get online;

  EventListenerList get pageHide;

  EventListenerList get pageShow;

  EventListenerList get pause;

  EventListenerList get play;

  EventListenerList get playing;

  EventListenerList get popState;

  EventListenerList get progress;

  EventListenerList get rateChange;

  EventListenerList get reset;

  EventListenerList get resize;

  EventListenerList get scroll;

  EventListenerList get search;

  EventListenerList get seeked;

  EventListenerList get seeking;

  EventListenerList get select;

  EventListenerList get stalled;

  EventListenerList get storage;

  EventListenerList get submit;

  EventListenerList get suspend;

  EventListenerList get timeUpdate;

  EventListenerList get touchCancel;

  EventListenerList get touchEnd;

  EventListenerList get touchMove;

  EventListenerList get touchStart;

  EventListenerList get unload;

  EventListenerList get volumeChange;

  EventListenerList get waiting;

  EventListenerList get animationEnd;

  EventListenerList get animationIteration;

  EventListenerList get animationStart;

  EventListenerList get transitionEnd;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _LocalWindowImpl extends _EventTargetImpl implements LocalWindow native "@*DOMWindow" {

  _DocumentImpl get document => JS('_DocumentImpl', '#.document', this);

  Window _open2(url, name) => JS('Window', '#.open(#,#)', this, url, name);

  Window _open3(url, name, options) =>
      JS('Window', '#.open(#,#,#)', this, url, name, options);

  Window open(String url, String name, [String options]) {
    if (options == null) {
      return _DOMWindowCrossFrameImpl._createSafe(_open2(url, name));
    } else {
      return _DOMWindowCrossFrameImpl._createSafe(_open3(url, name, options));
    }
  }

  // API level getter and setter for Location.
  // TODO: The cross domain safe wrapper can be inserted here or folded into
  // _LocationWrapper.
  LocalLocation get location => _get_location();

  // TODO: consider forcing users to do: window.location.assign('string').
  /**
   * Sets the window's location, which causes the browser to navigate to the new
   * location. [value] may be a Location object or a string.
   */
  void set location(value) => _set_location(value);

  // Firefox work-around for Location.  The Firefox location object cannot be
  // made to behave like a Dart object so must be wrapped.

  LocalLocation _get_location() {
    var result = _location;
    if (_isDartLocation(result)) return result;  // e.g. on Chrome.
    if (null == _location_wrapper) {
      _location_wrapper = new _LocationWrapper(result);
    }
    return _location_wrapper;
  }

  void _set_location(value) {
    if (value is _LocationWrapper) {
      _location = value._ptr;
    } else {
      _location = value;
    }
  }

  var _location_wrapper;  // Cached wrapped Location object.

  // Native getter and setter to access raw Location object.
  Location get _location => JS('Location', '#.location', this);
  void set _location(Location value) {
    JS('void', '#.location = #', this, value);
  }
  // Prevent compiled from thinking 'location' property is available for a Dart
  // member.
  _protect_location() native 'location';

  static _isDartLocation(thing) {
    // On Firefox the code that implements 'is Location' fails to find the patch
    // stub on Object.prototype and throws an exception.
    try {
      return thing is Location;
    } catch (e) {
      return false;
    }
  }


  void requestLayoutFrame(TimeoutHandler callback) {
    _addMeasurementFrameCallback(callback);
  }

  /** @domName DOMWindow.requestAnimationFrame */
  int requestAnimationFrame(RequestAnimationFrameCallback callback) {
    _ensureRequestAnimationFrame();
    return _requestAnimationFrame(callback);
  }

  void cancelAnimationFrame(id) {
    _ensureRequestAnimationFrame();
    _cancelAnimationFrame(id);
  }

  int _requestAnimationFrame(RequestAnimationFrameCallback callback)
      native 'requestAnimationFrame';

  void _cancelAnimationFrame(int id)
      native 'cancelAnimationFrame';

  _ensureRequestAnimationFrame() {
    if (JS('bool',
           '!!(#.requestAnimationFrame && #.cancelAnimationFrame)', this, this))
      return;

    JS('void',
       r"""
  (function($this) {
   var vendors = ['ms', 'moz', 'webkit', 'o'];
   for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
     $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
     $this.cancelAnimationFrame =
         $this[vendors[i]+'CancelAnimationFrame'] ||
         $this[vendors[i]+'CancelRequestAnimationFrame'];
   }
   if ($this.requestAnimationFrame && $this.cancelAnimationFrame) return;
   $this.requestAnimationFrame = function(callback) {
      return window.setTimeout(function() {
        callback(Date.now());
      }, 16 /* 16ms ~= 60fps */);
   };
   $this.cancelAnimationFrame = function(id) { clearTimeout(id); }
  })(#)""",
       this);
  }


  _IDBFactoryImpl get indexedDB => _get_indexedDB();

  _IDBFactoryImpl _get_indexedDB() =>
      JS('_IDBFactoryImpl',
         '#.indexedDB || #.webkitIndexedDB || #.mozIndexedDB',
         this, this, this);

  // TODO(kasperl): Document these.
  lookupPort(String name) {
    var port = JSON.parse(localStorage['dart-port:$name']);
    return _deserialize(port);
  }

  registerPort(String name, var port) {
    var serialized = _serialize(port);
    localStorage['dart-port:$name'] = JSON.stringify(serialized);
  }

  String createObjectUrl(object) =>
      JS('String',
         '(window.URL || window.webkitURL).createObjectURL(#)', object);

  void revokeObjectUrl(String objectUrl) {
    JS('void',
       '(window.URL || window.webkitURL).revokeObjectURL(#)', objectUrl);
  }


  _LocalWindowEventsImpl get on =>
    new _LocalWindowEventsImpl(this);

  final _DOMApplicationCacheImpl applicationCache;

  final _NavigatorImpl clientInformation;

  final bool closed;

  final _ConsoleImpl console;

  final _CryptoImpl crypto;

  String defaultStatus;

  String defaultstatus;

  final num devicePixelRatio;

  final _EventImpl event;

  final _LocalHistoryImpl history;

  final int innerHeight;

  final int innerWidth;

  final _StorageImpl localStorage;

  final _BarInfoImpl locationbar;

  final _BarInfoImpl menubar;

  String name;

  final _NavigatorImpl navigator;

  final bool offscreenBuffering;

  Window get opener => _convertNativeToDart_Window(this._opener);
  Window get _opener => JS("Window", "#.opener", this);

  final int outerHeight;

  final int outerWidth;

  final _PagePopupControllerImpl pagePopupController;

  final int pageXOffset;

  final int pageYOffset;

  Window get parent => _convertNativeToDart_Window(this._parent);
  Window get _parent => JS("Window", "#.parent", this);

  final _PerformanceImpl performance;

  final _BarInfoImpl personalbar;

  final _ScreenImpl screen;

  final int screenLeft;

  final int screenTop;

  final int screenX;

  final int screenY;

  final int scrollX;

  final int scrollY;

  final _BarInfoImpl scrollbars;

  Window get self => _convertNativeToDart_Window(this._self);
  Window get _self => JS("Window", "#.self", this);

  final _StorageImpl sessionStorage;

  String status;

  final _BarInfoImpl statusbar;

  final _StyleMediaImpl styleMedia;

  final _BarInfoImpl toolbar;

  Window get top => _convertNativeToDart_Window(this._top);
  Window get _top => JS("Window", "#.top", this);

  final _IDBFactoryImpl webkitIndexedDB;

  final _NotificationCenterImpl webkitNotifications;

  final _StorageInfoImpl webkitStorageInfo;

  Window get window => _convertNativeToDart_Window(this._window);
  Window get _window => JS("Window", "#.window", this);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void alert(String message) native;

  String atob(String string) native;

  void blur() native;

  String btoa(String string) native;

  void captureEvents() native;

  void clearInterval(int handle) native;

  void clearTimeout(int handle) native;

  void close() native;

  bool confirm(String message) native;

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) native;

  void focus() native;

  _CSSStyleDeclarationImpl $dom_getComputedStyle(_ElementImpl element, String pseudoElement) native "getComputedStyle";

  _CSSRuleListImpl getMatchedCSSRules(_ElementImpl element, String pseudoElement) native;

  _DOMSelectionImpl getSelection() native;

  _MediaQueryListImpl matchMedia(String query) native;

  void moveBy(num x, num y) native;

  void moveTo(num x, num y) native;

  _DatabaseImpl openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native;

  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [messagePorts]) {
    if (?message &&
        !?messagePorts) {
      var message_1 = _convertDartToNative_SerializedScriptValue(message);
      _postMessage_1(message_1, targetOrigin);
      return;
    }
    if (?message &&
        (messagePorts is List || messagePorts == null)) {
      var message_2 = _convertDartToNative_SerializedScriptValue(message);
      _postMessage_2(message_2, targetOrigin, messagePorts);
      return;
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  void _postMessage_1(message, targetOrigin) native "postMessage";
  void _postMessage_2(message, targetOrigin, List messagePorts) native "postMessage";

  void print() native;

  String prompt(String message, String defaultValue) native;

  void releaseEvents() native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void resizeBy(num x, num y) native;

  void resizeTo(num width, num height) native;

  void scroll(int x, int y) native;

  void scrollBy(int x, int y) native;

  void scrollTo(int x, int y) native;

  int setInterval(TimeoutHandler handler, int timeout) native;

  int setTimeout(TimeoutHandler handler, int timeout) native;

  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]) native;

  void stop() native;

  _PointImpl webkitConvertPointFromNodeToPage(_NodeImpl node, _PointImpl p) native;

  _PointImpl webkitConvertPointFromPageToNode(_NodeImpl node, _PointImpl p) native;

  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback]) native;

  void webkitResolveLocalFileSystemURL(String url, EntryCallback successCallback, [ErrorCallback errorCallback]) native;

}

class _LocalWindowEventsImpl extends _EventsImpl implements LocalWindowEvents {
  _LocalWindowEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get beforeUnload => this['beforeunload'];

  EventListenerList get blur => this['blur'];

  EventListenerList get canPlay => this['canplay'];

  EventListenerList get canPlayThrough => this['canplaythrough'];

  EventListenerList get change => this['change'];

  EventListenerList get click => this['click'];

  EventListenerList get contextMenu => this['contextmenu'];

  EventListenerList get doubleClick => this['dblclick'];

  EventListenerList get deviceMotion => this['devicemotion'];

  EventListenerList get deviceOrientation => this['deviceorientation'];

  EventListenerList get drag => this['drag'];

  EventListenerList get dragEnd => this['dragend'];

  EventListenerList get dragEnter => this['dragenter'];

  EventListenerList get dragLeave => this['dragleave'];

  EventListenerList get dragOver => this['dragover'];

  EventListenerList get dragStart => this['dragstart'];

  EventListenerList get drop => this['drop'];

  EventListenerList get durationChange => this['durationchange'];

  EventListenerList get emptied => this['emptied'];

  EventListenerList get ended => this['ended'];

  EventListenerList get error => this['error'];

  EventListenerList get focus => this['focus'];

  EventListenerList get hashChange => this['hashchange'];

  EventListenerList get input => this['input'];

  EventListenerList get invalid => this['invalid'];

  EventListenerList get keyDown => this['keydown'];

  EventListenerList get keyPress => this['keypress'];

  EventListenerList get keyUp => this['keyup'];

  EventListenerList get load => this['load'];

  EventListenerList get loadedData => this['loadeddata'];

  EventListenerList get loadedMetadata => this['loadedmetadata'];

  EventListenerList get loadStart => this['loadstart'];

  EventListenerList get message => this['message'];

  EventListenerList get mouseDown => this['mousedown'];

  EventListenerList get mouseMove => this['mousemove'];

  EventListenerList get mouseOut => this['mouseout'];

  EventListenerList get mouseOver => this['mouseover'];

  EventListenerList get mouseUp => this['mouseup'];

  EventListenerList get mouseWheel => this['mousewheel'];

  EventListenerList get offline => this['offline'];

  EventListenerList get online => this['online'];

  EventListenerList get pageHide => this['pagehide'];

  EventListenerList get pageShow => this['pageshow'];

  EventListenerList get pause => this['pause'];

  EventListenerList get play => this['play'];

  EventListenerList get playing => this['playing'];

  EventListenerList get popState => this['popstate'];

  EventListenerList get progress => this['progress'];

  EventListenerList get rateChange => this['ratechange'];

  EventListenerList get reset => this['reset'];

  EventListenerList get resize => this['resize'];

  EventListenerList get scroll => this['scroll'];

  EventListenerList get search => this['search'];

  EventListenerList get seeked => this['seeked'];

  EventListenerList get seeking => this['seeking'];

  EventListenerList get select => this['select'];

  EventListenerList get stalled => this['stalled'];

  EventListenerList get storage => this['storage'];

  EventListenerList get submit => this['submit'];

  EventListenerList get suspend => this['suspend'];

  EventListenerList get timeUpdate => this['timeupdate'];

  EventListenerList get touchCancel => this['touchcancel'];

  EventListenerList get touchEnd => this['touchend'];

  EventListenerList get touchMove => this['touchmove'];

  EventListenerList get touchStart => this['touchstart'];

  EventListenerList get unload => this['unload'];

  EventListenerList get volumeChange => this['volumechange'];

  EventListenerList get waiting => this['waiting'];

  EventListenerList get animationEnd => this['webkitAnimationEnd'];

  EventListenerList get animationIteration => this['webkitAnimationIteration'];

  EventListenerList get animationStart => this['webkitAnimationStart'];

  EventListenerList get transitionEnd => this['webkitTransitionEnd'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMapElement
abstract class MapElement implements Element {

  factory MapElement() => _Elements.createMapElement();

  /** @domName HTMLMapElement.areas */
  HTMLCollection get areas;

  /** @domName HTMLMapElement.name */
  String name;
}

class _MapElementImpl extends _ElementImpl implements MapElement native "*HTMLMapElement" {

  final _HTMLCollectionImpl areas;

  String name;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMarqueeElement
abstract class MarqueeElement implements Element {

  /** @domName HTMLMarqueeElement.behavior */
  String behavior;

  /** @domName HTMLMarqueeElement.bgColor */
  String bgColor;

  /** @domName HTMLMarqueeElement.direction */
  String direction;

  /** @domName HTMLMarqueeElement.height */
  String height;

  /** @domName HTMLMarqueeElement.hspace */
  int hspace;

  /** @domName HTMLMarqueeElement.loop */
  int loop;

  /** @domName HTMLMarqueeElement.scrollAmount */
  int scrollAmount;

  /** @domName HTMLMarqueeElement.scrollDelay */
  int scrollDelay;

  /** @domName HTMLMarqueeElement.trueSpeed */
  bool trueSpeed;

  /** @domName HTMLMarqueeElement.vspace */
  int vspace;

  /** @domName HTMLMarqueeElement.width */
  String width;

  /** @domName HTMLMarqueeElement.start */
  void start();

  /** @domName HTMLMarqueeElement.stop */
  void stop();
}

class _MarqueeElementImpl extends _ElementImpl implements MarqueeElement native "*HTMLMarqueeElement" {

  String behavior;

  String bgColor;

  String direction;

  String height;

  int hspace;

  int loop;

  int scrollAmount;

  int scrollDelay;

  bool trueSpeed;

  int vspace;

  String width;

  void start() native;

  void stop() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaController
abstract class MediaController implements EventTarget {

  factory MediaController() => _MediaControllerFactoryProvider.createMediaController();

  /** @domName MediaController.buffered */
  TimeRanges get buffered;

  /** @domName MediaController.currentTime */
  num currentTime;

  /** @domName MediaController.defaultPlaybackRate */
  num defaultPlaybackRate;

  /** @domName MediaController.duration */
  num get duration;

  /** @domName MediaController.muted */
  bool muted;

  /** @domName MediaController.paused */
  bool get paused;

  /** @domName MediaController.playbackRate */
  num playbackRate;

  /** @domName MediaController.played */
  TimeRanges get played;

  /** @domName MediaController.seekable */
  TimeRanges get seekable;

  /** @domName MediaController.volume */
  num volume;

  /** @domName MediaController.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaController.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName MediaController.pause */
  void pause();

  /** @domName MediaController.play */
  void play();

  /** @domName MediaController.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

class _MediaControllerImpl extends _EventTargetImpl implements MediaController native "*MediaController" {

  final _TimeRangesImpl buffered;

  num currentTime;

  num defaultPlaybackRate;

  final num duration;

  bool muted;

  final bool paused;

  num playbackRate;

  final _TimeRangesImpl played;

  final _TimeRangesImpl seekable;

  num volume;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void pause() native;

  void play() native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMediaElement
abstract class MediaElement implements Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaElementEvents get on;

  static const int HAVE_CURRENT_DATA = 2;

  static const int HAVE_ENOUGH_DATA = 4;

  static const int HAVE_FUTURE_DATA = 3;

  static const int HAVE_METADATA = 1;

  static const int HAVE_NOTHING = 0;

  static const int NETWORK_EMPTY = 0;

  static const int NETWORK_IDLE = 1;

  static const int NETWORK_LOADING = 2;

  static const int NETWORK_NO_SOURCE = 3;

  /** @domName HTMLMediaElement.autoplay */
  bool autoplay;

  /** @domName HTMLMediaElement.buffered */
  TimeRanges get buffered;

  /** @domName HTMLMediaElement.controller */
  MediaController controller;

  /** @domName HTMLMediaElement.controls */
  bool controls;

  /** @domName HTMLMediaElement.currentSrc */
  String get currentSrc;

  /** @domName HTMLMediaElement.currentTime */
  num currentTime;

  /** @domName HTMLMediaElement.defaultMuted */
  bool defaultMuted;

  /** @domName HTMLMediaElement.defaultPlaybackRate */
  num defaultPlaybackRate;

  /** @domName HTMLMediaElement.duration */
  num get duration;

  /** @domName HTMLMediaElement.ended */
  bool get ended;

  /** @domName HTMLMediaElement.error */
  MediaError get error;

  /** @domName HTMLMediaElement.initialTime */
  num get initialTime;

  /** @domName HTMLMediaElement.loop */
  bool loop;

  /** @domName HTMLMediaElement.mediaGroup */
  String mediaGroup;

  /** @domName HTMLMediaElement.muted */
  bool muted;

  /** @domName HTMLMediaElement.networkState */
  int get networkState;

  /** @domName HTMLMediaElement.paused */
  bool get paused;

  /** @domName HTMLMediaElement.playbackRate */
  num playbackRate;

  /** @domName HTMLMediaElement.played */
  TimeRanges get played;

  /** @domName HTMLMediaElement.preload */
  String preload;

  /** @domName HTMLMediaElement.readyState */
  int get readyState;

  /** @domName HTMLMediaElement.seekable */
  TimeRanges get seekable;

  /** @domName HTMLMediaElement.seeking */
  bool get seeking;

  /** @domName HTMLMediaElement.src */
  String src;

  /** @domName HTMLMediaElement.startTime */
  num get startTime;

  /** @domName HTMLMediaElement.textTracks */
  TextTrackList get textTracks;

  /** @domName HTMLMediaElement.volume */
  num volume;

  /** @domName HTMLMediaElement.webkitAudioDecodedByteCount */
  int get webkitAudioDecodedByteCount;

  /** @domName HTMLMediaElement.webkitClosedCaptionsVisible */
  bool webkitClosedCaptionsVisible;

  /** @domName HTMLMediaElement.webkitHasClosedCaptions */
  bool get webkitHasClosedCaptions;

  /** @domName HTMLMediaElement.webkitPreservesPitch */
  bool webkitPreservesPitch;

  /** @domName HTMLMediaElement.webkitVideoDecodedByteCount */
  int get webkitVideoDecodedByteCount;

  /** @domName HTMLMediaElement.addTextTrack */
  TextTrack addTextTrack(String kind, [String label, String language]);

  /** @domName HTMLMediaElement.canPlayType */
  String canPlayType(String type, String keySystem);

  /** @domName HTMLMediaElement.load */
  void load();

  /** @domName HTMLMediaElement.pause */
  void pause();

  /** @domName HTMLMediaElement.play */
  void play();

  /** @domName HTMLMediaElement.webkitAddKey */
  void webkitAddKey(String keySystem, Uint8Array key, [Uint8Array initData, String sessionId]);

  /** @domName HTMLMediaElement.webkitCancelKeyRequest */
  void webkitCancelKeyRequest(String keySystem, String sessionId);

  /** @domName HTMLMediaElement.webkitGenerateKeyRequest */
  void webkitGenerateKeyRequest(String keySystem, [Uint8Array initData]);
}

abstract class MediaElementEvents implements ElementEvents {

  EventListenerList get canPlay;

  EventListenerList get canPlayThrough;

  EventListenerList get durationChange;

  EventListenerList get emptied;

  EventListenerList get ended;

  EventListenerList get loadedData;

  EventListenerList get loadedMetadata;

  EventListenerList get loadStart;

  EventListenerList get pause;

  EventListenerList get play;

  EventListenerList get playing;

  EventListenerList get progress;

  EventListenerList get rateChange;

  EventListenerList get seeked;

  EventListenerList get seeking;

  EventListenerList get show;

  EventListenerList get stalled;

  EventListenerList get suspend;

  EventListenerList get timeUpdate;

  EventListenerList get volumeChange;

  EventListenerList get waiting;

  EventListenerList get keyAdded;

  EventListenerList get keyError;

  EventListenerList get keyMessage;

  EventListenerList get needKey;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaElementAudioSourceNode
abstract class MediaElementAudioSourceNode implements AudioSourceNode {

  /** @domName MediaElementAudioSourceNode.mediaElement */
  MediaElement get mediaElement;
}

class _MediaElementAudioSourceNodeImpl extends _AudioSourceNodeImpl implements MediaElementAudioSourceNode native "*MediaElementAudioSourceNode" {

  final _MediaElementImpl mediaElement;
}

class _MediaElementImpl extends _ElementImpl implements MediaElement native "*HTMLMediaElement" {

  _MediaElementEventsImpl get on =>
    new _MediaElementEventsImpl(this);

  bool autoplay;

  final _TimeRangesImpl buffered;

  _MediaControllerImpl controller;

  bool controls;

  final String currentSrc;

  num currentTime;

  bool defaultMuted;

  num defaultPlaybackRate;

  final num duration;

  final bool ended;

  final _MediaErrorImpl error;

  final num initialTime;

  bool loop;

  String mediaGroup;

  bool muted;

  final int networkState;

  final bool paused;

  num playbackRate;

  final _TimeRangesImpl played;

  String preload;

  final int readyState;

  final _TimeRangesImpl seekable;

  final bool seeking;

  String src;

  final num startTime;

  final _TextTrackListImpl textTracks;

  num volume;

  final int webkitAudioDecodedByteCount;

  bool webkitClosedCaptionsVisible;

  final bool webkitHasClosedCaptions;

  bool webkitPreservesPitch;

  final int webkitVideoDecodedByteCount;

  _TextTrackImpl addTextTrack(String kind, [String label, String language]) native;

  String canPlayType(String type, String keySystem) native;

  void load() native;

  void pause() native;

  void play() native;

  void webkitAddKey(String keySystem, _Uint8ArrayImpl key, [_Uint8ArrayImpl initData, String sessionId]) native;

  void webkitCancelKeyRequest(String keySystem, String sessionId) native;

  void webkitGenerateKeyRequest(String keySystem, [_Uint8ArrayImpl initData]) native;
}

class _MediaElementEventsImpl extends _ElementEventsImpl implements MediaElementEvents {
  _MediaElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get canPlay => this['canplay'];

  EventListenerList get canPlayThrough => this['canplaythrough'];

  EventListenerList get durationChange => this['durationchange'];

  EventListenerList get emptied => this['emptied'];

  EventListenerList get ended => this['ended'];

  EventListenerList get loadedData => this['loadeddata'];

  EventListenerList get loadedMetadata => this['loadedmetadata'];

  EventListenerList get loadStart => this['loadstart'];

  EventListenerList get pause => this['pause'];

  EventListenerList get play => this['play'];

  EventListenerList get playing => this['playing'];

  EventListenerList get progress => this['progress'];

  EventListenerList get rateChange => this['ratechange'];

  EventListenerList get seeked => this['seeked'];

  EventListenerList get seeking => this['seeking'];

  EventListenerList get show => this['show'];

  EventListenerList get stalled => this['stalled'];

  EventListenerList get suspend => this['suspend'];

  EventListenerList get timeUpdate => this['timeupdate'];

  EventListenerList get volumeChange => this['volumechange'];

  EventListenerList get waiting => this['waiting'];

  EventListenerList get keyAdded => this['webkitkeyadded'];

  EventListenerList get keyError => this['webkitkeyerror'];

  EventListenerList get keyMessage => this['webkitkeymessage'];

  EventListenerList get needKey => this['webkitneedkey'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaError
abstract class MediaError {

  static const int MEDIA_ERR_ABORTED = 1;

  static const int MEDIA_ERR_DECODE = 3;

  static const int MEDIA_ERR_ENCRYPTED = 5;

  static const int MEDIA_ERR_NETWORK = 2;

  static const int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  /** @domName MediaError.code */
  int get code;
}

class _MediaErrorImpl implements MediaError native "*MediaError" {

  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaKeyError
abstract class MediaKeyError {

  static const int MEDIA_KEYERR_CLIENT = 2;

  static const int MEDIA_KEYERR_DOMAIN = 6;

  static const int MEDIA_KEYERR_HARDWARECHANGE = 5;

  static const int MEDIA_KEYERR_OUTPUT = 4;

  static const int MEDIA_KEYERR_SERVICE = 3;

  static const int MEDIA_KEYERR_UNKNOWN = 1;

  /** @domName MediaKeyError.code */
  int get code;
}

class _MediaKeyErrorImpl implements MediaKeyError native "*MediaKeyError" {

  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaKeyEvent
abstract class MediaKeyEvent implements Event {

  /** @domName MediaKeyEvent.defaultURL */
  String get defaultURL;

  /** @domName MediaKeyEvent.errorCode */
  MediaKeyError get errorCode;

  /** @domName MediaKeyEvent.initData */
  Uint8Array get initData;

  /** @domName MediaKeyEvent.keySystem */
  String get keySystem;

  /** @domName MediaKeyEvent.message */
  Uint8Array get message;

  /** @domName MediaKeyEvent.sessionId */
  String get sessionId;

  /** @domName MediaKeyEvent.systemCode */
  int get systemCode;
}

class _MediaKeyEventImpl extends _EventImpl implements MediaKeyEvent native "*MediaKeyEvent" {

  final String defaultURL;

  final _MediaKeyErrorImpl errorCode;

  final _Uint8ArrayImpl initData;

  final String keySystem;

  final _Uint8ArrayImpl message;

  final String sessionId;

  final int systemCode;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaList
abstract class MediaList {

  /** @domName MediaList.length */
  int get length;

  /** @domName MediaList.mediaText */
  String mediaText;

  /** @domName MediaList.appendMedium */
  void appendMedium(String newMedium);

  /** @domName MediaList.deleteMedium */
  void deleteMedium(String oldMedium);

  /** @domName MediaList.item */
  String item(int index);
}

class _MediaListImpl implements MediaList native "*MediaList" {

  final int length;

  String mediaText;

  void appendMedium(String newMedium) native;

  void deleteMedium(String oldMedium) native;

  String item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaQueryList
abstract class MediaQueryList {

  /** @domName MediaQueryList.matches */
  bool get matches;

  /** @domName MediaQueryList.media */
  String get media;

  /** @domName MediaQueryList.addListener */
  void addListener(MediaQueryListListener listener);

  /** @domName MediaQueryList.removeListener */
  void removeListener(MediaQueryListListener listener);
}

class _MediaQueryListImpl implements MediaQueryList native "*MediaQueryList" {

  final bool matches;

  final String media;

  void addListener(MediaQueryListListener listener) native;

  void removeListener(MediaQueryListListener listener) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaQueryListListener
abstract class MediaQueryListListener {

  /** @domName MediaQueryListListener.queryChanged */
  void queryChanged(MediaQueryList list);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaSource
abstract class MediaSource implements EventTarget {

  factory MediaSource() => _MediaSourceFactoryProvider.createMediaSource();

  /** @domName MediaSource.activeSourceBuffers */
  SourceBufferList get activeSourceBuffers;

  /** @domName MediaSource.duration */
  num duration;

  /** @domName MediaSource.readyState */
  String get readyState;

  /** @domName MediaSource.sourceBuffers */
  SourceBufferList get sourceBuffers;

  /** @domName MediaSource.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaSource.addSourceBuffer */
  SourceBuffer addSourceBuffer(String type);

  /** @domName MediaSource.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName MediaSource.endOfStream */
  void endOfStream(String error);

  /** @domName MediaSource.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaSource.removeSourceBuffer */
  void removeSourceBuffer(SourceBuffer buffer);
}

class _MediaSourceImpl extends _EventTargetImpl implements MediaSource native "*MediaSource" {

  final _SourceBufferListImpl activeSourceBuffers;

  num duration;

  final String readyState;

  final _SourceBufferListImpl sourceBuffers;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  _SourceBufferImpl addSourceBuffer(String type) native;

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void endOfStream(String error) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void removeSourceBuffer(_SourceBufferImpl buffer) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStream
abstract class MediaStream implements EventTarget {

  factory MediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks) => _MediaStreamFactoryProvider.createMediaStream(audioTracks, videoTracks);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaStreamEvents get on;

  static const int ENDED = 2;

  static const int LIVE = 1;

  /** @domName MediaStream.audioTracks */
  MediaStreamTrackList get audioTracks;

  /** @domName MediaStream.label */
  String get label;

  /** @domName MediaStream.readyState */
  int get readyState;

  /** @domName MediaStream.videoTracks */
  MediaStreamTrackList get videoTracks;

  /** @domName MediaStream.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaStream.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName MediaStream.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class MediaStreamEvents implements Events {

  EventListenerList get ended;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamAudioSourceNode
abstract class MediaStreamAudioSourceNode implements AudioSourceNode {

  /** @domName MediaStreamAudioSourceNode.mediaStream */
  MediaStream get mediaStream;
}

class _MediaStreamAudioSourceNodeImpl extends _AudioSourceNodeImpl implements MediaStreamAudioSourceNode native "*MediaStreamAudioSourceNode" {

  final _MediaStreamImpl mediaStream;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamEvent
abstract class MediaStreamEvent implements Event {

  /** @domName MediaStreamEvent.stream */
  MediaStream get stream;
}

class _MediaStreamEventImpl extends _EventImpl implements MediaStreamEvent native "*MediaStreamEvent" {

  final _MediaStreamImpl stream;
}

class _MediaStreamImpl extends _EventTargetImpl implements MediaStream native "*MediaStream" {

  _MediaStreamEventsImpl get on =>
    new _MediaStreamEventsImpl(this);

  final _MediaStreamTrackListImpl audioTracks;

  final String label;

  final int readyState;

  final _MediaStreamTrackListImpl videoTracks;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _MediaStreamEventsImpl extends _EventsImpl implements MediaStreamEvents {
  _MediaStreamEventsImpl(_ptr) : super(_ptr);

  EventListenerList get ended => this['ended'];
}

class _MediaStreamListImpl implements List<MediaStream>, JavaScriptIndexingBehavior native "*MediaStreamList" {

  final int length;

  _MediaStreamImpl operator[](int index) => JS("_MediaStreamImpl", "#[#]", this, index);

  void operator[]=(int index, _MediaStreamImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<MediaStream> mixins.
  // MediaStream is the element type.

  // From Iterable<MediaStream>:

  Iterator<MediaStream> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<MediaStream>(this);
  }

  // From Collection<MediaStream>:

  void add(MediaStream value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(MediaStream value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<MediaStream> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(MediaStream element) => _Collections.contains(this, element);

  void forEach(void f(MediaStream element)) => _Collections.forEach(this, f);

  Collection map(f(MediaStream element)) => _Collections.map(this, [], f);

  Collection<MediaStream> filter(bool f(MediaStream element)) =>
     _Collections.filter(this, <MediaStream>[], f);

  bool every(bool f(MediaStream element)) => _Collections.every(this, f);

  bool some(bool f(MediaStream element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<MediaStream>:

  void sort([Comparator<MediaStream> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(MediaStream element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(MediaStream element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  MediaStream get last => this[length - 1];

  MediaStream removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<MediaStream> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [MediaStream initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<MediaStream> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <MediaStream>[]);

  // -- end List<MediaStream> mixins.

  _MediaStreamImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamTrack
abstract class MediaStreamTrack implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaStreamTrackEvents get on;

  static const int ENDED = 2;

  static const int LIVE = 0;

  static const int MUTED = 1;

  /** @domName MediaStreamTrack.enabled */
  bool enabled;

  /** @domName MediaStreamTrack.kind */
  String get kind;

  /** @domName MediaStreamTrack.label */
  String get label;

  /** @domName MediaStreamTrack.readyState */
  int get readyState;

  /** @domName MediaStreamTrack.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaStreamTrack.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName MediaStreamTrack.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class MediaStreamTrackEvents implements Events {

  EventListenerList get ended;

  EventListenerList get mute;

  EventListenerList get unmute;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamTrackEvent
abstract class MediaStreamTrackEvent implements Event {

  /** @domName MediaStreamTrackEvent.track */
  MediaStreamTrack get track;
}

class _MediaStreamTrackEventImpl extends _EventImpl implements MediaStreamTrackEvent native "*MediaStreamTrackEvent" {

  final _MediaStreamTrackImpl track;
}

class _MediaStreamTrackImpl extends _EventTargetImpl implements MediaStreamTrack native "*MediaStreamTrack" {

  _MediaStreamTrackEventsImpl get on =>
    new _MediaStreamTrackEventsImpl(this);

  bool enabled;

  final String kind;

  final String label;

  final int readyState;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _MediaStreamTrackEventsImpl extends _EventsImpl implements MediaStreamTrackEvents {
  _MediaStreamTrackEventsImpl(_ptr) : super(_ptr);

  EventListenerList get ended => this['ended'];

  EventListenerList get mute => this['mute'];

  EventListenerList get unmute => this['unmute'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamTrackList
abstract class MediaStreamTrackList implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaStreamTrackListEvents get on;

  /** @domName MediaStreamTrackList.length */
  int get length;

  /** @domName MediaStreamTrackList.add */
  void add(MediaStreamTrack track);

  /** @domName MediaStreamTrackList.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaStreamTrackList.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName MediaStreamTrackList.item */
  MediaStreamTrack item(int index);

  /** @domName MediaStreamTrackList.remove */
  void remove(MediaStreamTrack track);

  /** @domName MediaStreamTrackList.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class MediaStreamTrackListEvents implements Events {

  EventListenerList get addTrack;

  EventListenerList get removeTrack;
}

class _MediaStreamTrackListImpl extends _EventTargetImpl implements MediaStreamTrackList native "*MediaStreamTrackList" {

  _MediaStreamTrackListEventsImpl get on =>
    new _MediaStreamTrackListEventsImpl(this);

  final int length;

  void add(_MediaStreamTrackImpl track) native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  _MediaStreamTrackImpl item(int index) native;

  void remove(_MediaStreamTrackImpl track) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _MediaStreamTrackListEventsImpl extends _EventsImpl implements MediaStreamTrackListEvents {
  _MediaStreamTrackListEventsImpl(_ptr) : super(_ptr);

  EventListenerList get addTrack => this['addtrack'];

  EventListenerList get removeTrack => this['removetrack'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MemoryInfo
abstract class MemoryInfo {

  /** @domName MemoryInfo.jsHeapSizeLimit */
  int get jsHeapSizeLimit;

  /** @domName MemoryInfo.totalJSHeapSize */
  int get totalJSHeapSize;

  /** @domName MemoryInfo.usedJSHeapSize */
  int get usedJSHeapSize;
}

class _MemoryInfoImpl implements MemoryInfo native "*MemoryInfo" {

  final int jsHeapSizeLimit;

  final int totalJSHeapSize;

  final int usedJSHeapSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMenuElement
abstract class MenuElement implements Element {

  factory MenuElement() => _Elements.createMenuElement();

  /** @domName HTMLMenuElement.compact */
  bool compact;
}

class _MenuElementImpl extends _ElementImpl implements MenuElement native "*HTMLMenuElement" {

  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessageChannel
abstract class MessageChannel {

  factory MessageChannel() => _MessageChannelFactoryProvider.createMessageChannel();

  /** @domName MessageChannel.port1 */
  MessagePort get port1;

  /** @domName MessageChannel.port2 */
  MessagePort get port2;
}

class _MessageChannelImpl implements MessageChannel native "*MessageChannel" {

  final _MessagePortImpl port1;

  final _MessagePortImpl port2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessageEvent
abstract class MessageEvent implements Event {

  /** @domName MessageEvent.data */
  Object get data;

  /** @domName MessageEvent.lastEventId */
  String get lastEventId;

  /** @domName MessageEvent.origin */
  String get origin;

  /** @domName MessageEvent.ports */
  List get ports;

  /** @domName MessageEvent.source */
  Window get source;

  /** @domName MessageEvent.initMessageEvent */
  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, LocalWindow sourceArg, List messagePorts);

  /** @domName MessageEvent.webkitInitMessageEvent */
  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, LocalWindow sourceArg, List transferables);
}

class _MessageEventImpl extends _EventImpl implements MessageEvent native "*MessageEvent" {

  dynamic get data => _convertNativeToDart_SerializedScriptValue(this._data);
  dynamic get _data => JS("dynamic", "#.data", this);

  final String lastEventId;

  final String origin;

  final List ports;

  Window get source => _convertNativeToDart_Window(this._source);
  Window get _source => JS("Window", "#.source", this);

  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, _LocalWindowImpl sourceArg, List messagePorts) native;

  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, _LocalWindowImpl sourceArg, List transferables) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessagePort
abstract class MessagePort implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MessagePortEvents get on;

  /** @domName MessagePort.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MessagePort.close */
  void close();

  /** @domName MessagePort.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName MessagePort.postMessage */
  void postMessage(Object message, [List messagePorts]);

  /** @domName MessagePort.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MessagePort.start */
  void start();
}

abstract class MessagePortEvents implements Events {

  EventListenerList get message;
}

class _MessagePortImpl extends _EventTargetImpl implements MessagePort native "*MessagePort" {

  _MessagePortEventsImpl get on =>
    new _MessagePortEventsImpl(this);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void close() native;

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void postMessage(/*any*/ message, [messagePorts]) {
    if (?messagePorts) {
      var message_1 = _convertDartToNative_SerializedScriptValue(message);
      _postMessage_1(message_1, messagePorts);
      return;
    }
    var message_2 = _convertDartToNative_SerializedScriptValue(message);
    _postMessage_2(message_2);
    return;
  }
  void _postMessage_1(message, List messagePorts) native "postMessage";
  void _postMessage_2(message) native "postMessage";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void start() native;
}

class _MessagePortEventsImpl extends _EventsImpl implements MessagePortEvents {
  _MessagePortEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message => this['message'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMetaElement
abstract class MetaElement implements Element {

  /** @domName HTMLMetaElement.content */
  String content;

  /** @domName HTMLMetaElement.httpEquiv */
  String httpEquiv;

  /** @domName HTMLMetaElement.name */
  String name;

  /** @domName HTMLMetaElement.scheme */
  String scheme;
}

class _MetaElementImpl extends _ElementImpl implements MetaElement native "*HTMLMetaElement" {

  String content;

  String httpEquiv;

  String name;

  String scheme;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Metadata
abstract class Metadata {

  /** @domName Metadata.modificationTime */
  Date get modificationTime;

  /** @domName Metadata.size */
  int get size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void MetadataCallback(Metadata metadata);

class _MetadataImpl implements Metadata native "*Metadata" {

  final Date modificationTime;

  final int size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMeterElement
abstract class MeterElement implements Element {

  factory MeterElement() => _Elements.createMeterElement();

  /** @domName HTMLMeterElement.high */
  num high;

  /** @domName HTMLMeterElement.labels */
  List<Node> get labels;

  /** @domName HTMLMeterElement.low */
  num low;

  /** @domName HTMLMeterElement.max */
  num max;

  /** @domName HTMLMeterElement.min */
  num min;

  /** @domName HTMLMeterElement.optimum */
  num optimum;

  /** @domName HTMLMeterElement.value */
  num value;
}

class _MeterElementImpl extends _ElementImpl implements MeterElement native "*HTMLMeterElement" {

  num high;

  final List<Node> labels;

  num low;

  num max;

  num min;

  num optimum;

  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLModElement
abstract class ModElement implements Element {

  /** @domName HTMLModElement.cite */
  String cite;

  /** @domName HTMLModElement.dateTime */
  String dateTime;
}

class _ModElementImpl extends _ElementImpl implements ModElement native "*HTMLModElement" {

  String cite;

  String dateTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName MouseEvent
abstract class MouseEvent implements UIEvent {

  factory MouseEvent(String type, Window view, int detail, int screenX, int screenY,
      int clientX, int clientY, int button, [bool canBubble = true,
      bool cancelable = true, bool ctrlKey = false, bool altKey = false,
      bool shiftKey = false, bool metaKey = false,
      EventTarget relatedTarget = null]) =>
      _MouseEventFactoryProvider.createMouseEvent(
          type, view, detail, screenX, screenY,
          clientX, clientY, button, canBubble, cancelable,
          ctrlKey, altKey, shiftKey, metaKey,
          relatedTarget);


  /** @domName MouseEvent.altKey */
  bool get altKey;

  /** @domName MouseEvent.button */
  int get button;

  /** @domName MouseEvent.clientX */
  int get clientX;

  /** @domName MouseEvent.clientY */
  int get clientY;

  /** @domName MouseEvent.ctrlKey */
  bool get ctrlKey;

  /** @domName MouseEvent.dataTransfer */
  Clipboard get dataTransfer;

  /** @domName MouseEvent.fromElement */
  Node get fromElement;

  /** @domName MouseEvent.metaKey */
  bool get metaKey;

  /** @domName MouseEvent.offsetX */
  int get offsetX;

  /** @domName MouseEvent.offsetY */
  int get offsetY;

  /** @domName MouseEvent.relatedTarget */
  EventTarget get relatedTarget;

  /** @domName MouseEvent.screenX */
  int get screenX;

  /** @domName MouseEvent.screenY */
  int get screenY;

  /** @domName MouseEvent.shiftKey */
  bool get shiftKey;

  /** @domName MouseEvent.toElement */
  Node get toElement;

  /** @domName MouseEvent.webkitMovementX */
  int get webkitMovementX;

  /** @domName MouseEvent.webkitMovementY */
  int get webkitMovementY;

  /** @domName MouseEvent.x */
  int get x;

  /** @domName MouseEvent.y */
  int get y;

  /** @domName MouseEvent.initMouseEvent */
  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, LocalWindow view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MouseEventImpl extends _UIEventImpl implements MouseEvent native "*MouseEvent" {

  final bool altKey;

  final int button;

  final int clientX;

  final int clientY;

  final bool ctrlKey;

  final _ClipboardImpl dataTransfer;

  final _NodeImpl fromElement;

  final bool metaKey;

  EventTarget get relatedTarget => _convertNativeToDart_EventTarget(this._relatedTarget);
  EventTarget get _relatedTarget => JS("EventTarget", "#.relatedTarget", this);

  final int screenX;

  final int screenY;

  final bool shiftKey;

  final _NodeImpl toElement;

  final int webkitMovementX;

  final int webkitMovementY;

  final int x;

  final int y;

  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, _LocalWindowImpl view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) {
    EventTarget relatedTarget_1 = _convertDartToNative_EventTarget(relatedTarget);
    _$dom_initMouseEvent_1(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget_1);
    return;
  }
  void _$dom_initMouseEvent_1(type, canBubble, cancelable, _LocalWindowImpl view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, EventTarget relatedTarget) native "initMouseEvent";


  int get offsetX {
  if (JS('bool', '!!#.offsetX', this)) {
      return JS('int', '#.offsetX', this);
    } else {
      // Firefox does not support offsetX.
      var target = this.target;
      if (!(target is Element)) {
        throw new UnsupportedError(
            'offsetX is only supported on elements');
      }
      return this.clientX - this.target.getBoundingClientRect().left;
    }
  }

  int get offsetY {
    if (JS('bool', '!!#.offsetY', this)) {
      return JS('int', '#.offsetY', this);
    } else {
      // Firefox does not support offsetY.
      var target = this.target;
      if (!(target is Element)) {
        throw new UnsupportedError(
            'offsetY is only supported on elements');
      }
      return this.clientY - this.target.getBoundingClientRect().top;
    }
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void MutationCallback(List<MutationRecord> mutations, MutationObserver observer);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationEvent
abstract class MutationEvent implements Event {

  static const int ADDITION = 2;

  static const int MODIFICATION = 1;

  static const int REMOVAL = 3;

  /** @domName MutationEvent.attrChange */
  int get attrChange;

  /** @domName MutationEvent.attrName */
  String get attrName;

  /** @domName MutationEvent.newValue */
  String get newValue;

  /** @domName MutationEvent.prevValue */
  String get prevValue;

  /** @domName MutationEvent.relatedNode */
  Node get relatedNode;

  /** @domName MutationEvent.initMutationEvent */
  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange);
}

class _MutationEventImpl extends _EventImpl implements MutationEvent native "*MutationEvent" {

  final int attrChange;

  final String attrName;

  final String newValue;

  final String prevValue;

  final _NodeImpl relatedNode;

  void initMutationEvent(String type, bool canBubble, bool cancelable, _NodeImpl relatedNode, String prevValue, String newValue, String attrName, int attrChange) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName MutationObserver
abstract class MutationObserver {

  factory MutationObserver(MutationCallback callback) => _MutationObserverFactoryProvider.createMutationObserver(callback);

  /** @domName MutationObserver.disconnect */
  void disconnect();

  /** @domName MutationObserver.takeRecords */
  List<MutationRecord> takeRecords();

  void observe(Node target,
               {Map options,
                bool childList,
                bool attributes,
                bool characterData,
                bool subtree,
                bool attributeOldValue,
                bool characterDataOldValue,
                List<String> attributeFilter});
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MutationObserverImpl implements MutationObserver native "*MutationObserver" {

  void disconnect() native;

  void _observe(_NodeImpl target, Map options) {
    var options_1 = _convertDartToNative_Dictionary(options);
    __observe_1(target, options_1);
    return;
  }
  void __observe_1(_NodeImpl target, options) native "observe";

  List<MutationRecord> takeRecords() native;

  void observe(Node target,
               {Map options,
                bool childList,
                bool attributes,
                bool characterData,
                bool subtree,
                bool attributeOldValue,
                bool characterDataOldValue,
                List<String> attributeFilter}) {

    // Parse options into map of known type.
    var parsedOptions = _createDict();

    if (options != null) {
      options.forEach((k, v) {
          if (_boolKeys.containsKey(k)) {
            _add(parsedOptions, k, true == v);
          } else if (k == 'attributeFilter') {
            _add(parsedOptions, k, _fixupList(v));
          } else {
            throw new ArgumentError(
                "Illegal MutationObserver.observe option '$k'");
          }
        });
    }

    // Override options passed in the map with named optional arguments.
    override(key, value) {
      if (value != null) _add(parsedOptions, key, value);
    }

    override('childList', childList);
    override('attributes', attributes);
    override('characterData', characterData);
    override('subtree', subtree);
    override('attributeOldValue', attributeOldValue);
    override('characterDataOldValue', characterDataOldValue);
    if (attributeFilter != null) {
      override('attributeFilter', _fixupList(attributeFilter));
    }

    _call(target, parsedOptions);
  }

   // TODO: Change to a set when const Sets are available.
  static final _boolKeys =
    const {'childList': true,
           'attributes': true,
           'characterData': true,
           'subtree': true,
           'attributeOldValue': true,
           'characterDataOldValue': true };


  static _createDict() => JS('var', '{}');
  static _add(m, String key, value) { JS('void', '#[#] = #', m, key, value); }
  static _fixupList(list) => list;  // TODO: Ensure is a JavaScript Array.

  // Call native function with no conversions.
  _call(target, options) native 'observe';
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationRecord
abstract class MutationRecord {

  /** @domName MutationRecord.addedNodes */
  List<Node> get addedNodes;

  /** @domName MutationRecord.attributeName */
  String get attributeName;

  /** @domName MutationRecord.attributeNamespace */
  String get attributeNamespace;

  /** @domName MutationRecord.nextSibling */
  Node get nextSibling;

  /** @domName MutationRecord.oldValue */
  String get oldValue;

  /** @domName MutationRecord.previousSibling */
  Node get previousSibling;

  /** @domName MutationRecord.removedNodes */
  List<Node> get removedNodes;

  /** @domName MutationRecord.target */
  Node get target;

  /** @domName MutationRecord.type */
  String get type;
}

class _MutationRecordImpl implements MutationRecord native "*MutationRecord" {

  final List<Node> addedNodes;

  final String attributeName;

  final String attributeNamespace;

  final _NodeImpl nextSibling;

  final String oldValue;

  final _NodeImpl previousSibling;

  final List<Node> removedNodes;

  final _NodeImpl target;

  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NamedNodeMap
abstract class NamedNodeMap implements List<Node> {

  /** @domName NamedNodeMap.length */
  int get length;

  /** @domName NamedNodeMap.getNamedItem */
  Node getNamedItem(String name);

  /** @domName NamedNodeMap.getNamedItemNS */
  Node getNamedItemNS(String namespaceURI, String localName);

  /** @domName NamedNodeMap.item */
  Node item(int index);

  /** @domName NamedNodeMap.removeNamedItem */
  Node removeNamedItem(String name);

  /** @domName NamedNodeMap.removeNamedItemNS */
  Node removeNamedItemNS(String namespaceURI, String localName);

  /** @domName NamedNodeMap.setNamedItem */
  Node setNamedItem(Node node);

  /** @domName NamedNodeMap.setNamedItemNS */
  Node setNamedItemNS(Node node);
}

class _NamedNodeMapImpl implements NamedNodeMap, JavaScriptIndexingBehavior native "*NamedNodeMap" {

  final int length;

  _NodeImpl operator[](int index) => JS("_NodeImpl", "#[#]", this, index);

  void operator[]=(int index, _NodeImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Node element) => _Collections.contains(this, element);

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     _Collections.filter(this, <Node>[], f);

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Node>:

  void sort([Comparator<Node> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Node get last => this[length - 1];

  Node removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  _NodeImpl getNamedItem(String name) native;

  _NodeImpl getNamedItemNS(String namespaceURI, String localName) native;

  _NodeImpl item(int index) native;

  _NodeImpl removeNamedItem(String name) native;

  _NodeImpl removeNamedItemNS(String namespaceURI, String localName) native;

  _NodeImpl setNamedItem(_NodeImpl node) native;

  _NodeImpl setNamedItemNS(_NodeImpl node) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Navigator
abstract class Navigator {

  /** @domName Navigator.appCodeName */
  String get appCodeName;

  /** @domName Navigator.appName */
  String get appName;

  /** @domName Navigator.appVersion */
  String get appVersion;

  /** @domName Navigator.cookieEnabled */
  bool get cookieEnabled;

  /** @domName Navigator.geolocation */
  Geolocation get geolocation;

  /** @domName Navigator.language */
  String get language;

  /** @domName Navigator.mimeTypes */
  DOMMimeTypeArray get mimeTypes;

  /** @domName Navigator.onLine */
  bool get onLine;

  /** @domName Navigator.platform */
  String get platform;

  /** @domName Navigator.plugins */
  DOMPluginArray get plugins;

  /** @domName Navigator.product */
  String get product;

  /** @domName Navigator.productSub */
  String get productSub;

  /** @domName Navigator.userAgent */
  String get userAgent;

  /** @domName Navigator.vendor */
  String get vendor;

  /** @domName Navigator.vendorSub */
  String get vendorSub;

  /** @domName Navigator.webkitBattery */
  BatteryManager get webkitBattery;

  /** @domName Navigator.getStorageUpdates */
  void getStorageUpdates();

  /** @domName Navigator.javaEnabled */
  bool javaEnabled();

  /** @domName Navigator.webkitGetGamepads */
  List<Gamepad> webkitGetGamepads();

  /** @domName Navigator.webkitGetUserMedia */
  void webkitGetUserMedia(Map options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback]);
}

class _NavigatorImpl implements Navigator native "*Navigator" {

  final String appCodeName;

  final String appName;

  final String appVersion;

  final bool cookieEnabled;

  final _GeolocationImpl geolocation;

  final String language;

  final _DOMMimeTypeArrayImpl mimeTypes;

  final bool onLine;

  final String platform;

  final _DOMPluginArrayImpl plugins;

  final String product;

  final String productSub;

  final String userAgent;

  final String vendor;

  final String vendorSub;

  final _BatteryManagerImpl webkitBattery;

  void getStorageUpdates() native;

  bool javaEnabled() native;

  _GamepadListImpl webkitGetGamepads() native;

  void webkitGetUserMedia(Map options, NavigatorUserMediaSuccessCallback successCallback, [errorCallback]) {
    if (?errorCallback) {
      var options_1 = _convertDartToNative_Dictionary(options);
      _webkitGetUserMedia_1(options_1, successCallback, errorCallback);
      return;
    }
    var options_2 = _convertDartToNative_Dictionary(options);
    _webkitGetUserMedia_2(options_2, successCallback);
    return;
  }
  void _webkitGetUserMedia_1(options, NavigatorUserMediaSuccessCallback successCallback, NavigatorUserMediaErrorCallback errorCallback) native "webkitGetUserMedia";
  void _webkitGetUserMedia_2(options, NavigatorUserMediaSuccessCallback successCallback) native "webkitGetUserMedia";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NavigatorUserMediaError
abstract class NavigatorUserMediaError {

  static const int PERMISSION_DENIED = 1;

  /** @domName NavigatorUserMediaError.code */
  int get code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);

class _NavigatorUserMediaErrorImpl implements NavigatorUserMediaError native "*NavigatorUserMediaError" {

  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void NavigatorUserMediaSuccessCallback(LocalMediaStream stream);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName Node
abstract class Node implements EventTarget {
  List<Node> get nodes;

  void set nodes(Collection<Node> value);

  /**
   * Replaces this node with another node.
   * @domName Node.replaceChild
   */
  Node replaceWith(Node otherNode);

  /**
   * Removes this node from the DOM.
   * @domName Node.removeChild
   */
  void remove();


  static const int ATTRIBUTE_NODE = 2;

  static const int CDATA_SECTION_NODE = 4;

  static const int COMMENT_NODE = 8;

  static const int DOCUMENT_FRAGMENT_NODE = 11;

  static const int DOCUMENT_NODE = 9;

  static const int DOCUMENT_POSITION_CONTAINED_BY = 0x10;

  static const int DOCUMENT_POSITION_CONTAINS = 0x08;

  static const int DOCUMENT_POSITION_DISCONNECTED = 0x01;

  static const int DOCUMENT_POSITION_FOLLOWING = 0x04;

  static const int DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

  static const int DOCUMENT_POSITION_PRECEDING = 0x02;

  static const int DOCUMENT_TYPE_NODE = 10;

  static const int ELEMENT_NODE = 1;

  static const int ENTITY_NODE = 6;

  static const int ENTITY_REFERENCE_NODE = 5;

  static const int NOTATION_NODE = 12;

  static const int PROCESSING_INSTRUCTION_NODE = 7;

  static const int TEXT_NODE = 3;

  /** @domName Node.attributes */
  NamedNodeMap get $dom_attributes;

  /** @domName Node.childNodes */
  List<Node> get $dom_childNodes;

  /** @domName Node.firstChild */
  Node get $dom_firstChild;

  /** @domName Node.lastChild */
  Node get $dom_lastChild;

  /** @domName Node.nextSibling */
  Node get nextNode;

  /** @domName Node.nodeType */
  int get $dom_nodeType;

  /** @domName Node.ownerDocument */
  Document get document;

  /** @domName Node.parentNode */
  Node get parent;

  /** @domName Node.previousSibling */
  Node get previousNode;

  /** @domName Node.textContent */
  String text;

  /** @domName Node.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Node.appendChild */
  Node $dom_appendChild(Node newChild);

  /** @domName Node.cloneNode */
  Node clone(bool deep);

  /** @domName Node.contains */
  bool contains(Node other);

  /** @domName Node.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName Node.hasChildNodes */
  bool hasChildNodes();

  /** @domName Node.insertBefore */
  Node insertBefore(Node newChild, Node refChild);

  /** @domName Node.removeChild */
  Node $dom_removeChild(Node oldChild);

  /** @domName Node.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Node.replaceChild */
  Node $dom_replaceChild(Node newChild, Node oldChild);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeFilter
abstract class NodeFilter {

  static const int FILTER_ACCEPT = 1;

  static const int FILTER_REJECT = 2;

  static const int FILTER_SKIP = 3;

  static const int SHOW_ALL = 0xFFFFFFFF;

  static const int SHOW_ATTRIBUTE = 0x00000002;

  static const int SHOW_CDATA_SECTION = 0x00000008;

  static const int SHOW_COMMENT = 0x00000080;

  static const int SHOW_DOCUMENT = 0x00000100;

  static const int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  static const int SHOW_DOCUMENT_TYPE = 0x00000200;

  static const int SHOW_ELEMENT = 0x00000001;

  static const int SHOW_ENTITY = 0x00000020;

  static const int SHOW_ENTITY_REFERENCE = 0x00000010;

  static const int SHOW_NOTATION = 0x00000800;

  static const int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  static const int SHOW_TEXT = 0x00000004;

  /** @domName NodeFilter.acceptNode */
  int acceptNode(Node n);
}

class _NodeFilterImpl implements NodeFilter native "*NodeFilter" {

  int acceptNode(_NodeImpl n) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Lazy implementation of the child nodes of an element that does not request
 * the actual child nodes of an element until strictly necessary greatly
 * improving performance for the typical cases where it is not required.
 */
class _ChildNodeListLazy implements List {
  final _NodeImpl _this;

  _ChildNodeListLazy(this._this);


  _NodeImpl get first => JS('_NodeImpl', '#.firstChild', _this);
  _NodeImpl get last => JS('_NodeImpl', '#.lastChild', _this);

  void add(_NodeImpl value) {
    _this.$dom_appendChild(value);
  }

  void addLast(_NodeImpl value) {
    _this.$dom_appendChild(value);
  }


  void addAll(Collection<_NodeImpl> collection) {
    for (_NodeImpl node in collection) {
      _this.$dom_appendChild(node);
    }
  }

  _NodeImpl removeLast() {
    final result = last;
    if (result != null) {
      _this.$dom_removeChild(result);
    }
    return result;
  }

  void clear() {
    _this.text = '';
  }

  void operator []=(int index, _NodeImpl value) {
    _this.$dom_replaceChild(value, this[index]);
  }

  Iterator<Node> iterator() => _this.$dom_childNodes.iterator();

  // TODO(jacobr): We can implement these methods much more efficiently by
  // looking up the nodeList only once instead of once per iteration.
  bool contains(Node element) => _Collections.contains(this, element);

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     new _NodeListWrapper(_Collections.filter(this, <Node>[], f));

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Node>:

  // TODO(jacobr): this could be implemented for child node lists.
  // The exception we throw here is misleading.
  void sort([Comparator<Node> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      _Lists.lastIndexOf(this, element, start);

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError(
        "Cannot setRange on immutable List.");
  }
  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError(
        "Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError(
        "Cannot insertRange on immutable List.");
  }
  List<Node> getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_Lists.getRange(this, start, rangeLength, <Node>[]));

  // -- end List<Node> mixins.

  // TODO(jacobr): benchmark whether this is more efficient or whether caching
  // a local copy of $dom_childNodes is more efficient.
  int get length => _this.$dom_childNodes.length;

  _NodeImpl operator[](int index) => _this.$dom_childNodes[index];
}

class _NodeImpl extends _EventTargetImpl implements Node native "*Node" {
  _ChildNodeListLazy get nodes {
    return new _ChildNodeListLazy(this);
  }

  void set nodes(Collection<Node> value) {
    // Copy list first since we don't want liveness during iteration.
    // TODO(jacobr): there is a better way to do this.
    List copy = new List.from(value);
    text = '';
    for (Node node in copy) {
      $dom_appendChild(node);
    }
  }

  // TODO(jacobr): should we throw an exception if parent is already null?
  // TODO(vsm): Use the native remove when available.
  void remove() {
    if (this.parent != null) {
      final _NodeImpl parent = this.parent;
      parent.$dom_removeChild(this);
    }
  }

  _NodeImpl replaceWith(Node otherNode) {
    try {
      final _NodeImpl parent = this.parent;
      parent.$dom_replaceChild(otherNode, this);
    } catch (e) {

    };
    return this;
  }


  _NamedNodeMapImpl get $dom_attributes => JS("_NamedNodeMapImpl", "#.attributes", this);

  List<Node> get $dom_childNodes => JS("List<Node>", "#.childNodes", this);

  _NodeImpl get $dom_firstChild => JS("_NodeImpl", "#.firstChild", this);

  _NodeImpl get $dom_lastChild => JS("_NodeImpl", "#.lastChild", this);

  _NodeImpl get nextNode => JS("_NodeImpl", "#.nextSibling", this);

  int get $dom_nodeType => JS("int", "#.nodeType", this);

  _DocumentImpl get document => JS("_DocumentImpl", "#.ownerDocument", this);

  _NodeImpl get parent => JS("_NodeImpl", "#.parentNode", this);

  _NodeImpl get previousNode => JS("_NodeImpl", "#.previousSibling", this);

  String get text => JS("String", "#.textContent", this);

  void set text(String value) {
    JS("void", "#.textContent = #", this, value);
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  _NodeImpl $dom_appendChild(_NodeImpl newChild) native "appendChild";

  _NodeImpl clone(bool deep) native "cloneNode";

  bool contains(_NodeImpl other) native;

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  bool hasChildNodes() native;

  _NodeImpl insertBefore(_NodeImpl newChild, _NodeImpl refChild) native;

  _NodeImpl $dom_removeChild(_NodeImpl oldChild) native "removeChild";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  _NodeImpl $dom_replaceChild(_NodeImpl newChild, _NodeImpl oldChild) native "replaceChild";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeIterator
abstract class NodeIterator {

  /** @domName NodeIterator.expandEntityReferences */
  bool get expandEntityReferences;

  /** @domName NodeIterator.filter */
  NodeFilter get filter;

  /** @domName NodeIterator.pointerBeforeReferenceNode */
  bool get pointerBeforeReferenceNode;

  /** @domName NodeIterator.referenceNode */
  Node get referenceNode;

  /** @domName NodeIterator.root */
  Node get root;

  /** @domName NodeIterator.whatToShow */
  int get whatToShow;

  /** @domName NodeIterator.detach */
  void detach();

  /** @domName NodeIterator.nextNode */
  Node nextNode();

  /** @domName NodeIterator.previousNode */
  Node previousNode();
}

class _NodeIteratorImpl implements NodeIterator native "*NodeIterator" {

  final bool expandEntityReferences;

  final _NodeFilterImpl filter;

  final bool pointerBeforeReferenceNode;

  final _NodeImpl referenceNode;

  final _NodeImpl root;

  final int whatToShow;

  void detach() native;

  _NodeImpl nextNode() native;

  _NodeImpl previousNode() native;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName NodeList
abstract class NodeList implements List<Node> {

  List<Node> filter(bool f(Node element));

  List<Node> getRange(int start, int length);

  Node get first;


  /** @domName NodeList.length */
  int get length;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(nweiz): when all implementations we target have the same name for the
// coreimpl implementation of List<E>, extend that rather than wrapping.
class _ListWrapper<E> implements List<E> {
  List _list;

  _ListWrapper(List this._list);

  Iterator<E> iterator() => _list.iterator();

  bool contains(E element) => _list.contains(element);

  void forEach(void f(E element)) => _list.forEach(f);

  Collection map(f(E element)) => _list.map(f);

  List<E> filter(bool f(E element)) => _list.filter(f);

  bool every(bool f(E element)) => _list.every(f);

  bool some(bool f(E element)) => _list.some(f);

  bool get isEmpty => _list.isEmpty;

  int get length => _list.length;

  E operator [](int index) => _list[index];

  void operator []=(int index, E value) { _list[index] = value; }

  void set length(int newLength) { _list.length = newLength; }

  void add(E value) => _list.add(value);

  void addLast(E value) => _list.addLast(value);

  void addAll(Collection<E> collection) => _list.addAll(collection);

  void sort([Comparator<E> compare = Comparable.compare]) => _list.sort(compare);

  int indexOf(E element, [int start = 0]) => _list.indexOf(element, start);

  int lastIndexOf(E element, [int start = 0]) =>
    _list.lastIndexOf(element, start);

  void clear() => _list.clear();

  E removeLast() => _list.removeLast();

  E get last => _list.last;

  List<E> getRange(int start, int rangeLength) =>
    _list.getRange(start, rangeLength);

  void setRange(int start, int rangeLength, List<E> from, [int startFrom = 0])
      => _list.setRange(start, rangeLength, from, startFrom);

  void removeRange(int start, int rangeLength) =>
    _list.removeRange(start, rangeLength);

  void insertRange(int start, int rangeLength, [E initialValue = null]) =>
    _list.insertRange(start, rangeLength, initialValue);

  E get first => _list[0];
}

/**
 * This class is used to insure the results of list operations are NodeLists
 * instead of lists.
 */
class _NodeListWrapper extends _ListWrapper<Node> implements List {
  _NodeListWrapper(List list) : super(list);

  List<Node> filter(bool f(Node element)) =>
    new _NodeListWrapper(_list.filter(f));

  List<Node> getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_list.getRange(start, rangeLength));
}

class _NodeListImpl implements NodeList, JavaScriptIndexingBehavior native "*NodeList" {
  _NodeImpl _parent;

  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(_NodeImpl value) {
    _parent.$dom_appendChild(value);
  }

  void addLast(_NodeImpl value) {
    _parent.$dom_appendChild(value);
  }

  void addAll(Collection<_NodeImpl> collection) {
    for (_NodeImpl node in collection) {
      _parent.$dom_appendChild(node);
    }
  }

  _NodeImpl removeLast() {
    final result = this.last;
    if (result != null) {
      _parent.$dom_removeChild(result);
    }
    return result;
  }

  void clear() {
    _parent.text = '';
  }

  void operator []=(int index, _NodeImpl value) {
    _parent.$dom_replaceChild(value, this[index]);
  }

  bool contains(Node element) => _Collections.contains(this, element);

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     new _NodeListWrapper(_Collections.filter(this, <Node>[], f));

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Node>:

  void sort([Comparator<Node> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      _Lists.lastIndexOf(this, element, start);

  Node get last => this[length - 1];
  Node get first => this[0];

  // FIXME: implement thesee.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }
  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }
  List<Node> getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_Lists.getRange(this, start, rangeLength, <Node>[]));

  // -- end List<Node> mixins.


  final int length;

  _NodeImpl operator[](int index) => JS("_NodeImpl", "#[#]", this, index);

  _NodeImpl _item(int index) native "item";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Notation
abstract class Notation implements Node {

  /** @domName Notation.publicId */
  String get publicId;

  /** @domName Notation.systemId */
  String get systemId;
}

class _NotationImpl extends _NodeImpl implements Notation native "*Notation" {

  final String publicId;

  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Notification
abstract class Notification implements EventTarget {

  factory Notification(String title, [Map options]) {
    if (!?options) {
      return _NotificationFactoryProvider.createNotification(title);
    }
    return _NotificationFactoryProvider.createNotification(title, options);
  }

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  NotificationEvents get on;

  /** @domName Notification.dir */
  String dir;

  /** @domName Notification.permission */
  String get permission;

  /** @domName Notification.replaceId */
  String replaceId;

  /** @domName Notification.tag */
  String tag;

  /** @domName Notification.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Notification.cancel */
  void cancel();

  /** @domName Notification.close */
  void close();

  /** @domName Notification.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName Notification.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Notification.requestPermission */
  static final requestPermission = _NotificationImpl.requestPermission;

  /** @domName Notification.show */
  void show();
}

abstract class NotificationEvents implements Events {

  EventListenerList get click;

  EventListenerList get close;

  EventListenerList get display;

  EventListenerList get error;

  EventListenerList get show;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NotificationCenter
abstract class NotificationCenter {

  /** @domName NotificationCenter.checkPermission */
  int checkPermission();

  /** @domName NotificationCenter.createHTMLNotification */
  Notification createHTMLNotification(String url);

  /** @domName NotificationCenter.createNotification */
  Notification createNotification(String iconUrl, String title, String body);

  /** @domName NotificationCenter.requestPermission */
  void requestPermission(VoidCallback callback);
}

class _NotificationCenterImpl implements NotificationCenter native "*NotificationCenter" {

  int checkPermission() native;

  _NotificationImpl createHTMLNotification(String url) native;

  _NotificationImpl createNotification(String iconUrl, String title, String body) native;

  void requestPermission(VoidCallback callback) native;
}

class _NotificationImpl extends _EventTargetImpl implements Notification native "*Notification" {

  _NotificationEventsImpl get on =>
    new _NotificationEventsImpl(this);

  String dir;

  final String permission;

  String replaceId;

  String tag;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void cancel() native;

  void close() native;

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  static void requestPermission(NotificationPermissionCallback callback) native;

  void show() native;
}

class _NotificationEventsImpl extends _EventsImpl implements NotificationEvents {
  _NotificationEventsImpl(_ptr) : super(_ptr);

  EventListenerList get click => this['click'];

  EventListenerList get close => this['close'];

  EventListenerList get display => this['display'];

  EventListenerList get error => this['error'];

  EventListenerList get show => this['show'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void NotificationPermissionCallback(String permission);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESElementIndexUint
abstract class OESElementIndexUint {
}

class _OESElementIndexUintImpl implements OESElementIndexUint native "*OESElementIndexUint" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESStandardDerivatives
abstract class OESStandardDerivatives {

  static const int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;
}

class _OESStandardDerivativesImpl implements OESStandardDerivatives native "*OESStandardDerivatives" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESTextureFloat
abstract class OESTextureFloat {
}

class _OESTextureFloatImpl implements OESTextureFloat native "*OESTextureFloat" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESVertexArrayObject
abstract class OESVertexArrayObject {

  static const int VERTEX_ARRAY_BINDING_OES = 0x85B5;

  /** @domName OESVertexArrayObject.bindVertexArrayOES */
  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  /** @domName OESVertexArrayObject.createVertexArrayOES */
  WebGLVertexArrayObjectOES createVertexArrayOES();

  /** @domName OESVertexArrayObject.deleteVertexArrayOES */
  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  /** @domName OESVertexArrayObject.isVertexArrayOES */
  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);
}

class _OESVertexArrayObjectImpl implements OESVertexArrayObject native "*OESVertexArrayObject" {

  void bindVertexArrayOES(_WebGLVertexArrayObjectOESImpl arrayObject) native;

  _WebGLVertexArrayObjectOESImpl createVertexArrayOES() native;

  void deleteVertexArrayOES(_WebGLVertexArrayObjectOESImpl arrayObject) native;

  bool isVertexArrayOES(_WebGLVertexArrayObjectOESImpl arrayObject) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOListElement
abstract class OListElement implements Element {

  factory OListElement() => _Elements.createOListElement();

  /** @domName HTMLOListElement.compact */
  bool compact;

  /** @domName HTMLOListElement.reversed */
  bool reversed;

  /** @domName HTMLOListElement.start */
  int start;

  /** @domName HTMLOListElement.type */
  String type;
}

class _OListElementImpl extends _ElementImpl implements OListElement native "*HTMLOListElement" {

  bool compact;

  bool reversed;

  int start;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLObjectElement
abstract class ObjectElement implements Element {

  factory ObjectElement() => _Elements.createObjectElement();

  /** @domName HTMLObjectElement.align */
  String align;

  /** @domName HTMLObjectElement.archive */
  String archive;

  /** @domName HTMLObjectElement.border */
  String border;

  /** @domName HTMLObjectElement.code */
  String code;

  /** @domName HTMLObjectElement.codeBase */
  String codeBase;

  /** @domName HTMLObjectElement.codeType */
  String codeType;

  /** @domName HTMLObjectElement.data */
  String data;

  /** @domName HTMLObjectElement.declare */
  bool declare;

  /** @domName HTMLObjectElement.form */
  FormElement get form;

  /** @domName HTMLObjectElement.height */
  String height;

  /** @domName HTMLObjectElement.hspace */
  int hspace;

  /** @domName HTMLObjectElement.name */
  String name;

  /** @domName HTMLObjectElement.standby */
  String standby;

  /** @domName HTMLObjectElement.type */
  String type;

  /** @domName HTMLObjectElement.useMap */
  String useMap;

  /** @domName HTMLObjectElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLObjectElement.validity */
  ValidityState get validity;

  /** @domName HTMLObjectElement.vspace */
  int vspace;

  /** @domName HTMLObjectElement.width */
  String width;

  /** @domName HTMLObjectElement.willValidate */
  bool get willValidate;

  /** @domName HTMLObjectElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLObjectElement.setCustomValidity */
  void setCustomValidity(String error);
}

class _ObjectElementImpl extends _ElementImpl implements ObjectElement native "*HTMLObjectElement" {

  String align;

  String archive;

  String border;

  String code;

  String codeBase;

  String codeType;

  String data;

  bool declare;

  final _FormElementImpl form;

  String height;

  int hspace;

  String name;

  String standby;

  String type;

  String useMap;

  final String validationMessage;

  final _ValidityStateImpl validity;

  int vspace;

  String width;

  final bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OfflineAudioCompletionEvent
abstract class OfflineAudioCompletionEvent implements Event {

  /** @domName OfflineAudioCompletionEvent.renderedBuffer */
  AudioBuffer get renderedBuffer;
}

class _OfflineAudioCompletionEventImpl extends _EventImpl implements OfflineAudioCompletionEvent native "*OfflineAudioCompletionEvent" {

  final _AudioBufferImpl renderedBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptGroupElement
abstract class OptGroupElement implements Element {

  factory OptGroupElement() => _Elements.createOptGroupElement();

  /** @domName HTMLOptGroupElement.disabled */
  bool disabled;

  /** @domName HTMLOptGroupElement.label */
  String label;
}

class _OptGroupElementImpl extends _ElementImpl implements OptGroupElement native "*HTMLOptGroupElement" {

  bool disabled;

  String label;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptionElement
abstract class OptionElement implements Element {

  factory OptionElement([String data, String value, bool defaultSelected, bool selected]) {
    if (!?data) {
      return _OptionElementFactoryProvider.createOptionElement();
    }
    if (!?value) {
      return _OptionElementFactoryProvider.createOptionElement(data);
    }
    if (!?defaultSelected) {
      return _OptionElementFactoryProvider.createOptionElement(data, value);
    }
    if (!?selected) {
      return _OptionElementFactoryProvider.createOptionElement(data, value, defaultSelected);
    }
    return _OptionElementFactoryProvider.createOptionElement(data, value, defaultSelected, selected);
  }

  /** @domName HTMLOptionElement.defaultSelected */
  bool defaultSelected;

  /** @domName HTMLOptionElement.disabled */
  bool disabled;

  /** @domName HTMLOptionElement.form */
  FormElement get form;

  /** @domName HTMLOptionElement.index */
  int get index;

  /** @domName HTMLOptionElement.label */
  String label;

  /** @domName HTMLOptionElement.selected */
  bool selected;

  /** @domName HTMLOptionElement.value */
  String value;
}

class _OptionElementImpl extends _ElementImpl implements OptionElement native "*HTMLOptionElement" {

  bool defaultSelected;

  bool disabled;

  final _FormElementImpl form;

  final int index;

  String label;

  bool selected;

  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OscillatorNode
abstract class OscillatorNode implements AudioSourceNode {

  static const int CUSTOM = 4;

  static const int FINISHED_STATE = 3;

  static const int PLAYING_STATE = 2;

  static const int SAWTOOTH = 2;

  static const int SCHEDULED_STATE = 1;

  static const int SINE = 0;

  static const int SQUARE = 1;

  static const int TRIANGLE = 3;

  static const int UNSCHEDULED_STATE = 0;

  /** @domName OscillatorNode.detune */
  AudioParam get detune;

  /** @domName OscillatorNode.frequency */
  AudioParam get frequency;

  /** @domName OscillatorNode.playbackState */
  int get playbackState;

  /** @domName OscillatorNode.type */
  int type;

  /** @domName OscillatorNode.setWaveTable */
  void setWaveTable(WaveTable waveTable);

  /** @domName OscillatorNode.start */
  void start(num when);

  /** @domName OscillatorNode.stop */
  void stop(num when);
}

class _OscillatorNodeImpl extends _AudioSourceNodeImpl implements OscillatorNode native "*OscillatorNode" {

  final _AudioParamImpl detune;

  final _AudioParamImpl frequency;

  final int playbackState;

  int type;

  void setWaveTable(_WaveTableImpl waveTable) native;

  void start(num when) native;

  void stop(num when) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOutputElement
abstract class OutputElement implements Element {

  factory OutputElement() => _Elements.createOutputElement();

  /** @domName HTMLOutputElement.defaultValue */
  String defaultValue;

  /** @domName HTMLOutputElement.form */
  FormElement get form;

  /** @domName HTMLOutputElement.htmlFor */
  DOMSettableTokenList htmlFor;

  /** @domName HTMLOutputElement.labels */
  List<Node> get labels;

  /** @domName HTMLOutputElement.name */
  String name;

  /** @domName HTMLOutputElement.type */
  String get type;

  /** @domName HTMLOutputElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLOutputElement.validity */
  ValidityState get validity;

  /** @domName HTMLOutputElement.value */
  String value;

  /** @domName HTMLOutputElement.willValidate */
  bool get willValidate;

  /** @domName HTMLOutputElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLOutputElement.setCustomValidity */
  void setCustomValidity(String error);
}

class _OutputElementImpl extends _ElementImpl implements OutputElement native "*HTMLOutputElement" {

  String defaultValue;

  final _FormElementImpl form;

  _DOMSettableTokenListImpl htmlFor;

  final List<Node> labels;

  String name;

  final String type;

  final String validationMessage;

  final _ValidityStateImpl validity;

  String value;

  final bool willValidate;

  bool checkValidity() native;

  void setCustomValidity(String error) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OverflowEvent
abstract class OverflowEvent implements Event {

  static const int BOTH = 2;

  static const int HORIZONTAL = 0;

  static const int VERTICAL = 1;

  /** @domName OverflowEvent.horizontalOverflow */
  bool get horizontalOverflow;

  /** @domName OverflowEvent.orient */
  int get orient;

  /** @domName OverflowEvent.verticalOverflow */
  bool get verticalOverflow;
}

class _OverflowEventImpl extends _EventImpl implements OverflowEvent native "*OverflowEvent" {

  final bool horizontalOverflow;

  final int orient;

  final bool verticalOverflow;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PagePopupController
abstract class PagePopupController {

  /** @domName PagePopupController.localizeNumberString */
  String localizeNumberString(String numberString);

  /** @domName PagePopupController.setValueAndClosePopup */
  void setValueAndClosePopup(int numberValue, String stringValue);
}

class _PagePopupControllerImpl implements PagePopupController native "*PagePopupController" {

  String localizeNumberString(String numberString) native;

  void setValueAndClosePopup(int numberValue, String stringValue) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PageTransitionEvent
abstract class PageTransitionEvent implements Event {

  /** @domName PageTransitionEvent.persisted */
  bool get persisted;
}

class _PageTransitionEventImpl extends _EventImpl implements PageTransitionEvent native "*PageTransitionEvent" {

  final bool persisted;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PannerNode
abstract class PannerNode implements AudioNode {

  static const int EQUALPOWER = 0;

  static const int EXPONENTIAL_DISTANCE = 2;

  static const int HRTF = 1;

  static const int INVERSE_DISTANCE = 1;

  static const int LINEAR_DISTANCE = 0;

  static const int SOUNDFIELD = 2;

  /** @domName PannerNode.coneGain */
  AudioGain get coneGain;

  /** @domName PannerNode.coneInnerAngle */
  num coneInnerAngle;

  /** @domName PannerNode.coneOuterAngle */
  num coneOuterAngle;

  /** @domName PannerNode.coneOuterGain */
  num coneOuterGain;

  /** @domName PannerNode.distanceGain */
  AudioGain get distanceGain;

  /** @domName PannerNode.distanceModel */
  int distanceModel;

  /** @domName PannerNode.maxDistance */
  num maxDistance;

  /** @domName PannerNode.panningModel */
  int panningModel;

  /** @domName PannerNode.refDistance */
  num refDistance;

  /** @domName PannerNode.rolloffFactor */
  num rolloffFactor;

  /** @domName PannerNode.setOrientation */
  void setOrientation(num x, num y, num z);

  /** @domName PannerNode.setPosition */
  void setPosition(num x, num y, num z);

  /** @domName PannerNode.setVelocity */
  void setVelocity(num x, num y, num z);
}

class _PannerNodeImpl extends _AudioNodeImpl implements PannerNode native "*PannerNode" {

  final _AudioGainImpl coneGain;

  num coneInnerAngle;

  num coneOuterAngle;

  num coneOuterGain;

  final _AudioGainImpl distanceGain;

  int distanceModel;

  num maxDistance;

  int panningModel;

  num refDistance;

  num rolloffFactor;

  void setOrientation(num x, num y, num z) native;

  void setPosition(num x, num y, num z) native;

  void setVelocity(num x, num y, num z) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLParagraphElement
abstract class ParagraphElement implements Element {

  factory ParagraphElement() => _Elements.createParagraphElement();

  /** @domName HTMLParagraphElement.align */
  String align;
}

class _ParagraphElementImpl extends _ElementImpl implements ParagraphElement native "*HTMLParagraphElement" {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLParamElement
abstract class ParamElement implements Element {

  factory ParamElement() => _Elements.createParamElement();

  /** @domName HTMLParamElement.name */
  String name;

  /** @domName HTMLParamElement.type */
  String type;

  /** @domName HTMLParamElement.value */
  String value;

  /** @domName HTMLParamElement.valueType */
  String valueType;
}

class _ParamElementImpl extends _ElementImpl implements ParamElement native "*HTMLParamElement" {

  String name;

  String type;

  String value;

  String valueType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PeerConnection00
abstract class PeerConnection00 implements EventTarget {

  factory PeerConnection00(String serverConfiguration, IceCallback iceCallback) => _PeerConnection00FactoryProvider.createPeerConnection00(serverConfiguration, iceCallback);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  PeerConnection00Events get on;

  static const int ACTIVE = 2;

  static const int CLOSED = 3;

  static const int ICE_CHECKING = 0x300;

  static const int ICE_CLOSED = 0x700;

  static const int ICE_COMPLETED = 0x500;

  static const int ICE_CONNECTED = 0x400;

  static const int ICE_FAILED = 0x600;

  static const int ICE_GATHERING = 0x100;

  static const int ICE_WAITING = 0x200;

  static const int NEW = 0;

  static const int OPENING = 1;

  static const int SDP_ANSWER = 0x300;

  static const int SDP_OFFER = 0x100;

  static const int SDP_PRANSWER = 0x200;

  /** @domName PeerConnection00.iceState */
  int get iceState;

  /** @domName PeerConnection00.localDescription */
  SessionDescription get localDescription;

  /** @domName PeerConnection00.localStreams */
  List<MediaStream> get localStreams;

  /** @domName PeerConnection00.readyState */
  int get readyState;

  /** @domName PeerConnection00.remoteDescription */
  SessionDescription get remoteDescription;

  /** @domName PeerConnection00.remoteStreams */
  List<MediaStream> get remoteStreams;

  /** @domName PeerConnection00.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName PeerConnection00.addStream */
  void addStream(MediaStream stream, [Map mediaStreamHints]);

  /** @domName PeerConnection00.close */
  void close();

  /** @domName PeerConnection00.createAnswer */
  SessionDescription createAnswer(String offer, [Map mediaHints]);

  /** @domName PeerConnection00.createOffer */
  SessionDescription createOffer([Map mediaHints]);

  /** @domName PeerConnection00.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName PeerConnection00.processIceMessage */
  void processIceMessage(IceCandidate candidate);

  /** @domName PeerConnection00.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName PeerConnection00.removeStream */
  void removeStream(MediaStream stream);

  /** @domName PeerConnection00.setLocalDescription */
  void setLocalDescription(int action, SessionDescription desc);

  /** @domName PeerConnection00.setRemoteDescription */
  void setRemoteDescription(int action, SessionDescription desc);

  /** @domName PeerConnection00.startIce */
  void startIce([Map iceOptions]);
}

abstract class PeerConnection00Events implements Events {

  EventListenerList get addStream;

  EventListenerList get connecting;

  EventListenerList get open;

  EventListenerList get removeStream;

  EventListenerList get stateChange;
}

class _PeerConnection00Impl extends _EventTargetImpl implements PeerConnection00 native "*PeerConnection00" {

  _PeerConnection00EventsImpl get on =>
    new _PeerConnection00EventsImpl(this);

  final int iceState;

  final _SessionDescriptionImpl localDescription;

  final _MediaStreamListImpl localStreams;

  final int readyState;

  final _SessionDescriptionImpl remoteDescription;

  final _MediaStreamListImpl remoteStreams;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void addStream(_MediaStreamImpl stream, [mediaStreamHints]) {
    if (?mediaStreamHints) {
      var mediaStreamHints_1 = _convertDartToNative_Dictionary(mediaStreamHints);
      _addStream_1(stream, mediaStreamHints_1);
      return;
    }
    _addStream_2(stream);
    return;
  }
  void _addStream_1(_MediaStreamImpl stream, mediaStreamHints) native "addStream";
  void _addStream_2(_MediaStreamImpl stream) native "addStream";

  void close() native;

  _SessionDescriptionImpl createAnswer(String offer, [mediaHints]) {
    if (?mediaHints) {
      var mediaHints_1 = _convertDartToNative_Dictionary(mediaHints);
      return _createAnswer_1(offer, mediaHints_1);
    }
    return _createAnswer_2(offer);
  }
  _SessionDescriptionImpl _createAnswer_1(offer, mediaHints) native "createAnswer";
  _SessionDescriptionImpl _createAnswer_2(offer) native "createAnswer";

  _SessionDescriptionImpl createOffer([mediaHints]) {
    if (?mediaHints) {
      var mediaHints_1 = _convertDartToNative_Dictionary(mediaHints);
      return _createOffer_1(mediaHints_1);
    }
    return _createOffer_2();
  }
  _SessionDescriptionImpl _createOffer_1(mediaHints) native "createOffer";
  _SessionDescriptionImpl _createOffer_2() native "createOffer";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void processIceMessage(_IceCandidateImpl candidate) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void removeStream(_MediaStreamImpl stream) native;

  void setLocalDescription(int action, _SessionDescriptionImpl desc) native;

  void setRemoteDescription(int action, _SessionDescriptionImpl desc) native;

  void startIce([iceOptions]) {
    if (?iceOptions) {
      var iceOptions_1 = _convertDartToNative_Dictionary(iceOptions);
      _startIce_1(iceOptions_1);
      return;
    }
    _startIce_2();
    return;
  }
  void _startIce_1(iceOptions) native "startIce";
  void _startIce_2() native "startIce";
}

class _PeerConnection00EventsImpl extends _EventsImpl implements PeerConnection00Events {
  _PeerConnection00EventsImpl(_ptr) : super(_ptr);

  EventListenerList get addStream => this['addstream'];

  EventListenerList get connecting => this['connecting'];

  EventListenerList get open => this['open'];

  EventListenerList get removeStream => this['removestream'];

  EventListenerList get stateChange => this['statechange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Performance
abstract class Performance implements EventTarget {

  /** @domName Performance.memory */
  MemoryInfo get memory;

  /** @domName Performance.navigation */
  PerformanceNavigation get navigation;

  /** @domName Performance.timing */
  PerformanceTiming get timing;

  /** @domName Performance.now */
  num now();
}

class _PerformanceImpl extends _EventTargetImpl implements Performance native "*Performance" {

  final _MemoryInfoImpl memory;

  final _PerformanceNavigationImpl navigation;

  final _PerformanceTimingImpl timing;

  num now() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PerformanceNavigation
abstract class PerformanceNavigation {

  static const int TYPE_BACK_FORWARD = 2;

  static const int TYPE_NAVIGATE = 0;

  static const int TYPE_RELOAD = 1;

  static const int TYPE_RESERVED = 255;

  /** @domName PerformanceNavigation.redirectCount */
  int get redirectCount;

  /** @domName PerformanceNavigation.type */
  int get type;
}

class _PerformanceNavigationImpl implements PerformanceNavigation native "*PerformanceNavigation" {

  final int redirectCount;

  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PerformanceTiming
abstract class PerformanceTiming {

  /** @domName PerformanceTiming.connectEnd */
  int get connectEnd;

  /** @domName PerformanceTiming.connectStart */
  int get connectStart;

  /** @domName PerformanceTiming.domComplete */
  int get domComplete;

  /** @domName PerformanceTiming.domContentLoadedEventEnd */
  int get domContentLoadedEventEnd;

  /** @domName PerformanceTiming.domContentLoadedEventStart */
  int get domContentLoadedEventStart;

  /** @domName PerformanceTiming.domInteractive */
  int get domInteractive;

  /** @domName PerformanceTiming.domLoading */
  int get domLoading;

  /** @domName PerformanceTiming.domainLookupEnd */
  int get domainLookupEnd;

  /** @domName PerformanceTiming.domainLookupStart */
  int get domainLookupStart;

  /** @domName PerformanceTiming.fetchStart */
  int get fetchStart;

  /** @domName PerformanceTiming.loadEventEnd */
  int get loadEventEnd;

  /** @domName PerformanceTiming.loadEventStart */
  int get loadEventStart;

  /** @domName PerformanceTiming.navigationStart */
  int get navigationStart;

  /** @domName PerformanceTiming.redirectEnd */
  int get redirectEnd;

  /** @domName PerformanceTiming.redirectStart */
  int get redirectStart;

  /** @domName PerformanceTiming.requestStart */
  int get requestStart;

  /** @domName PerformanceTiming.responseEnd */
  int get responseEnd;

  /** @domName PerformanceTiming.responseStart */
  int get responseStart;

  /** @domName PerformanceTiming.secureConnectionStart */
  int get secureConnectionStart;

  /** @domName PerformanceTiming.unloadEventEnd */
  int get unloadEventEnd;

  /** @domName PerformanceTiming.unloadEventStart */
  int get unloadEventStart;
}

class _PerformanceTimingImpl implements PerformanceTiming native "*PerformanceTiming" {

  final int connectEnd;

  final int connectStart;

  final int domComplete;

  final int domContentLoadedEventEnd;

  final int domContentLoadedEventStart;

  final int domInteractive;

  final int domLoading;

  final int domainLookupEnd;

  final int domainLookupStart;

  final int fetchStart;

  final int loadEventEnd;

  final int loadEventStart;

  final int navigationStart;

  final int redirectEnd;

  final int redirectStart;

  final int requestStart;

  final int responseEnd;

  final int responseStart;

  final int secureConnectionStart;

  final int unloadEventEnd;

  final int unloadEventStart;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName WebKitPoint
abstract class Point {

  factory Point(num x, num y) => _PointFactoryProvider.createPoint(x, y);

  /** @domName WebKitPoint.x */
  num x;

  /** @domName WebKitPoint.y */
  num y;
}

class _PointImpl implements Point native "*WebKitPoint" {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PopStateEvent
abstract class PopStateEvent implements Event {

  /** @domName PopStateEvent.state */
  Object get state;
}

class _PopStateEventImpl extends _EventImpl implements PopStateEvent native "*PopStateEvent" {

  final Object state;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void PositionCallback(Geoposition position);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PositionError
abstract class PositionError {

  static const int PERMISSION_DENIED = 1;

  static const int POSITION_UNAVAILABLE = 2;

  static const int TIMEOUT = 3;

  /** @domName PositionError.code */
  int get code;

  /** @domName PositionError.message */
  String get message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void PositionErrorCallback(PositionError error);

class _PositionErrorImpl implements PositionError native "*PositionError" {

  final int code;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLPreElement
abstract class PreElement implements Element {

  factory PreElement() => _Elements.createPreElement();

  /** @domName HTMLPreElement.width */
  int width;

  /** @domName HTMLPreElement.wrap */
  bool wrap;
}

class _PreElementImpl extends _ElementImpl implements PreElement native "*HTMLPreElement" {

  int width;

  bool wrap;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ProcessingInstruction
abstract class ProcessingInstruction implements Node {

  /** @domName ProcessingInstruction.data */
  String data;

  /** @domName ProcessingInstruction.sheet */
  StyleSheet get sheet;

  /** @domName ProcessingInstruction.target */
  String get target;
}

class _ProcessingInstructionImpl extends _NodeImpl implements ProcessingInstruction native "*ProcessingInstruction" {

  String data;

  final _StyleSheetImpl sheet;

  final String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLProgressElement
abstract class ProgressElement implements Element {

  factory ProgressElement() => _Elements.createProgressElement();

  /** @domName HTMLProgressElement.labels */
  List<Node> get labels;

  /** @domName HTMLProgressElement.max */
  num max;

  /** @domName HTMLProgressElement.position */
  num get position;

  /** @domName HTMLProgressElement.value */
  num value;
}

class _ProgressElementImpl extends _ElementImpl implements ProgressElement native "*HTMLProgressElement" {

  final List<Node> labels;

  num max;

  final num position;

  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ProgressEvent
abstract class ProgressEvent implements Event {

  /** @domName ProgressEvent.lengthComputable */
  bool get lengthComputable;

  /** @domName ProgressEvent.loaded */
  int get loaded;

  /** @domName ProgressEvent.total */
  int get total;
}

class _ProgressEventImpl extends _EventImpl implements ProgressEvent native "*ProgressEvent" {

  final bool lengthComputable;

  final int loaded;

  final int total;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLQuoteElement
abstract class QuoteElement implements Element {

  /** @domName HTMLQuoteElement.cite */
  String cite;
}

class _QuoteElementImpl extends _ElementImpl implements QuoteElement native "*HTMLQuoteElement" {

  String cite;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RGBColor
abstract class RGBColor {

  /** @domName RGBColor.blue */
  CSSPrimitiveValue get blue;

  /** @domName RGBColor.green */
  CSSPrimitiveValue get green;

  /** @domName RGBColor.red */
  CSSPrimitiveValue get red;
}

class _RGBColorImpl implements RGBColor native "*RGBColor" {

  final _CSSPrimitiveValueImpl blue;

  final _CSSPrimitiveValueImpl green;

  final _CSSPrimitiveValueImpl red;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCDataChannel
abstract class RTCDataChannel implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  RTCDataChannelEvents get on;

  /** @domName RTCDataChannel.binaryType */
  String binaryType;

  /** @domName RTCDataChannel.bufferedAmount */
  int get bufferedAmount;

  /** @domName RTCDataChannel.label */
  String get label;

  /** @domName RTCDataChannel.readyState */
  String get readyState;

  /** @domName RTCDataChannel.reliable */
  bool get reliable;

  /** @domName RTCDataChannel.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName RTCDataChannel.close */
  void close();

  /** @domName RTCDataChannel.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName RTCDataChannel.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName RTCDataChannel.send */
  void send(data);
}

abstract class RTCDataChannelEvents implements Events {

  EventListenerList get close;

  EventListenerList get error;

  EventListenerList get message;

  EventListenerList get open;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCDataChannelEvent
abstract class RTCDataChannelEvent implements Event {

  /** @domName RTCDataChannelEvent.channel */
  RTCDataChannel get channel;
}

class _RTCDataChannelEventImpl extends _EventImpl implements RTCDataChannelEvent native "*RTCDataChannelEvent" {

  final _RTCDataChannelImpl channel;
}

class _RTCDataChannelImpl extends _EventTargetImpl implements RTCDataChannel native "*RTCDataChannel" {

  _RTCDataChannelEventsImpl get on =>
    new _RTCDataChannelEventsImpl(this);

  String binaryType;

  final int bufferedAmount;

  final String label;

  final String readyState;

  final bool reliable;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void close() native;

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void send(data) native;
}

class _RTCDataChannelEventsImpl extends _EventsImpl implements RTCDataChannelEvents {
  _RTCDataChannelEventsImpl(_ptr) : super(_ptr);

  EventListenerList get close => this['close'];

  EventListenerList get error => this['error'];

  EventListenerList get message => this['message'];

  EventListenerList get open => this['open'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RTCErrorCallback(String errorInformation);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCIceCandidate
abstract class RTCIceCandidate {

  factory RTCIceCandidate(Map dictionary) => _RTCIceCandidateFactoryProvider.createRTCIceCandidate(dictionary);

  /** @domName RTCIceCandidate.candidate */
  String get candidate;

  /** @domName RTCIceCandidate.sdpMLineIndex */
  int get sdpMLineIndex;

  /** @domName RTCIceCandidate.sdpMid */
  String get sdpMid;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCIceCandidateEvent
abstract class RTCIceCandidateEvent implements Event {

  /** @domName RTCIceCandidateEvent.candidate */
  RTCIceCandidate get candidate;
}

class _RTCIceCandidateEventImpl extends _EventImpl implements RTCIceCandidateEvent native "*RTCIceCandidateEvent" {

  final _RTCIceCandidateImpl candidate;
}

class _RTCIceCandidateImpl implements RTCIceCandidate native "*RTCIceCandidate" {

  final String candidate;

  final int sdpMLineIndex;

  final String sdpMid;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCPeerConnection
abstract class RTCPeerConnection implements EventTarget {

  factory RTCPeerConnection(Map rtcIceServers, [Map mediaConstraints]) {
    if (!?mediaConstraints) {
      return _RTCPeerConnectionFactoryProvider.createRTCPeerConnection(rtcIceServers);
    }
    return _RTCPeerConnectionFactoryProvider.createRTCPeerConnection(rtcIceServers, mediaConstraints);
  }

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  RTCPeerConnectionEvents get on;

  /** @domName RTCPeerConnection.iceState */
  String get iceState;

  /** @domName RTCPeerConnection.localDescription */
  RTCSessionDescription get localDescription;

  /** @domName RTCPeerConnection.localStreams */
  List<MediaStream> get localStreams;

  /** @domName RTCPeerConnection.readyState */
  String get readyState;

  /** @domName RTCPeerConnection.remoteDescription */
  RTCSessionDescription get remoteDescription;

  /** @domName RTCPeerConnection.remoteStreams */
  List<MediaStream> get remoteStreams;

  /** @domName RTCPeerConnection.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName RTCPeerConnection.addIceCandidate */
  void addIceCandidate(RTCIceCandidate candidate);

  /** @domName RTCPeerConnection.addStream */
  void addStream(MediaStream stream, [Map mediaConstraints]);

  /** @domName RTCPeerConnection.close */
  void close();

  /** @domName RTCPeerConnection.createAnswer */
  void createAnswer(RTCSessionDescriptionCallback successCallback, [RTCErrorCallback failureCallback, Map mediaConstraints]);

  /** @domName RTCPeerConnection.createDataChannel */
  RTCDataChannel createDataChannel(String label, [Map options]);

  /** @domName RTCPeerConnection.createOffer */
  void createOffer(RTCSessionDescriptionCallback successCallback, [RTCErrorCallback failureCallback, Map mediaConstraints]);

  /** @domName RTCPeerConnection.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName RTCPeerConnection.getStats */
  void getStats(RTCStatsCallback successCallback, MediaStreamTrack selector);

  /** @domName RTCPeerConnection.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName RTCPeerConnection.removeStream */
  void removeStream(MediaStream stream);

  /** @domName RTCPeerConnection.setLocalDescription */
  void setLocalDescription(RTCSessionDescription description, [VoidCallback successCallback, RTCErrorCallback failureCallback]);

  /** @domName RTCPeerConnection.setRemoteDescription */
  void setRemoteDescription(RTCSessionDescription description, [VoidCallback successCallback, RTCErrorCallback failureCallback]);

  /** @domName RTCPeerConnection.updateIce */
  void updateIce([Map configuration, Map mediaConstraints]);
}

abstract class RTCPeerConnectionEvents implements Events {

  EventListenerList get addStream;

  EventListenerList get iceCandidate;

  EventListenerList get iceChange;

  EventListenerList get negotiationNeeded;

  EventListenerList get open;

  EventListenerList get removeStream;

  EventListenerList get stateChange;
}

class _RTCPeerConnectionImpl extends _EventTargetImpl implements RTCPeerConnection native "*RTCPeerConnection" {

  _RTCPeerConnectionEventsImpl get on =>
    new _RTCPeerConnectionEventsImpl(this);

  final String iceState;

  final _RTCSessionDescriptionImpl localDescription;

  final _MediaStreamListImpl localStreams;

  final String readyState;

  final _RTCSessionDescriptionImpl remoteDescription;

  final _MediaStreamListImpl remoteStreams;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void addIceCandidate(_RTCIceCandidateImpl candidate) native;

  void addStream(_MediaStreamImpl stream, [mediaConstraints]) {
    if (?mediaConstraints) {
      var mediaConstraints_1 = _convertDartToNative_Dictionary(mediaConstraints);
      _addStream_1(stream, mediaConstraints_1);
      return;
    }
    _addStream_2(stream);
    return;
  }
  void _addStream_1(_MediaStreamImpl stream, mediaConstraints) native "addStream";
  void _addStream_2(_MediaStreamImpl stream) native "addStream";

  void close() native;

  void createAnswer(RTCSessionDescriptionCallback successCallback, [failureCallback, mediaConstraints]) {
    if (?mediaConstraints) {
      var mediaConstraints_1 = _convertDartToNative_Dictionary(mediaConstraints);
      _createAnswer_1(successCallback, failureCallback, mediaConstraints_1);
      return;
    }
    _createAnswer_2(successCallback, failureCallback);
    return;
  }
  void _createAnswer_1(RTCSessionDescriptionCallback successCallback, RTCErrorCallback failureCallback, mediaConstraints) native "createAnswer";
  void _createAnswer_2(RTCSessionDescriptionCallback successCallback, RTCErrorCallback failureCallback) native "createAnswer";

  _RTCDataChannelImpl createDataChannel(String label, [options]) {
    if (?options) {
      var options_1 = _convertDartToNative_Dictionary(options);
      return _createDataChannel_1(label, options_1);
    }
    return _createDataChannel_2(label);
  }
  _RTCDataChannelImpl _createDataChannel_1(label, options) native "createDataChannel";
  _RTCDataChannelImpl _createDataChannel_2(label) native "createDataChannel";

  void createOffer(RTCSessionDescriptionCallback successCallback, [failureCallback, mediaConstraints]) {
    if (?mediaConstraints) {
      var mediaConstraints_1 = _convertDartToNative_Dictionary(mediaConstraints);
      _createOffer_1(successCallback, failureCallback, mediaConstraints_1);
      return;
    }
    _createOffer_2(successCallback, failureCallback);
    return;
  }
  void _createOffer_1(RTCSessionDescriptionCallback successCallback, RTCErrorCallback failureCallback, mediaConstraints) native "createOffer";
  void _createOffer_2(RTCSessionDescriptionCallback successCallback, RTCErrorCallback failureCallback) native "createOffer";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  void getStats(RTCStatsCallback successCallback, _MediaStreamTrackImpl selector) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void removeStream(_MediaStreamImpl stream) native;

  void setLocalDescription(_RTCSessionDescriptionImpl description, [VoidCallback successCallback, RTCErrorCallback failureCallback]) native;

  void setRemoteDescription(_RTCSessionDescriptionImpl description, [VoidCallback successCallback, RTCErrorCallback failureCallback]) native;

  void updateIce([configuration, mediaConstraints]) {
    if (?mediaConstraints) {
      var configuration_1 = _convertDartToNative_Dictionary(configuration);
      var mediaConstraints_2 = _convertDartToNative_Dictionary(mediaConstraints);
      _updateIce_1(configuration_1, mediaConstraints_2);
      return;
    }
    if (?configuration) {
      var configuration_3 = _convertDartToNative_Dictionary(configuration);
      _updateIce_2(configuration_3);
      return;
    }
    _updateIce_3();
    return;
  }
  void _updateIce_1(configuration, mediaConstraints) native "updateIce";
  void _updateIce_2(configuration) native "updateIce";
  void _updateIce_3() native "updateIce";
}

class _RTCPeerConnectionEventsImpl extends _EventsImpl implements RTCPeerConnectionEvents {
  _RTCPeerConnectionEventsImpl(_ptr) : super(_ptr);

  EventListenerList get addStream => this['addstream'];

  EventListenerList get iceCandidate => this['icecandidate'];

  EventListenerList get iceChange => this['icechange'];

  EventListenerList get negotiationNeeded => this['negotiationneeded'];

  EventListenerList get open => this['open'];

  EventListenerList get removeStream => this['removestream'];

  EventListenerList get stateChange => this['statechange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCSessionDescription
abstract class RTCSessionDescription {

  factory RTCSessionDescription(Map dictionary) => _RTCSessionDescriptionFactoryProvider.createRTCSessionDescription(dictionary);

  /** @domName RTCSessionDescription.sdp */
  String sdp;

  /** @domName RTCSessionDescription.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RTCSessionDescriptionCallback(RTCSessionDescription sdp);

class _RTCSessionDescriptionImpl implements RTCSessionDescription native "*RTCSessionDescription" {

  String sdp;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RTCStatsCallback(RTCStatsResponse response);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCStatsElement
abstract class RTCStatsElement {

  /** @domName RTCStatsElement.timestamp */
  Date get timestamp;

  /** @domName RTCStatsElement.stat */
  String stat(String name);
}

class _RTCStatsElementImpl implements RTCStatsElement native "*RTCStatsElement" {

  final Date timestamp;

  String stat(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCStatsReport
abstract class RTCStatsReport {

  /** @domName RTCStatsReport.local */
  RTCStatsElement get local;

  /** @domName RTCStatsReport.remote */
  RTCStatsElement get remote;
}

class _RTCStatsReportImpl implements RTCStatsReport native "*RTCStatsReport" {

  final _RTCStatsElementImpl local;

  final _RTCStatsElementImpl remote;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RTCStatsResponse
abstract class RTCStatsResponse {

  /** @domName RTCStatsResponse.result */
  List<RTCStatsReport> result();
}

class _RTCStatsResponseImpl implements RTCStatsResponse native "*RTCStatsResponse" {

  List<RTCStatsReport> result() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RadioNodeList
abstract class RadioNodeList implements NodeList {

  /** @domName RadioNodeList.value */
  String value;
}

class _RadioNodeListImpl extends _NodeListImpl implements RadioNodeList native "*RadioNodeList" {

  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Range
abstract class Range {

  static const int END_TO_END = 2;

  static const int END_TO_START = 3;

  static const int NODE_AFTER = 1;

  static const int NODE_BEFORE = 0;

  static const int NODE_BEFORE_AND_AFTER = 2;

  static const int NODE_INSIDE = 3;

  static const int START_TO_END = 1;

  static const int START_TO_START = 0;

  /** @domName Range.collapsed */
  bool get collapsed;

  /** @domName Range.commonAncestorContainer */
  Node get commonAncestorContainer;

  /** @domName Range.endContainer */
  Node get endContainer;

  /** @domName Range.endOffset */
  int get endOffset;

  /** @domName Range.startContainer */
  Node get startContainer;

  /** @domName Range.startOffset */
  int get startOffset;

  /** @domName Range.cloneContents */
  DocumentFragment cloneContents();

  /** @domName Range.cloneRange */
  Range cloneRange();

  /** @domName Range.collapse */
  void collapse(bool toStart);

  /** @domName Range.compareNode */
  int compareNode(Node refNode);

  /** @domName Range.comparePoint */
  int comparePoint(Node refNode, int offset);

  /** @domName Range.createContextualFragment */
  DocumentFragment createContextualFragment(String html);

  /** @domName Range.deleteContents */
  void deleteContents();

  /** @domName Range.detach */
  void detach();

  /** @domName Range.expand */
  void expand(String unit);

  /** @domName Range.extractContents */
  DocumentFragment extractContents();

  /** @domName Range.getBoundingClientRect */
  ClientRect getBoundingClientRect();

  /** @domName Range.getClientRects */
  List<ClientRect> getClientRects();

  /** @domName Range.insertNode */
  void insertNode(Node newNode);

  /** @domName Range.intersectsNode */
  bool intersectsNode(Node refNode);

  /** @domName Range.isPointInRange */
  bool isPointInRange(Node refNode, int offset);

  /** @domName Range.selectNode */
  void selectNode(Node refNode);

  /** @domName Range.selectNodeContents */
  void selectNodeContents(Node refNode);

  /** @domName Range.setEnd */
  void setEnd(Node refNode, int offset);

  /** @domName Range.setEndAfter */
  void setEndAfter(Node refNode);

  /** @domName Range.setEndBefore */
  void setEndBefore(Node refNode);

  /** @domName Range.setStart */
  void setStart(Node refNode, int offset);

  /** @domName Range.setStartAfter */
  void setStartAfter(Node refNode);

  /** @domName Range.setStartBefore */
  void setStartBefore(Node refNode);

  /** @domName Range.surroundContents */
  void surroundContents(Node newParent);

  /** @domName Range.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RangeException
abstract class RangeException {

  static const int BAD_BOUNDARYPOINTS_ERR = 1;

  static const int INVALID_NODE_TYPE_ERR = 2;

  /** @domName RangeException.code */
  int get code;

  /** @domName RangeException.message */
  String get message;

  /** @domName RangeException.name */
  String get name;

  /** @domName RangeException.toString */
  String toString();
}

class _RangeExceptionImpl implements RangeException native "*RangeException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}

class _RangeImpl implements Range native "*Range" {

  final bool collapsed;

  final _NodeImpl commonAncestorContainer;

  final _NodeImpl endContainer;

  final int endOffset;

  final _NodeImpl startContainer;

  final int startOffset;

  _DocumentFragmentImpl cloneContents() native;

  _RangeImpl cloneRange() native;

  void collapse(bool toStart) native;

  int compareNode(_NodeImpl refNode) native;

  int comparePoint(_NodeImpl refNode, int offset) native;

  _DocumentFragmentImpl createContextualFragment(String html) native;

  void deleteContents() native;

  void detach() native;

  void expand(String unit) native;

  _DocumentFragmentImpl extractContents() native;

  _ClientRectImpl getBoundingClientRect() native;

  _ClientRectListImpl getClientRects() native;

  void insertNode(_NodeImpl newNode) native;

  bool intersectsNode(_NodeImpl refNode) native;

  bool isPointInRange(_NodeImpl refNode, int offset) native;

  void selectNode(_NodeImpl refNode) native;

  void selectNodeContents(_NodeImpl refNode) native;

  void setEnd(_NodeImpl refNode, int offset) native;

  void setEndAfter(_NodeImpl refNode) native;

  void setEndBefore(_NodeImpl refNode) native;

  void setStart(_NodeImpl refNode, int offset) native;

  void setStartAfter(_NodeImpl refNode) native;

  void setStartBefore(_NodeImpl refNode) native;

  void surroundContents(_NodeImpl newParent) native;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Rect
abstract class Rect {

  /** @domName Rect.bottom */
  CSSPrimitiveValue get bottom;

  /** @domName Rect.left */
  CSSPrimitiveValue get left;

  /** @domName Rect.right */
  CSSPrimitiveValue get right;

  /** @domName Rect.top */
  CSSPrimitiveValue get top;
}

class _RectImpl implements Rect native "*Rect" {

  final _CSSPrimitiveValueImpl bottom;

  final _CSSPrimitiveValueImpl left;

  final _CSSPrimitiveValueImpl right;

  final _CSSPrimitiveValueImpl top;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void RequestAnimationFrameCallback(num highResTime);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLError
abstract class SQLError {

  static const int CONSTRAINT_ERR = 6;

  static const int DATABASE_ERR = 1;

  static const int QUOTA_ERR = 4;

  static const int SYNTAX_ERR = 5;

  static const int TIMEOUT_ERR = 7;

  static const int TOO_LARGE_ERR = 3;

  static const int UNKNOWN_ERR = 0;

  static const int VERSION_ERR = 2;

  /** @domName SQLError.code */
  int get code;

  /** @domName SQLError.message */
  String get message;
}

class _SQLErrorImpl implements SQLError native "*SQLError" {

  final int code;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLException
abstract class SQLException {

  static const int CONSTRAINT_ERR = 6;

  static const int DATABASE_ERR = 1;

  static const int QUOTA_ERR = 4;

  static const int SYNTAX_ERR = 5;

  static const int TIMEOUT_ERR = 7;

  static const int TOO_LARGE_ERR = 3;

  static const int UNKNOWN_ERR = 0;

  static const int VERSION_ERR = 2;

  /** @domName SQLException.code */
  int get code;

  /** @domName SQLException.message */
  String get message;
}

class _SQLExceptionImpl implements SQLException native "*SQLException" {

  final int code;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLResultSet
abstract class SQLResultSet {

  /** @domName SQLResultSet.insertId */
  int get insertId;

  /** @domName SQLResultSet.rows */
  SQLResultSetRowList get rows;

  /** @domName SQLResultSet.rowsAffected */
  int get rowsAffected;
}

class _SQLResultSetImpl implements SQLResultSet native "*SQLResultSet" {

  final int insertId;

  final _SQLResultSetRowListImpl rows;

  final int rowsAffected;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLResultSetRowList
abstract class SQLResultSetRowList implements List<Map> {

  /** @domName SQLResultSetRowList.length */
  int get length;

  /** @domName SQLResultSetRowList.item */
  Map item(int index);
}

class _SQLResultSetRowListImpl implements SQLResultSetRowList, JavaScriptIndexingBehavior native "*SQLResultSetRowList" {

  final int length;

  Map operator[](int index) => JS("Map", "#[#]", this, index);

  void operator[]=(int index, Map value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Map> mixins.
  // Map is the element type.

  // From Iterable<Map>:

  Iterator<Map> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Map>(this);
  }

  // From Collection<Map>:

  void add(Map value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Map value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Map> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Map element) => _Collections.contains(this, element);

  void forEach(void f(Map element)) => _Collections.forEach(this, f);

  Collection map(f(Map element)) => _Collections.map(this, [], f);

  Collection<Map> filter(bool f(Map element)) =>
     _Collections.filter(this, <Map>[], f);

  bool every(bool f(Map element)) => _Collections.every(this, f);

  bool some(bool f(Map element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Map>:

  void sort([Comparator<Map> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Map element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Map element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Map get last => this[length - 1];

  Map removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Map> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Map initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Map> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Map>[]);

  // -- end List<Map> mixins.

  Map item(int index) {
    return _convertNativeToDart_Dictionary(_item_1(index));
  }
  _item_1(index) native "item";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SQLStatementCallback(SQLTransaction transaction, SQLResultSet resultSet);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SQLStatementErrorCallback(SQLTransaction transaction, SQLError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLTransaction
abstract class SQLTransaction {

  /** @domName SQLTransaction.executeSql */
  void executeSql(String sqlStatement, List arguments, [SQLStatementCallback callback, SQLStatementErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SQLTransactionCallback(SQLTransaction transaction);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SQLTransactionErrorCallback(SQLError error);

class _SQLTransactionImpl implements SQLTransaction native "*SQLTransaction" {

  void executeSql(String sqlStatement, List arguments, [SQLStatementCallback callback, SQLStatementErrorCallback errorCallback]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLTransactionSync
abstract class SQLTransactionSync {

  /** @domName SQLTransactionSync.executeSql */
  SQLResultSet executeSql(String sqlStatement, List arguments);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void SQLTransactionSyncCallback(SQLTransactionSync transaction);

class _SQLTransactionSyncImpl implements SQLTransactionSync native "*SQLTransactionSync" {

  _SQLResultSetImpl executeSql(String sqlStatement, List arguments) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAElement
abstract class SVGAElement implements SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGAElement.target */
  SVGAnimatedString get target;
}

class _SVGAElementImpl extends _SVGElementImpl implements SVGAElement native "*SVGAElement" {

  final _SVGAnimatedStringImpl target;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphDefElement
abstract class SVGAltGlyphDefElement implements SVGElement {
}

class _SVGAltGlyphDefElementImpl extends _SVGElementImpl implements SVGAltGlyphDefElement native "*SVGAltGlyphDefElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphElement
abstract class SVGAltGlyphElement implements SVGTextPositioningElement, SVGURIReference {

  /** @domName SVGAltGlyphElement.format */
  String format;

  /** @domName SVGAltGlyphElement.glyphRef */
  String glyphRef;
}

class _SVGAltGlyphElementImpl extends _SVGTextPositioningElementImpl implements SVGAltGlyphElement native "*SVGAltGlyphElement" {

  String format;

  String glyphRef;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphItemElement
abstract class SVGAltGlyphItemElement implements SVGElement {
}

class _SVGAltGlyphItemElementImpl extends _SVGElementImpl implements SVGAltGlyphItemElement native "*SVGAltGlyphItemElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAngle
abstract class SVGAngle {

  static const int SVG_ANGLETYPE_DEG = 2;

  static const int SVG_ANGLETYPE_GRAD = 4;

  static const int SVG_ANGLETYPE_RAD = 3;

  static const int SVG_ANGLETYPE_UNKNOWN = 0;

  static const int SVG_ANGLETYPE_UNSPECIFIED = 1;

  /** @domName SVGAngle.unitType */
  int get unitType;

  /** @domName SVGAngle.value */
  num value;

  /** @domName SVGAngle.valueAsString */
  String valueAsString;

  /** @domName SVGAngle.valueInSpecifiedUnits */
  num valueInSpecifiedUnits;

  /** @domName SVGAngle.convertToSpecifiedUnits */
  void convertToSpecifiedUnits(int unitType);

  /** @domName SVGAngle.newValueSpecifiedUnits */
  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}

class _SVGAngleImpl implements SVGAngle native "*SVGAngle" {

  final int unitType;

  num value;

  String valueAsString;

  num valueInSpecifiedUnits;

  void convertToSpecifiedUnits(int unitType) native;

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateColorElement
abstract class SVGAnimateColorElement implements SVGAnimationElement {
}

class _SVGAnimateColorElementImpl extends _SVGAnimationElementImpl implements SVGAnimateColorElement native "*SVGAnimateColorElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateElement
abstract class SVGAnimateElement implements SVGAnimationElement {
}

class _SVGAnimateElementImpl extends _SVGAnimationElementImpl implements SVGAnimateElement native "*SVGAnimateElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateMotionElement
abstract class SVGAnimateMotionElement implements SVGAnimationElement {
}

class _SVGAnimateMotionElementImpl extends _SVGAnimationElementImpl implements SVGAnimateMotionElement native "*SVGAnimateMotionElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateTransformElement
abstract class SVGAnimateTransformElement implements SVGAnimationElement {
}

class _SVGAnimateTransformElementImpl extends _SVGAnimationElementImpl implements SVGAnimateTransformElement native "*SVGAnimateTransformElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedAngle
abstract class SVGAnimatedAngle {

  /** @domName SVGAnimatedAngle.animVal */
  SVGAngle get animVal;

  /** @domName SVGAnimatedAngle.baseVal */
  SVGAngle get baseVal;
}

class _SVGAnimatedAngleImpl implements SVGAnimatedAngle native "*SVGAnimatedAngle" {

  final _SVGAngleImpl animVal;

  final _SVGAngleImpl baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedBoolean
abstract class SVGAnimatedBoolean {

  /** @domName SVGAnimatedBoolean.animVal */
  bool get animVal;

  /** @domName SVGAnimatedBoolean.baseVal */
  bool baseVal;
}

class _SVGAnimatedBooleanImpl implements SVGAnimatedBoolean native "*SVGAnimatedBoolean" {

  final bool animVal;

  bool baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedEnumeration
abstract class SVGAnimatedEnumeration {

  /** @domName SVGAnimatedEnumeration.animVal */
  int get animVal;

  /** @domName SVGAnimatedEnumeration.baseVal */
  int baseVal;
}

class _SVGAnimatedEnumerationImpl implements SVGAnimatedEnumeration native "*SVGAnimatedEnumeration" {

  final int animVal;

  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedInteger
abstract class SVGAnimatedInteger {

  /** @domName SVGAnimatedInteger.animVal */
  int get animVal;

  /** @domName SVGAnimatedInteger.baseVal */
  int baseVal;
}

class _SVGAnimatedIntegerImpl implements SVGAnimatedInteger native "*SVGAnimatedInteger" {

  final int animVal;

  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedLength
abstract class SVGAnimatedLength {

  /** @domName SVGAnimatedLength.animVal */
  SVGLength get animVal;

  /** @domName SVGAnimatedLength.baseVal */
  SVGLength get baseVal;
}

class _SVGAnimatedLengthImpl implements SVGAnimatedLength native "*SVGAnimatedLength" {

  final _SVGLengthImpl animVal;

  final _SVGLengthImpl baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedLengthList
abstract class SVGAnimatedLengthList implements List<SVGAnimatedLength> {

  /** @domName SVGAnimatedLengthList.animVal */
  SVGLengthList get animVal;

  /** @domName SVGAnimatedLengthList.baseVal */
  SVGLengthList get baseVal;
}

class _SVGAnimatedLengthListImpl implements SVGAnimatedLengthList, JavaScriptIndexingBehavior native "*SVGAnimatedLengthList" {

  final _SVGLengthListImpl animVal;

  final _SVGLengthListImpl baseVal;

  _SVGAnimatedLengthImpl operator[](int index) => JS("_SVGAnimatedLengthImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGAnimatedLengthImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGAnimatedLength> mixins.
  // SVGAnimatedLength is the element type.

  // From Iterable<SVGAnimatedLength>:

  Iterator<SVGAnimatedLength> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGAnimatedLength>(this);
  }

  // From Collection<SVGAnimatedLength>:

  void add(SVGAnimatedLength value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGAnimatedLength value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGAnimatedLength> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGAnimatedLength element) => _Collections.contains(this, element);

  void forEach(void f(SVGAnimatedLength element)) => _Collections.forEach(this, f);

  Collection map(f(SVGAnimatedLength element)) => _Collections.map(this, [], f);

  Collection<SVGAnimatedLength> filter(bool f(SVGAnimatedLength element)) =>
     _Collections.filter(this, <SVGAnimatedLength>[], f);

  bool every(bool f(SVGAnimatedLength element)) => _Collections.every(this, f);

  bool some(bool f(SVGAnimatedLength element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGAnimatedLength>:

  void sort([Comparator<SVGAnimatedLength> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGAnimatedLength element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGAnimatedLength element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGAnimatedLength get last => this[length - 1];

  SVGAnimatedLength removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGAnimatedLength> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGAnimatedLength initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGAnimatedLength> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGAnimatedLength>[]);

  // -- end List<SVGAnimatedLength> mixins.
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedNumber
abstract class SVGAnimatedNumber {

  /** @domName SVGAnimatedNumber.animVal */
  num get animVal;

  /** @domName SVGAnimatedNumber.baseVal */
  num baseVal;
}

class _SVGAnimatedNumberImpl implements SVGAnimatedNumber native "*SVGAnimatedNumber" {

  final num animVal;

  num baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedNumberList
abstract class SVGAnimatedNumberList implements List<SVGAnimatedNumber> {

  /** @domName SVGAnimatedNumberList.animVal */
  SVGNumberList get animVal;

  /** @domName SVGAnimatedNumberList.baseVal */
  SVGNumberList get baseVal;
}

class _SVGAnimatedNumberListImpl implements SVGAnimatedNumberList, JavaScriptIndexingBehavior native "*SVGAnimatedNumberList" {

  final _SVGNumberListImpl animVal;

  final _SVGNumberListImpl baseVal;

  _SVGAnimatedNumberImpl operator[](int index) => JS("_SVGAnimatedNumberImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGAnimatedNumberImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGAnimatedNumber> mixins.
  // SVGAnimatedNumber is the element type.

  // From Iterable<SVGAnimatedNumber>:

  Iterator<SVGAnimatedNumber> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGAnimatedNumber>(this);
  }

  // From Collection<SVGAnimatedNumber>:

  void add(SVGAnimatedNumber value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGAnimatedNumber value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGAnimatedNumber> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGAnimatedNumber element) => _Collections.contains(this, element);

  void forEach(void f(SVGAnimatedNumber element)) => _Collections.forEach(this, f);

  Collection map(f(SVGAnimatedNumber element)) => _Collections.map(this, [], f);

  Collection<SVGAnimatedNumber> filter(bool f(SVGAnimatedNumber element)) =>
     _Collections.filter(this, <SVGAnimatedNumber>[], f);

  bool every(bool f(SVGAnimatedNumber element)) => _Collections.every(this, f);

  bool some(bool f(SVGAnimatedNumber element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGAnimatedNumber>:

  void sort([Comparator<SVGAnimatedNumber> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGAnimatedNumber element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGAnimatedNumber element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGAnimatedNumber get last => this[length - 1];

  SVGAnimatedNumber removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGAnimatedNumber> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGAnimatedNumber initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGAnimatedNumber> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGAnimatedNumber>[]);

  // -- end List<SVGAnimatedNumber> mixins.
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedPreserveAspectRatio
abstract class SVGAnimatedPreserveAspectRatio {

  /** @domName SVGAnimatedPreserveAspectRatio.animVal */
  SVGPreserveAspectRatio get animVal;

  /** @domName SVGAnimatedPreserveAspectRatio.baseVal */
  SVGPreserveAspectRatio get baseVal;
}

class _SVGAnimatedPreserveAspectRatioImpl implements SVGAnimatedPreserveAspectRatio native "*SVGAnimatedPreserveAspectRatio" {

  final _SVGPreserveAspectRatioImpl animVal;

  final _SVGPreserveAspectRatioImpl baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedRect
abstract class SVGAnimatedRect {

  /** @domName SVGAnimatedRect.animVal */
  SVGRect get animVal;

  /** @domName SVGAnimatedRect.baseVal */
  SVGRect get baseVal;
}

class _SVGAnimatedRectImpl implements SVGAnimatedRect native "*SVGAnimatedRect" {

  final _SVGRectImpl animVal;

  final _SVGRectImpl baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedString
abstract class SVGAnimatedString {

  /** @domName SVGAnimatedString.animVal */
  String get animVal;

  /** @domName SVGAnimatedString.baseVal */
  String baseVal;
}

class _SVGAnimatedStringImpl implements SVGAnimatedString native "*SVGAnimatedString" {

  final String animVal;

  String baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedTransformList
abstract class SVGAnimatedTransformList implements List<SVGAnimateTransformElement> {

  /** @domName SVGAnimatedTransformList.animVal */
  SVGTransformList get animVal;

  /** @domName SVGAnimatedTransformList.baseVal */
  SVGTransformList get baseVal;
}

class _SVGAnimatedTransformListImpl implements SVGAnimatedTransformList, JavaScriptIndexingBehavior native "*SVGAnimatedTransformList" {

  final _SVGTransformListImpl animVal;

  final _SVGTransformListImpl baseVal;

  _SVGAnimateTransformElementImpl operator[](int index) => JS("_SVGAnimateTransformElementImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGAnimateTransformElementImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGAnimateTransformElement> mixins.
  // SVGAnimateTransformElement is the element type.

  // From Iterable<SVGAnimateTransformElement>:

  Iterator<SVGAnimateTransformElement> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGAnimateTransformElement>(this);
  }

  // From Collection<SVGAnimateTransformElement>:

  void add(SVGAnimateTransformElement value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGAnimateTransformElement value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGAnimateTransformElement> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGAnimateTransformElement element) => _Collections.contains(this, element);

  void forEach(void f(SVGAnimateTransformElement element)) => _Collections.forEach(this, f);

  Collection map(f(SVGAnimateTransformElement element)) => _Collections.map(this, [], f);

  Collection<SVGAnimateTransformElement> filter(bool f(SVGAnimateTransformElement element)) =>
     _Collections.filter(this, <SVGAnimateTransformElement>[], f);

  bool every(bool f(SVGAnimateTransformElement element)) => _Collections.every(this, f);

  bool some(bool f(SVGAnimateTransformElement element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGAnimateTransformElement>:

  void sort([Comparator<SVGAnimateTransformElement> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGAnimateTransformElement element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGAnimateTransformElement element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGAnimateTransformElement get last => this[length - 1];

  SVGAnimateTransformElement removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGAnimateTransformElement> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGAnimateTransformElement initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGAnimateTransformElement> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGAnimateTransformElement>[]);

  // -- end List<SVGAnimateTransformElement> mixins.
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimationElement
abstract class SVGAnimationElement implements SVGElement, SVGTests, SVGExternalResourcesRequired, ElementTimeControl {

  /** @domName SVGAnimationElement.targetElement */
  SVGElement get targetElement;

  /** @domName SVGAnimationElement.getCurrentTime */
  num getCurrentTime();

  /** @domName SVGAnimationElement.getSimpleDuration */
  num getSimpleDuration();

  /** @domName SVGAnimationElement.getStartTime */
  num getStartTime();
}

class _SVGAnimationElementImpl extends _SVGElementImpl implements SVGAnimationElement native "*SVGAnimationElement" {

  final _SVGElementImpl targetElement;

  num getCurrentTime() native;

  num getSimpleDuration() native;

  num getStartTime() native;

  // From ElementTimeControl

  void beginElement() native;

  void beginElementAt(num offset) native;

  void endElement() native;

  void endElementAt(num offset) native;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGCircleElement
abstract class SVGCircleElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGCircleElement.cx */
  SVGAnimatedLength get cx;

  /** @domName SVGCircleElement.cy */
  SVGAnimatedLength get cy;

  /** @domName SVGCircleElement.r */
  SVGAnimatedLength get r;
}

class _SVGCircleElementImpl extends _SVGElementImpl implements SVGCircleElement native "*SVGCircleElement" {

  final _SVGAnimatedLengthImpl cx;

  final _SVGAnimatedLengthImpl cy;

  final _SVGAnimatedLengthImpl r;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGClipPathElement
abstract class SVGClipPathElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGClipPathElement.clipPathUnits */
  SVGAnimatedEnumeration get clipPathUnits;
}

class _SVGClipPathElementImpl extends _SVGElementImpl implements SVGClipPathElement native "*SVGClipPathElement" {

  final _SVGAnimatedEnumerationImpl clipPathUnits;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGColor
abstract class SVGColor implements CSSValue {

  static const int SVG_COLORTYPE_CURRENTCOLOR = 3;

  static const int SVG_COLORTYPE_RGBCOLOR = 1;

  static const int SVG_COLORTYPE_RGBCOLOR_ICCCOLOR = 2;

  static const int SVG_COLORTYPE_UNKNOWN = 0;

  /** @domName SVGColor.colorType */
  int get colorType;

  /** @domName SVGColor.rgbColor */
  RGBColor get rgbColor;

  /** @domName SVGColor.setColor */
  void setColor(int colorType, String rgbColor, String iccColor);

  /** @domName SVGColor.setRGBColor */
  void setRGBColor(String rgbColor);

  /** @domName SVGColor.setRGBColorICCColor */
  void setRGBColorICCColor(String rgbColor, String iccColor);
}

class _SVGColorImpl extends _CSSValueImpl implements SVGColor native "*SVGColor" {

  final int colorType;

  final _RGBColorImpl rgbColor;

  void setColor(int colorType, String rgbColor, String iccColor) native;

  void setRGBColor(String rgbColor) native;

  void setRGBColorICCColor(String rgbColor, String iccColor) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGComponentTransferFunctionElement
abstract class SVGComponentTransferFunctionElement implements SVGElement {

  static const int SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3;

  static const int SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5;

  static const int SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1;

  static const int SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4;

  static const int SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2;

  static const int SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0;

  /** @domName SVGComponentTransferFunctionElement.amplitude */
  SVGAnimatedNumber get amplitude;

  /** @domName SVGComponentTransferFunctionElement.exponent */
  SVGAnimatedNumber get exponent;

  /** @domName SVGComponentTransferFunctionElement.intercept */
  SVGAnimatedNumber get intercept;

  /** @domName SVGComponentTransferFunctionElement.offset */
  SVGAnimatedNumber get offset;

  /** @domName SVGComponentTransferFunctionElement.slope */
  SVGAnimatedNumber get slope;

  /** @domName SVGComponentTransferFunctionElement.tableValues */
  SVGAnimatedNumberList get tableValues;

  /** @domName SVGComponentTransferFunctionElement.type */
  SVGAnimatedEnumeration get type;
}

class _SVGComponentTransferFunctionElementImpl extends _SVGElementImpl implements SVGComponentTransferFunctionElement native "*SVGComponentTransferFunctionElement" {

  final _SVGAnimatedNumberImpl amplitude;

  final _SVGAnimatedNumberImpl exponent;

  final _SVGAnimatedNumberImpl intercept;

  final _SVGAnimatedNumberImpl offset;

  final _SVGAnimatedNumberImpl slope;

  final _SVGAnimatedNumberListImpl tableValues;

  final _SVGAnimatedEnumerationImpl type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGCursorElement
abstract class SVGCursorElement implements SVGElement, SVGURIReference, SVGTests, SVGExternalResourcesRequired {

  /** @domName SVGCursorElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGCursorElement.y */
  SVGAnimatedLength get y;
}

class _SVGCursorElementImpl extends _SVGElementImpl implements SVGCursorElement native "*SVGCursorElement" {

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDefsElement
abstract class SVGDefsElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}

class _SVGDefsElementImpl extends _SVGElementImpl implements SVGDefsElement native "*SVGDefsElement" {

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDescElement
abstract class SVGDescElement implements SVGElement, SVGLangSpace, SVGStylable {
}

class _SVGDescElementImpl extends _SVGElementImpl implements SVGDescElement native "*SVGDescElement" {

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDocument
abstract class SVGDocument implements Document {

  /** @domName SVGDocument.rootElement */
  SVGSVGElement get rootElement;

  /** @domName SVGDocument.createEvent */
  Event $dom_createEvent(String eventType);
}

class _SVGDocumentImpl extends _DocumentImpl implements SVGDocument native "*SVGDocument" {

  final _SVGSVGElementImpl rootElement;

  _EventImpl $dom_createEvent(String eventType) native "createEvent";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName SVGElement
abstract class SVGElement implements Element {

  factory SVGElement.tag(String tag) =>
      _SVGElementFactoryProvider.createSVGElement_tag(tag);
  factory SVGElement.svg(String svg) =>
      _SVGElementFactoryProvider.createSVGElement_svg(svg);

  SVGElement clone(bool deep);


  /** @domName SVGElement.id */
  String id;

  /** @domName SVGElement.ownerSVGElement */
  SVGSVGElement get ownerSVGElement;

  /** @domName SVGElement.viewportElement */
  SVGElement get viewportElement;

  /** @domName SVGElement.xmlbase */
  String xmlbase;

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AttributeClassSet extends _CssClassSet {
  _AttributeClassSet(element) : super(element);

  String $dom_className() => _element.attributes['class'];

  void _write(Set s) {
    _element.attributes['class'] = _formatSet(s);
  }
}

class _SVGElementImpl extends _ElementImpl implements SVGElement native "*SVGElement" {
  CSSClassSet get classes {
    if (_cssClassSet == null) {
      _cssClassSet = new _AttributeClassSet(_ptr);
    }
    return _cssClassSet;
  }

  List<Element> get elements => new _FilteredElementList(this);

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  String get outerHTML {
    final container = new Element.tag("div");
    final SVGElement cloned = this.clone(true);
    container.elements.add(cloned);
    return container.innerHTML;
  }

  String get innerHTML {
    final container = new Element.tag("div");
    final SVGElement cloned = this.clone(true);
    container.elements.addAll(cloned.elements);
    return container.innerHTML;
  }

  void set innerHTML(String svg) {
    final container = new Element.tag("div");
    // Wrap the SVG string in <svg> so that SVGElements are created, rather than
    // HTMLElements.
    container.innerHTML = '<svg version="1.1">$svg</svg>';
    this.elements = container.elements[0].elements;
  }


  // Shadowing definition.
  String get id => JS("String", "#.id", this);

  void set id(String value) {
    JS("void", "#.id = #", this, value);
  }

  final _SVGSVGElementImpl ownerSVGElement;

  final _SVGElementImpl viewportElement;

  String xmlbase;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGElementInstance
abstract class SVGElementInstance implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SVGElementInstanceEvents get on;

  /** @domName SVGElementInstance.childNodes */
  List<SVGElementInstance> get childNodes;

  /** @domName SVGElementInstance.correspondingElement */
  SVGElement get correspondingElement;

  /** @domName SVGElementInstance.correspondingUseElement */
  SVGUseElement get correspondingUseElement;

  /** @domName SVGElementInstance.firstChild */
  SVGElementInstance get firstChild;

  /** @domName SVGElementInstance.lastChild */
  SVGElementInstance get lastChild;

  /** @domName SVGElementInstance.nextSibling */
  SVGElementInstance get nextSibling;

  /** @domName SVGElementInstance.parentNode */
  SVGElementInstance get parentNode;

  /** @domName SVGElementInstance.previousSibling */
  SVGElementInstance get previousSibling;
}

abstract class SVGElementInstanceEvents implements Events {

  EventListenerList get abort;

  EventListenerList get beforeCopy;

  EventListenerList get beforeCut;

  EventListenerList get beforePaste;

  EventListenerList get blur;

  EventListenerList get change;

  EventListenerList get click;

  EventListenerList get contextMenu;

  EventListenerList get copy;

  EventListenerList get cut;

  EventListenerList get doubleClick;

  EventListenerList get drag;

  EventListenerList get dragEnd;

  EventListenerList get dragEnter;

  EventListenerList get dragLeave;

  EventListenerList get dragOver;

  EventListenerList get dragStart;

  EventListenerList get drop;

  EventListenerList get error;

  EventListenerList get focus;

  EventListenerList get input;

  EventListenerList get keyDown;

  EventListenerList get keyPress;

  EventListenerList get keyUp;

  EventListenerList get load;

  EventListenerList get mouseDown;

  EventListenerList get mouseMove;

  EventListenerList get mouseOut;

  EventListenerList get mouseOver;

  EventListenerList get mouseUp;

  EventListenerList get mouseWheel;

  EventListenerList get paste;

  EventListenerList get reset;

  EventListenerList get resize;

  EventListenerList get scroll;

  EventListenerList get search;

  EventListenerList get select;

  EventListenerList get selectStart;

  EventListenerList get submit;

  EventListenerList get unload;
}

class _SVGElementInstanceImpl extends _EventTargetImpl implements SVGElementInstance native "*SVGElementInstance" {

  _SVGElementInstanceEventsImpl get on =>
    new _SVGElementInstanceEventsImpl(this);

  final _SVGElementInstanceListImpl childNodes;

  final _SVGElementImpl correspondingElement;

  final _SVGUseElementImpl correspondingUseElement;

  final _SVGElementInstanceImpl firstChild;

  final _SVGElementInstanceImpl lastChild;

  final _SVGElementInstanceImpl nextSibling;

  final _SVGElementInstanceImpl parentNode;

  final _SVGElementInstanceImpl previousSibling;
}

class _SVGElementInstanceEventsImpl extends _EventsImpl implements SVGElementInstanceEvents {
  _SVGElementInstanceEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort => this['abort'];

  EventListenerList get beforeCopy => this['beforecopy'];

  EventListenerList get beforeCut => this['beforecut'];

  EventListenerList get beforePaste => this['beforepaste'];

  EventListenerList get blur => this['blur'];

  EventListenerList get change => this['change'];

  EventListenerList get click => this['click'];

  EventListenerList get contextMenu => this['contextmenu'];

  EventListenerList get copy => this['copy'];

  EventListenerList get cut => this['cut'];

  EventListenerList get doubleClick => this['dblclick'];

  EventListenerList get drag => this['drag'];

  EventListenerList get dragEnd => this['dragend'];

  EventListenerList get dragEnter => this['dragenter'];

  EventListenerList get dragLeave => this['dragleave'];

  EventListenerList get dragOver => this['dragover'];

  EventListenerList get dragStart => this['dragstart'];

  EventListenerList get drop => this['drop'];

  EventListenerList get error => this['error'];

  EventListenerList get focus => this['focus'];

  EventListenerList get input => this['input'];

  EventListenerList get keyDown => this['keydown'];

  EventListenerList get keyPress => this['keypress'];

  EventListenerList get keyUp => this['keyup'];

  EventListenerList get load => this['load'];

  EventListenerList get mouseDown => this['mousedown'];

  EventListenerList get mouseMove => this['mousemove'];

  EventListenerList get mouseOut => this['mouseout'];

  EventListenerList get mouseOver => this['mouseover'];

  EventListenerList get mouseUp => this['mouseup'];

  EventListenerList get mouseWheel => this['mousewheel'];

  EventListenerList get paste => this['paste'];

  EventListenerList get reset => this['reset'];

  EventListenerList get resize => this['resize'];

  EventListenerList get scroll => this['scroll'];

  EventListenerList get search => this['search'];

  EventListenerList get select => this['select'];

  EventListenerList get selectStart => this['selectstart'];

  EventListenerList get submit => this['submit'];

  EventListenerList get unload => this['unload'];
}

class _SVGElementInstanceListImpl implements List<SVGElementInstance>, JavaScriptIndexingBehavior native "*SVGElementInstanceList" {

  final int length;

  _SVGElementInstanceImpl operator[](int index) => JS("_SVGElementInstanceImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGElementInstanceImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGElementInstance> mixins.
  // SVGElementInstance is the element type.

  // From Iterable<SVGElementInstance>:

  Iterator<SVGElementInstance> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGElementInstance>(this);
  }

  // From Collection<SVGElementInstance>:

  void add(SVGElementInstance value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGElementInstance value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGElementInstance> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGElementInstance element) => _Collections.contains(this, element);

  void forEach(void f(SVGElementInstance element)) => _Collections.forEach(this, f);

  Collection map(f(SVGElementInstance element)) => _Collections.map(this, [], f);

  Collection<SVGElementInstance> filter(bool f(SVGElementInstance element)) =>
     _Collections.filter(this, <SVGElementInstance>[], f);

  bool every(bool f(SVGElementInstance element)) => _Collections.every(this, f);

  bool some(bool f(SVGElementInstance element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGElementInstance>:

  void sort([Comparator<SVGElementInstance> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGElementInstance element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGElementInstance element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGElementInstance get last => this[length - 1];

  SVGElementInstance removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGElementInstance> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGElementInstance initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGElementInstance> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGElementInstance>[]);

  // -- end List<SVGElementInstance> mixins.

  _SVGElementInstanceImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGEllipseElement
abstract class SVGEllipseElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGEllipseElement.cx */
  SVGAnimatedLength get cx;

  /** @domName SVGEllipseElement.cy */
  SVGAnimatedLength get cy;

  /** @domName SVGEllipseElement.rx */
  SVGAnimatedLength get rx;

  /** @domName SVGEllipseElement.ry */
  SVGAnimatedLength get ry;
}

class _SVGEllipseElementImpl extends _SVGElementImpl implements SVGEllipseElement native "*SVGEllipseElement" {

  final _SVGAnimatedLengthImpl cx;

  final _SVGAnimatedLengthImpl cy;

  final _SVGAnimatedLengthImpl rx;

  final _SVGAnimatedLengthImpl ry;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGException
abstract class SVGException {

  static const int SVG_INVALID_VALUE_ERR = 1;

  static const int SVG_MATRIX_NOT_INVERTABLE = 2;

  static const int SVG_WRONG_TYPE_ERR = 0;

  /** @domName SVGException.code */
  int get code;

  /** @domName SVGException.message */
  String get message;

  /** @domName SVGException.name */
  String get name;

  /** @domName SVGException.toString */
  String toString();
}

class _SVGExceptionImpl implements SVGException native "*SVGException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGExternalResourcesRequired
abstract class SVGExternalResourcesRequired {

  /** @domName SVGExternalResourcesRequired.externalResourcesRequired */
  SVGAnimatedBoolean get externalResourcesRequired;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEBlendElement
abstract class SVGFEBlendElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  static const int SVG_FEBLEND_MODE_DARKEN = 4;

  static const int SVG_FEBLEND_MODE_LIGHTEN = 5;

  static const int SVG_FEBLEND_MODE_MULTIPLY = 2;

  static const int SVG_FEBLEND_MODE_NORMAL = 1;

  static const int SVG_FEBLEND_MODE_SCREEN = 3;

  static const int SVG_FEBLEND_MODE_UNKNOWN = 0;

  /** @domName SVGFEBlendElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEBlendElement.in2 */
  SVGAnimatedString get in2;

  /** @domName SVGFEBlendElement.mode */
  SVGAnimatedEnumeration get mode;
}

class _SVGFEBlendElementImpl extends _SVGElementImpl implements SVGFEBlendElement native "*SVGFEBlendElement" {

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedStringImpl in2;

  final _SVGAnimatedEnumerationImpl mode;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEColorMatrixElement
abstract class SVGFEColorMatrixElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  static const int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;

  static const int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;

  static const int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;

  static const int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;

  static const int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;

  /** @domName SVGFEColorMatrixElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEColorMatrixElement.type */
  SVGAnimatedEnumeration get type;

  /** @domName SVGFEColorMatrixElement.values */
  SVGAnimatedNumberList get values;
}

class _SVGFEColorMatrixElementImpl extends _SVGElementImpl implements SVGFEColorMatrixElement native "*SVGFEColorMatrixElement" {

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedEnumerationImpl type;

  final _SVGAnimatedNumberListImpl values;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEComponentTransferElement
abstract class SVGFEComponentTransferElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEComponentTransferElement.in1 */
  SVGAnimatedString get in1;
}

class _SVGFEComponentTransferElementImpl extends _SVGElementImpl implements SVGFEComponentTransferElement native "*SVGFEComponentTransferElement" {

  final _SVGAnimatedStringImpl in1;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFECompositeElement
abstract class SVGFECompositeElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  static const int SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;

  static const int SVG_FECOMPOSITE_OPERATOR_ATOP = 4;

  static const int SVG_FECOMPOSITE_OPERATOR_IN = 2;

  static const int SVG_FECOMPOSITE_OPERATOR_OUT = 3;

  static const int SVG_FECOMPOSITE_OPERATOR_OVER = 1;

  static const int SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;

  static const int SVG_FECOMPOSITE_OPERATOR_XOR = 5;

  /** @domName SVGFECompositeElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFECompositeElement.in2 */
  SVGAnimatedString get in2;

  /** @domName SVGFECompositeElement.k1 */
  SVGAnimatedNumber get k1;

  /** @domName SVGFECompositeElement.k2 */
  SVGAnimatedNumber get k2;

  /** @domName SVGFECompositeElement.k3 */
  SVGAnimatedNumber get k3;

  /** @domName SVGFECompositeElement.k4 */
  SVGAnimatedNumber get k4;

  /** @domName SVGFECompositeElement.operator */
  SVGAnimatedEnumeration get operator;
}

class _SVGFECompositeElementImpl extends _SVGElementImpl implements SVGFECompositeElement native "*SVGFECompositeElement" {

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedStringImpl in2;

  final _SVGAnimatedNumberImpl k1;

  final _SVGAnimatedNumberImpl k2;

  final _SVGAnimatedNumberImpl k3;

  final _SVGAnimatedNumberImpl k4;

  final _SVGAnimatedEnumerationImpl operator;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEConvolveMatrixElement
abstract class SVGFEConvolveMatrixElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  static const int SVG_EDGEMODE_DUPLICATE = 1;

  static const int SVG_EDGEMODE_NONE = 3;

  static const int SVG_EDGEMODE_UNKNOWN = 0;

  static const int SVG_EDGEMODE_WRAP = 2;

  /** @domName SVGFEConvolveMatrixElement.bias */
  SVGAnimatedNumber get bias;

  /** @domName SVGFEConvolveMatrixElement.divisor */
  SVGAnimatedNumber get divisor;

  /** @domName SVGFEConvolveMatrixElement.edgeMode */
  SVGAnimatedEnumeration get edgeMode;

  /** @domName SVGFEConvolveMatrixElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEConvolveMatrixElement.kernelMatrix */
  SVGAnimatedNumberList get kernelMatrix;

  /** @domName SVGFEConvolveMatrixElement.kernelUnitLengthX */
  SVGAnimatedNumber get kernelUnitLengthX;

  /** @domName SVGFEConvolveMatrixElement.kernelUnitLengthY */
  SVGAnimatedNumber get kernelUnitLengthY;

  /** @domName SVGFEConvolveMatrixElement.orderX */
  SVGAnimatedInteger get orderX;

  /** @domName SVGFEConvolveMatrixElement.orderY */
  SVGAnimatedInteger get orderY;

  /** @domName SVGFEConvolveMatrixElement.preserveAlpha */
  SVGAnimatedBoolean get preserveAlpha;

  /** @domName SVGFEConvolveMatrixElement.targetX */
  SVGAnimatedInteger get targetX;

  /** @domName SVGFEConvolveMatrixElement.targetY */
  SVGAnimatedInteger get targetY;
}

class _SVGFEConvolveMatrixElementImpl extends _SVGElementImpl implements SVGFEConvolveMatrixElement native "*SVGFEConvolveMatrixElement" {

  final _SVGAnimatedNumberImpl bias;

  final _SVGAnimatedNumberImpl divisor;

  final _SVGAnimatedEnumerationImpl edgeMode;

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedNumberListImpl kernelMatrix;

  final _SVGAnimatedNumberImpl kernelUnitLengthX;

  final _SVGAnimatedNumberImpl kernelUnitLengthY;

  final _SVGAnimatedIntegerImpl orderX;

  final _SVGAnimatedIntegerImpl orderY;

  final _SVGAnimatedBooleanImpl preserveAlpha;

  final _SVGAnimatedIntegerImpl targetX;

  final _SVGAnimatedIntegerImpl targetY;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDiffuseLightingElement
abstract class SVGFEDiffuseLightingElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEDiffuseLightingElement.diffuseConstant */
  SVGAnimatedNumber get diffuseConstant;

  /** @domName SVGFEDiffuseLightingElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEDiffuseLightingElement.kernelUnitLengthX */
  SVGAnimatedNumber get kernelUnitLengthX;

  /** @domName SVGFEDiffuseLightingElement.kernelUnitLengthY */
  SVGAnimatedNumber get kernelUnitLengthY;

  /** @domName SVGFEDiffuseLightingElement.surfaceScale */
  SVGAnimatedNumber get surfaceScale;
}

class _SVGFEDiffuseLightingElementImpl extends _SVGElementImpl implements SVGFEDiffuseLightingElement native "*SVGFEDiffuseLightingElement" {

  final _SVGAnimatedNumberImpl diffuseConstant;

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedNumberImpl kernelUnitLengthX;

  final _SVGAnimatedNumberImpl kernelUnitLengthY;

  final _SVGAnimatedNumberImpl surfaceScale;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDisplacementMapElement
abstract class SVGFEDisplacementMapElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  static const int SVG_CHANNEL_A = 4;

  static const int SVG_CHANNEL_B = 3;

  static const int SVG_CHANNEL_G = 2;

  static const int SVG_CHANNEL_R = 1;

  static const int SVG_CHANNEL_UNKNOWN = 0;

  /** @domName SVGFEDisplacementMapElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEDisplacementMapElement.in2 */
  SVGAnimatedString get in2;

  /** @domName SVGFEDisplacementMapElement.scale */
  SVGAnimatedNumber get scale;

  /** @domName SVGFEDisplacementMapElement.xChannelSelector */
  SVGAnimatedEnumeration get xChannelSelector;

  /** @domName SVGFEDisplacementMapElement.yChannelSelector */
  SVGAnimatedEnumeration get yChannelSelector;
}

class _SVGFEDisplacementMapElementImpl extends _SVGElementImpl implements SVGFEDisplacementMapElement native "*SVGFEDisplacementMapElement" {

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedStringImpl in2;

  final _SVGAnimatedNumberImpl scale;

  final _SVGAnimatedEnumerationImpl xChannelSelector;

  final _SVGAnimatedEnumerationImpl yChannelSelector;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDistantLightElement
abstract class SVGFEDistantLightElement implements SVGElement {

  /** @domName SVGFEDistantLightElement.azimuth */
  SVGAnimatedNumber get azimuth;

  /** @domName SVGFEDistantLightElement.elevation */
  SVGAnimatedNumber get elevation;
}

class _SVGFEDistantLightElementImpl extends _SVGElementImpl implements SVGFEDistantLightElement native "*SVGFEDistantLightElement" {

  final _SVGAnimatedNumberImpl azimuth;

  final _SVGAnimatedNumberImpl elevation;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDropShadowElement
abstract class SVGFEDropShadowElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEDropShadowElement.dx */
  SVGAnimatedNumber get dx;

  /** @domName SVGFEDropShadowElement.dy */
  SVGAnimatedNumber get dy;

  /** @domName SVGFEDropShadowElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEDropShadowElement.stdDeviationX */
  SVGAnimatedNumber get stdDeviationX;

  /** @domName SVGFEDropShadowElement.stdDeviationY */
  SVGAnimatedNumber get stdDeviationY;

  /** @domName SVGFEDropShadowElement.setStdDeviation */
  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}

class _SVGFEDropShadowElementImpl extends _SVGElementImpl implements SVGFEDropShadowElement native "*SVGFEDropShadowElement" {

  final _SVGAnimatedNumberImpl dx;

  final _SVGAnimatedNumberImpl dy;

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedNumberImpl stdDeviationX;

  final _SVGAnimatedNumberImpl stdDeviationY;

  void setStdDeviation(num stdDeviationX, num stdDeviationY) native;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFloodElement
abstract class SVGFEFloodElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {
}

class _SVGFEFloodElementImpl extends _SVGElementImpl implements SVGFEFloodElement native "*SVGFEFloodElement" {

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncAElement
abstract class SVGFEFuncAElement implements SVGComponentTransferFunctionElement {
}

class _SVGFEFuncAElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncAElement native "*SVGFEFuncAElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncBElement
abstract class SVGFEFuncBElement implements SVGComponentTransferFunctionElement {
}

class _SVGFEFuncBElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncBElement native "*SVGFEFuncBElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncGElement
abstract class SVGFEFuncGElement implements SVGComponentTransferFunctionElement {
}

class _SVGFEFuncGElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncGElement native "*SVGFEFuncGElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncRElement
abstract class SVGFEFuncRElement implements SVGComponentTransferFunctionElement {
}

class _SVGFEFuncRElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncRElement native "*SVGFEFuncRElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEGaussianBlurElement
abstract class SVGFEGaussianBlurElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEGaussianBlurElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEGaussianBlurElement.stdDeviationX */
  SVGAnimatedNumber get stdDeviationX;

  /** @domName SVGFEGaussianBlurElement.stdDeviationY */
  SVGAnimatedNumber get stdDeviationY;

  /** @domName SVGFEGaussianBlurElement.setStdDeviation */
  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}

class _SVGFEGaussianBlurElementImpl extends _SVGElementImpl implements SVGFEGaussianBlurElement native "*SVGFEGaussianBlurElement" {

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedNumberImpl stdDeviationX;

  final _SVGAnimatedNumberImpl stdDeviationY;

  void setStdDeviation(num stdDeviationX, num stdDeviationY) native;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEImageElement
abstract class SVGFEImageElement implements SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEImageElement.preserveAspectRatio */
  SVGAnimatedPreserveAspectRatio get preserveAspectRatio;
}

class _SVGFEImageElementImpl extends _SVGElementImpl implements SVGFEImageElement native "*SVGFEImageElement" {

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMergeElement
abstract class SVGFEMergeElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {
}

class _SVGFEMergeElementImpl extends _SVGElementImpl implements SVGFEMergeElement native "*SVGFEMergeElement" {

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMergeNodeElement
abstract class SVGFEMergeNodeElement implements SVGElement {

  /** @domName SVGFEMergeNodeElement.in1 */
  SVGAnimatedString get in1;
}

class _SVGFEMergeNodeElementImpl extends _SVGElementImpl implements SVGFEMergeNodeElement native "*SVGFEMergeNodeElement" {

  final _SVGAnimatedStringImpl in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMorphologyElement
abstract class SVGFEMorphologyElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  static const int SVG_MORPHOLOGY_OPERATOR_DILATE = 2;

  static const int SVG_MORPHOLOGY_OPERATOR_ERODE = 1;

  static const int SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;

  /** @domName SVGFEMorphologyElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFEMorphologyElement.operator */
  SVGAnimatedEnumeration get operator;

  /** @domName SVGFEMorphologyElement.radiusX */
  SVGAnimatedNumber get radiusX;

  /** @domName SVGFEMorphologyElement.radiusY */
  SVGAnimatedNumber get radiusY;

  /** @domName SVGFEMorphologyElement.setRadius */
  void setRadius(num radiusX, num radiusY);
}

class _SVGFEMorphologyElementImpl extends _SVGElementImpl implements SVGFEMorphologyElement native "*SVGFEMorphologyElement" {

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedEnumerationImpl operator;

  final _SVGAnimatedNumberImpl radiusX;

  final _SVGAnimatedNumberImpl radiusY;

  void setRadius(num radiusX, num radiusY) native;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEOffsetElement
abstract class SVGFEOffsetElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEOffsetElement.dx */
  SVGAnimatedNumber get dx;

  /** @domName SVGFEOffsetElement.dy */
  SVGAnimatedNumber get dy;

  /** @domName SVGFEOffsetElement.in1 */
  SVGAnimatedString get in1;
}

class _SVGFEOffsetElementImpl extends _SVGElementImpl implements SVGFEOffsetElement native "*SVGFEOffsetElement" {

  final _SVGAnimatedNumberImpl dx;

  final _SVGAnimatedNumberImpl dy;

  final _SVGAnimatedStringImpl in1;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEPointLightElement
abstract class SVGFEPointLightElement implements SVGElement {

  /** @domName SVGFEPointLightElement.x */
  SVGAnimatedNumber get x;

  /** @domName SVGFEPointLightElement.y */
  SVGAnimatedNumber get y;

  /** @domName SVGFEPointLightElement.z */
  SVGAnimatedNumber get z;
}

class _SVGFEPointLightElementImpl extends _SVGElementImpl implements SVGFEPointLightElement native "*SVGFEPointLightElement" {

  final _SVGAnimatedNumberImpl x;

  final _SVGAnimatedNumberImpl y;

  final _SVGAnimatedNumberImpl z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFESpecularLightingElement
abstract class SVGFESpecularLightingElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFESpecularLightingElement.in1 */
  SVGAnimatedString get in1;

  /** @domName SVGFESpecularLightingElement.specularConstant */
  SVGAnimatedNumber get specularConstant;

  /** @domName SVGFESpecularLightingElement.specularExponent */
  SVGAnimatedNumber get specularExponent;

  /** @domName SVGFESpecularLightingElement.surfaceScale */
  SVGAnimatedNumber get surfaceScale;
}

class _SVGFESpecularLightingElementImpl extends _SVGElementImpl implements SVGFESpecularLightingElement native "*SVGFESpecularLightingElement" {

  final _SVGAnimatedStringImpl in1;

  final _SVGAnimatedNumberImpl specularConstant;

  final _SVGAnimatedNumberImpl specularExponent;

  final _SVGAnimatedNumberImpl surfaceScale;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFESpotLightElement
abstract class SVGFESpotLightElement implements SVGElement {

  /** @domName SVGFESpotLightElement.limitingConeAngle */
  SVGAnimatedNumber get limitingConeAngle;

  /** @domName SVGFESpotLightElement.pointsAtX */
  SVGAnimatedNumber get pointsAtX;

  /** @domName SVGFESpotLightElement.pointsAtY */
  SVGAnimatedNumber get pointsAtY;

  /** @domName SVGFESpotLightElement.pointsAtZ */
  SVGAnimatedNumber get pointsAtZ;

  /** @domName SVGFESpotLightElement.specularExponent */
  SVGAnimatedNumber get specularExponent;

  /** @domName SVGFESpotLightElement.x */
  SVGAnimatedNumber get x;

  /** @domName SVGFESpotLightElement.y */
  SVGAnimatedNumber get y;

  /** @domName SVGFESpotLightElement.z */
  SVGAnimatedNumber get z;
}

class _SVGFESpotLightElementImpl extends _SVGElementImpl implements SVGFESpotLightElement native "*SVGFESpotLightElement" {

  final _SVGAnimatedNumberImpl limitingConeAngle;

  final _SVGAnimatedNumberImpl pointsAtX;

  final _SVGAnimatedNumberImpl pointsAtY;

  final _SVGAnimatedNumberImpl pointsAtZ;

  final _SVGAnimatedNumberImpl specularExponent;

  final _SVGAnimatedNumberImpl x;

  final _SVGAnimatedNumberImpl y;

  final _SVGAnimatedNumberImpl z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFETileElement
abstract class SVGFETileElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFETileElement.in1 */
  SVGAnimatedString get in1;
}

class _SVGFETileElementImpl extends _SVGElementImpl implements SVGFETileElement native "*SVGFETileElement" {

  final _SVGAnimatedStringImpl in1;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFETurbulenceElement
abstract class SVGFETurbulenceElement implements SVGElement, SVGFilterPrimitiveStandardAttributes {

  static const int SVG_STITCHTYPE_NOSTITCH = 2;

  static const int SVG_STITCHTYPE_STITCH = 1;

  static const int SVG_STITCHTYPE_UNKNOWN = 0;

  static const int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;

  static const int SVG_TURBULENCE_TYPE_TURBULENCE = 2;

  static const int SVG_TURBULENCE_TYPE_UNKNOWN = 0;

  /** @domName SVGFETurbulenceElement.baseFrequencyX */
  SVGAnimatedNumber get baseFrequencyX;

  /** @domName SVGFETurbulenceElement.baseFrequencyY */
  SVGAnimatedNumber get baseFrequencyY;

  /** @domName SVGFETurbulenceElement.numOctaves */
  SVGAnimatedInteger get numOctaves;

  /** @domName SVGFETurbulenceElement.seed */
  SVGAnimatedNumber get seed;

  /** @domName SVGFETurbulenceElement.stitchTiles */
  SVGAnimatedEnumeration get stitchTiles;

  /** @domName SVGFETurbulenceElement.type */
  SVGAnimatedEnumeration get type;
}

class _SVGFETurbulenceElementImpl extends _SVGElementImpl implements SVGFETurbulenceElement native "*SVGFETurbulenceElement" {

  final _SVGAnimatedNumberImpl baseFrequencyX;

  final _SVGAnimatedNumberImpl baseFrequencyY;

  final _SVGAnimatedIntegerImpl numOctaves;

  final _SVGAnimatedNumberImpl seed;

  final _SVGAnimatedEnumerationImpl stitchTiles;

  final _SVGAnimatedEnumerationImpl type;

  // From SVGFilterPrimitiveStandardAttributes

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedStringImpl result;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFilterElement
abstract class SVGFilterElement implements SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  /** @domName SVGFilterElement.filterResX */
  SVGAnimatedInteger get filterResX;

  /** @domName SVGFilterElement.filterResY */
  SVGAnimatedInteger get filterResY;

  /** @domName SVGFilterElement.filterUnits */
  SVGAnimatedEnumeration get filterUnits;

  /** @domName SVGFilterElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGFilterElement.primitiveUnits */
  SVGAnimatedEnumeration get primitiveUnits;

  /** @domName SVGFilterElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGFilterElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGFilterElement.y */
  SVGAnimatedLength get y;

  /** @domName SVGFilterElement.setFilterRes */
  void setFilterRes(int filterResX, int filterResY);
}

class _SVGFilterElementImpl extends _SVGElementImpl implements SVGFilterElement native "*SVGFilterElement" {

  final _SVGAnimatedIntegerImpl filterResX;

  final _SVGAnimatedIntegerImpl filterResY;

  final _SVGAnimatedEnumerationImpl filterUnits;

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedEnumerationImpl primitiveUnits;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  void setFilterRes(int filterResX, int filterResY) native;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFilterPrimitiveStandardAttributes
abstract class SVGFilterPrimitiveStandardAttributes implements SVGStylable {

  /** @domName SVGFilterPrimitiveStandardAttributes.height */
  SVGAnimatedLength get height;

  /** @domName SVGFilterPrimitiveStandardAttributes.result */
  SVGAnimatedString get result;

  /** @domName SVGFilterPrimitiveStandardAttributes.width */
  SVGAnimatedLength get width;

  /** @domName SVGFilterPrimitiveStandardAttributes.x */
  SVGAnimatedLength get x;

  /** @domName SVGFilterPrimitiveStandardAttributes.y */
  SVGAnimatedLength get y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFitToViewBox
abstract class SVGFitToViewBox {

  /** @domName SVGFitToViewBox.preserveAspectRatio */
  SVGAnimatedPreserveAspectRatio get preserveAspectRatio;

  /** @domName SVGFitToViewBox.viewBox */
  SVGAnimatedRect get viewBox;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontElement
abstract class SVGFontElement implements SVGElement {
}

class _SVGFontElementImpl extends _SVGElementImpl implements SVGFontElement native "*SVGFontElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceElement
abstract class SVGFontFaceElement implements SVGElement {
}

class _SVGFontFaceElementImpl extends _SVGElementImpl implements SVGFontFaceElement native "*SVGFontFaceElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceFormatElement
abstract class SVGFontFaceFormatElement implements SVGElement {
}

class _SVGFontFaceFormatElementImpl extends _SVGElementImpl implements SVGFontFaceFormatElement native "*SVGFontFaceFormatElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceNameElement
abstract class SVGFontFaceNameElement implements SVGElement {
}

class _SVGFontFaceNameElementImpl extends _SVGElementImpl implements SVGFontFaceNameElement native "*SVGFontFaceNameElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceSrcElement
abstract class SVGFontFaceSrcElement implements SVGElement {
}

class _SVGFontFaceSrcElementImpl extends _SVGElementImpl implements SVGFontFaceSrcElement native "*SVGFontFaceSrcElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceUriElement
abstract class SVGFontFaceUriElement implements SVGElement {
}

class _SVGFontFaceUriElementImpl extends _SVGElementImpl implements SVGFontFaceUriElement native "*SVGFontFaceUriElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGForeignObjectElement
abstract class SVGForeignObjectElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGForeignObjectElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGForeignObjectElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGForeignObjectElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGForeignObjectElement.y */
  SVGAnimatedLength get y;
}

class _SVGForeignObjectElementImpl extends _SVGElementImpl implements SVGForeignObjectElement native "*SVGForeignObjectElement" {

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGElement
abstract class SVGGElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}

class _SVGGElementImpl extends _SVGElementImpl implements SVGGElement native "*SVGGElement" {

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGlyphElement
abstract class SVGGlyphElement implements SVGElement {
}

class _SVGGlyphElementImpl extends _SVGElementImpl implements SVGGlyphElement native "*SVGGlyphElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGlyphRefElement
abstract class SVGGlyphRefElement implements SVGElement, SVGURIReference, SVGStylable {

  /** @domName SVGGlyphRefElement.dx */
  num dx;

  /** @domName SVGGlyphRefElement.dy */
  num dy;

  /** @domName SVGGlyphRefElement.format */
  String format;

  /** @domName SVGGlyphRefElement.glyphRef */
  String glyphRef;

  /** @domName SVGGlyphRefElement.x */
  num x;

  /** @domName SVGGlyphRefElement.y */
  num y;
}

class _SVGGlyphRefElementImpl extends _SVGElementImpl implements SVGGlyphRefElement native "*SVGGlyphRefElement" {

  num dx;

  num dy;

  String format;

  String glyphRef;

  num x;

  num y;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGradientElement
abstract class SVGGradientElement implements SVGElement, SVGURIReference, SVGExternalResourcesRequired, SVGStylable {

  static const int SVG_SPREADMETHOD_PAD = 1;

  static const int SVG_SPREADMETHOD_REFLECT = 2;

  static const int SVG_SPREADMETHOD_REPEAT = 3;

  static const int SVG_SPREADMETHOD_UNKNOWN = 0;

  /** @domName SVGGradientElement.gradientTransform */
  SVGAnimatedTransformList get gradientTransform;

  /** @domName SVGGradientElement.gradientUnits */
  SVGAnimatedEnumeration get gradientUnits;

  /** @domName SVGGradientElement.spreadMethod */
  SVGAnimatedEnumeration get spreadMethod;
}

class _SVGGradientElementImpl extends _SVGElementImpl implements SVGGradientElement native "*SVGGradientElement" {

  final _SVGAnimatedTransformListImpl gradientTransform;

  final _SVGAnimatedEnumerationImpl gradientUnits;

  final _SVGAnimatedEnumerationImpl spreadMethod;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGHKernElement
abstract class SVGHKernElement implements SVGElement {
}

class _SVGHKernElementImpl extends _SVGElementImpl implements SVGHKernElement native "*SVGHKernElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGImageElement
abstract class SVGImageElement implements SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGImageElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGImageElement.preserveAspectRatio */
  SVGAnimatedPreserveAspectRatio get preserveAspectRatio;

  /** @domName SVGImageElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGImageElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGImageElement.y */
  SVGAnimatedLength get y;
}

class _SVGImageElementImpl extends _SVGElementImpl implements SVGImageElement native "*SVGImageElement" {

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLangSpace
abstract class SVGLangSpace {

  /** @domName SVGLangSpace.xmllang */
  String xmllang;

  /** @domName SVGLangSpace.xmlspace */
  String xmlspace;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLength
abstract class SVGLength {

  static const int SVG_LENGTHTYPE_CM = 6;

  static const int SVG_LENGTHTYPE_EMS = 3;

  static const int SVG_LENGTHTYPE_EXS = 4;

  static const int SVG_LENGTHTYPE_IN = 8;

  static const int SVG_LENGTHTYPE_MM = 7;

  static const int SVG_LENGTHTYPE_NUMBER = 1;

  static const int SVG_LENGTHTYPE_PC = 10;

  static const int SVG_LENGTHTYPE_PERCENTAGE = 2;

  static const int SVG_LENGTHTYPE_PT = 9;

  static const int SVG_LENGTHTYPE_PX = 5;

  static const int SVG_LENGTHTYPE_UNKNOWN = 0;

  /** @domName SVGLength.unitType */
  int get unitType;

  /** @domName SVGLength.value */
  num value;

  /** @domName SVGLength.valueAsString */
  String valueAsString;

  /** @domName SVGLength.valueInSpecifiedUnits */
  num valueInSpecifiedUnits;

  /** @domName SVGLength.convertToSpecifiedUnits */
  void convertToSpecifiedUnits(int unitType);

  /** @domName SVGLength.newValueSpecifiedUnits */
  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}

class _SVGLengthImpl implements SVGLength native "*SVGLength" {

  final int unitType;

  num value;

  String valueAsString;

  num valueInSpecifiedUnits;

  void convertToSpecifiedUnits(int unitType) native;

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLengthList
abstract class SVGLengthList implements List<SVGLength> {

  /** @domName SVGLengthList.numberOfItems */
  int get numberOfItems;

  /** @domName SVGLengthList.appendItem */
  SVGLength appendItem(SVGLength item);

  /** @domName SVGLengthList.clear */
  void clear();

  /** @domName SVGLengthList.getItem */
  SVGLength getItem(int index);

  /** @domName SVGLengthList.initialize */
  SVGLength initialize(SVGLength item);

  /** @domName SVGLengthList.insertItemBefore */
  SVGLength insertItemBefore(SVGLength item, int index);

  /** @domName SVGLengthList.removeItem */
  SVGLength removeItem(int index);

  /** @domName SVGLengthList.replaceItem */
  SVGLength replaceItem(SVGLength item, int index);
}

class _SVGLengthListImpl implements SVGLengthList, JavaScriptIndexingBehavior native "*SVGLengthList" {

  final int numberOfItems;

  _SVGLengthImpl operator[](int index) => JS("_SVGLengthImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGLengthImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGLength> mixins.
  // SVGLength is the element type.

  // From Iterable<SVGLength>:

  Iterator<SVGLength> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGLength>(this);
  }

  // From Collection<SVGLength>:

  void add(SVGLength value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGLength value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGLength> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGLength element) => _Collections.contains(this, element);

  void forEach(void f(SVGLength element)) => _Collections.forEach(this, f);

  Collection map(f(SVGLength element)) => _Collections.map(this, [], f);

  Collection<SVGLength> filter(bool f(SVGLength element)) =>
     _Collections.filter(this, <SVGLength>[], f);

  bool every(bool f(SVGLength element)) => _Collections.every(this, f);

  bool some(bool f(SVGLength element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGLength>:

  void sort([Comparator<SVGLength> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGLength element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGLength element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGLength get last => this[length - 1];

  SVGLength removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGLength> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGLength initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGLength> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGLength>[]);

  // -- end List<SVGLength> mixins.

  _SVGLengthImpl appendItem(_SVGLengthImpl item) native;

  void clear() native;

  _SVGLengthImpl getItem(int index) native;

  _SVGLengthImpl initialize(_SVGLengthImpl item) native;

  _SVGLengthImpl insertItemBefore(_SVGLengthImpl item, int index) native;

  _SVGLengthImpl removeItem(int index) native;

  _SVGLengthImpl replaceItem(_SVGLengthImpl item, int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLineElement
abstract class SVGLineElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGLineElement.x1 */
  SVGAnimatedLength get x1;

  /** @domName SVGLineElement.x2 */
  SVGAnimatedLength get x2;

  /** @domName SVGLineElement.y1 */
  SVGAnimatedLength get y1;

  /** @domName SVGLineElement.y2 */
  SVGAnimatedLength get y2;
}

class _SVGLineElementImpl extends _SVGElementImpl implements SVGLineElement native "*SVGLineElement" {

  final _SVGAnimatedLengthImpl x1;

  final _SVGAnimatedLengthImpl x2;

  final _SVGAnimatedLengthImpl y1;

  final _SVGAnimatedLengthImpl y2;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLinearGradientElement
abstract class SVGLinearGradientElement implements SVGGradientElement {

  /** @domName SVGLinearGradientElement.x1 */
  SVGAnimatedLength get x1;

  /** @domName SVGLinearGradientElement.x2 */
  SVGAnimatedLength get x2;

  /** @domName SVGLinearGradientElement.y1 */
  SVGAnimatedLength get y1;

  /** @domName SVGLinearGradientElement.y2 */
  SVGAnimatedLength get y2;
}

class _SVGLinearGradientElementImpl extends _SVGGradientElementImpl implements SVGLinearGradientElement native "*SVGLinearGradientElement" {

  final _SVGAnimatedLengthImpl x1;

  final _SVGAnimatedLengthImpl x2;

  final _SVGAnimatedLengthImpl y1;

  final _SVGAnimatedLengthImpl y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLocatable
abstract class SVGLocatable {

  /** @domName SVGLocatable.farthestViewportElement */
  SVGElement get farthestViewportElement;

  /** @domName SVGLocatable.nearestViewportElement */
  SVGElement get nearestViewportElement;

  /** @domName SVGLocatable.getBBox */
  SVGRect getBBox();

  /** @domName SVGLocatable.getCTM */
  SVGMatrix getCTM();

  /** @domName SVGLocatable.getScreenCTM */
  SVGMatrix getScreenCTM();

  /** @domName SVGLocatable.getTransformToElement */
  SVGMatrix getTransformToElement(SVGElement element);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMPathElement
abstract class SVGMPathElement implements SVGElement, SVGURIReference, SVGExternalResourcesRequired {
}

class _SVGMPathElementImpl extends _SVGElementImpl implements SVGMPathElement native "*SVGMPathElement" {

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMarkerElement
abstract class SVGMarkerElement implements SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  static const int SVG_MARKERUNITS_STROKEWIDTH = 2;

  static const int SVG_MARKERUNITS_UNKNOWN = 0;

  static const int SVG_MARKERUNITS_USERSPACEONUSE = 1;

  static const int SVG_MARKER_ORIENT_ANGLE = 2;

  static const int SVG_MARKER_ORIENT_AUTO = 1;

  static const int SVG_MARKER_ORIENT_UNKNOWN = 0;

  /** @domName SVGMarkerElement.markerHeight */
  SVGAnimatedLength get markerHeight;

  /** @domName SVGMarkerElement.markerUnits */
  SVGAnimatedEnumeration get markerUnits;

  /** @domName SVGMarkerElement.markerWidth */
  SVGAnimatedLength get markerWidth;

  /** @domName SVGMarkerElement.orientAngle */
  SVGAnimatedAngle get orientAngle;

  /** @domName SVGMarkerElement.orientType */
  SVGAnimatedEnumeration get orientType;

  /** @domName SVGMarkerElement.refX */
  SVGAnimatedLength get refX;

  /** @domName SVGMarkerElement.refY */
  SVGAnimatedLength get refY;

  /** @domName SVGMarkerElement.setOrientToAngle */
  void setOrientToAngle(SVGAngle angle);

  /** @domName SVGMarkerElement.setOrientToAuto */
  void setOrientToAuto();
}

class _SVGMarkerElementImpl extends _SVGElementImpl implements SVGMarkerElement native "*SVGMarkerElement" {

  final _SVGAnimatedLengthImpl markerHeight;

  final _SVGAnimatedEnumerationImpl markerUnits;

  final _SVGAnimatedLengthImpl markerWidth;

  final _SVGAnimatedAngleImpl orientAngle;

  final _SVGAnimatedEnumerationImpl orientType;

  final _SVGAnimatedLengthImpl refX;

  final _SVGAnimatedLengthImpl refY;

  void setOrientToAngle(_SVGAngleImpl angle) native;

  void setOrientToAuto() native;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGFitToViewBox

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  final _SVGAnimatedRectImpl viewBox;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMaskElement
abstract class SVGMaskElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  /** @domName SVGMaskElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGMaskElement.maskContentUnits */
  SVGAnimatedEnumeration get maskContentUnits;

  /** @domName SVGMaskElement.maskUnits */
  SVGAnimatedEnumeration get maskUnits;

  /** @domName SVGMaskElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGMaskElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGMaskElement.y */
  SVGAnimatedLength get y;
}

class _SVGMaskElementImpl extends _SVGElementImpl implements SVGMaskElement native "*SVGMaskElement" {

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedEnumerationImpl maskContentUnits;

  final _SVGAnimatedEnumerationImpl maskUnits;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMatrix
abstract class SVGMatrix {

  /** @domName SVGMatrix.a */
  num a;

  /** @domName SVGMatrix.b */
  num b;

  /** @domName SVGMatrix.c */
  num c;

  /** @domName SVGMatrix.d */
  num d;

  /** @domName SVGMatrix.e */
  num e;

  /** @domName SVGMatrix.f */
  num f;

  /** @domName SVGMatrix.flipX */
  SVGMatrix flipX();

  /** @domName SVGMatrix.flipY */
  SVGMatrix flipY();

  /** @domName SVGMatrix.inverse */
  SVGMatrix inverse();

  /** @domName SVGMatrix.multiply */
  SVGMatrix multiply(SVGMatrix secondMatrix);

  /** @domName SVGMatrix.rotate */
  SVGMatrix rotate(num angle);

  /** @domName SVGMatrix.rotateFromVector */
  SVGMatrix rotateFromVector(num x, num y);

  /** @domName SVGMatrix.scale */
  SVGMatrix scale(num scaleFactor);

  /** @domName SVGMatrix.scaleNonUniform */
  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY);

  /** @domName SVGMatrix.skewX */
  SVGMatrix skewX(num angle);

  /** @domName SVGMatrix.skewY */
  SVGMatrix skewY(num angle);

  /** @domName SVGMatrix.translate */
  SVGMatrix translate(num x, num y);
}

class _SVGMatrixImpl implements SVGMatrix native "*SVGMatrix" {

  num a;

  num b;

  num c;

  num d;

  num e;

  num f;

  _SVGMatrixImpl flipX() native;

  _SVGMatrixImpl flipY() native;

  _SVGMatrixImpl inverse() native;

  _SVGMatrixImpl multiply(_SVGMatrixImpl secondMatrix) native;

  _SVGMatrixImpl rotate(num angle) native;

  _SVGMatrixImpl rotateFromVector(num x, num y) native;

  _SVGMatrixImpl scale(num scaleFactor) native;

  _SVGMatrixImpl scaleNonUniform(num scaleFactorX, num scaleFactorY) native;

  _SVGMatrixImpl skewX(num angle) native;

  _SVGMatrixImpl skewY(num angle) native;

  _SVGMatrixImpl translate(num x, num y) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMetadataElement
abstract class SVGMetadataElement implements SVGElement {
}

class _SVGMetadataElementImpl extends _SVGElementImpl implements SVGMetadataElement native "*SVGMetadataElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMissingGlyphElement
abstract class SVGMissingGlyphElement implements SVGElement {
}

class _SVGMissingGlyphElementImpl extends _SVGElementImpl implements SVGMissingGlyphElement native "*SVGMissingGlyphElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGNumber
abstract class SVGNumber {

  /** @domName SVGNumber.value */
  num value;
}

class _SVGNumberImpl implements SVGNumber native "*SVGNumber" {

  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGNumberList
abstract class SVGNumberList implements List<SVGNumber> {

  /** @domName SVGNumberList.numberOfItems */
  int get numberOfItems;

  /** @domName SVGNumberList.appendItem */
  SVGNumber appendItem(SVGNumber item);

  /** @domName SVGNumberList.clear */
  void clear();

  /** @domName SVGNumberList.getItem */
  SVGNumber getItem(int index);

  /** @domName SVGNumberList.initialize */
  SVGNumber initialize(SVGNumber item);

  /** @domName SVGNumberList.insertItemBefore */
  SVGNumber insertItemBefore(SVGNumber item, int index);

  /** @domName SVGNumberList.removeItem */
  SVGNumber removeItem(int index);

  /** @domName SVGNumberList.replaceItem */
  SVGNumber replaceItem(SVGNumber item, int index);
}

class _SVGNumberListImpl implements SVGNumberList, JavaScriptIndexingBehavior native "*SVGNumberList" {

  final int numberOfItems;

  _SVGNumberImpl operator[](int index) => JS("_SVGNumberImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGNumberImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGNumber> mixins.
  // SVGNumber is the element type.

  // From Iterable<SVGNumber>:

  Iterator<SVGNumber> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGNumber>(this);
  }

  // From Collection<SVGNumber>:

  void add(SVGNumber value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGNumber value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGNumber> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGNumber element) => _Collections.contains(this, element);

  void forEach(void f(SVGNumber element)) => _Collections.forEach(this, f);

  Collection map(f(SVGNumber element)) => _Collections.map(this, [], f);

  Collection<SVGNumber> filter(bool f(SVGNumber element)) =>
     _Collections.filter(this, <SVGNumber>[], f);

  bool every(bool f(SVGNumber element)) => _Collections.every(this, f);

  bool some(bool f(SVGNumber element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGNumber>:

  void sort([Comparator<SVGNumber> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGNumber element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGNumber element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGNumber get last => this[length - 1];

  SVGNumber removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGNumber> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGNumber initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGNumber> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGNumber>[]);

  // -- end List<SVGNumber> mixins.

  _SVGNumberImpl appendItem(_SVGNumberImpl item) native;

  void clear() native;

  _SVGNumberImpl getItem(int index) native;

  _SVGNumberImpl initialize(_SVGNumberImpl item) native;

  _SVGNumberImpl insertItemBefore(_SVGNumberImpl item, int index) native;

  _SVGNumberImpl removeItem(int index) native;

  _SVGNumberImpl replaceItem(_SVGNumberImpl item, int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPaint
abstract class SVGPaint implements SVGColor {

  static const int SVG_PAINTTYPE_CURRENTCOLOR = 102;

  static const int SVG_PAINTTYPE_NONE = 101;

  static const int SVG_PAINTTYPE_RGBCOLOR = 1;

  static const int SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR = 2;

  static const int SVG_PAINTTYPE_UNKNOWN = 0;

  static const int SVG_PAINTTYPE_URI = 107;

  static const int SVG_PAINTTYPE_URI_CURRENTCOLOR = 104;

  static const int SVG_PAINTTYPE_URI_NONE = 103;

  static const int SVG_PAINTTYPE_URI_RGBCOLOR = 105;

  static const int SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR = 106;

  /** @domName SVGPaint.paintType */
  int get paintType;

  /** @domName SVGPaint.uri */
  String get uri;

  /** @domName SVGPaint.setPaint */
  void setPaint(int paintType, String uri, String rgbColor, String iccColor);

  /** @domName SVGPaint.setUri */
  void setUri(String uri);
}

class _SVGPaintImpl extends _SVGColorImpl implements SVGPaint native "*SVGPaint" {

  final int paintType;

  final String uri;

  void setPaint(int paintType, String uri, String rgbColor, String iccColor) native;

  void setUri(String uri) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathElement
abstract class SVGPathElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPathElement.animatedNormalizedPathSegList */
  SVGPathSegList get animatedNormalizedPathSegList;

  /** @domName SVGPathElement.animatedPathSegList */
  SVGPathSegList get animatedPathSegList;

  /** @domName SVGPathElement.normalizedPathSegList */
  SVGPathSegList get normalizedPathSegList;

  /** @domName SVGPathElement.pathLength */
  SVGAnimatedNumber get pathLength;

  /** @domName SVGPathElement.pathSegList */
  SVGPathSegList get pathSegList;

  /** @domName SVGPathElement.createSVGPathSegArcAbs */
  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  /** @domName SVGPathElement.createSVGPathSegArcRel */
  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  /** @domName SVGPathElement.createSVGPathSegClosePath */
  SVGPathSegClosePath createSVGPathSegClosePath();

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicAbs */
  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicRel */
  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicSmoothAbs */
  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicSmoothRel */
  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticAbs */
  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticRel */
  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothAbs */
  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothRel */
  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoAbs */
  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoHorizontalAbs */
  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x);

  /** @domName SVGPathElement.createSVGPathSegLinetoHorizontalRel */
  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x);

  /** @domName SVGPathElement.createSVGPathSegLinetoRel */
  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoVerticalAbs */
  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoVerticalRel */
  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y);

  /** @domName SVGPathElement.createSVGPathSegMovetoAbs */
  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegMovetoRel */
  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y);

  /** @domName SVGPathElement.getPathSegAtLength */
  int getPathSegAtLength(num distance);

  /** @domName SVGPathElement.getPointAtLength */
  SVGPoint getPointAtLength(num distance);

  /** @domName SVGPathElement.getTotalLength */
  num getTotalLength();
}

class _SVGPathElementImpl extends _SVGElementImpl implements SVGPathElement native "*SVGPathElement" {

  final _SVGPathSegListImpl animatedNormalizedPathSegList;

  final _SVGPathSegListImpl animatedPathSegList;

  final _SVGPathSegListImpl normalizedPathSegList;

  final _SVGAnimatedNumberImpl pathLength;

  final _SVGPathSegListImpl pathSegList;

  _SVGPathSegArcAbsImpl createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;

  _SVGPathSegArcRelImpl createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;

  _SVGPathSegClosePathImpl createSVGPathSegClosePath() native;

  _SVGPathSegCurvetoCubicAbsImpl createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) native;

  _SVGPathSegCurvetoCubicRelImpl createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) native;

  _SVGPathSegCurvetoCubicSmoothAbsImpl createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) native;

  _SVGPathSegCurvetoCubicSmoothRelImpl createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) native;

  _SVGPathSegCurvetoQuadraticAbsImpl createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) native;

  _SVGPathSegCurvetoQuadraticRelImpl createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) native;

  _SVGPathSegCurvetoQuadraticSmoothAbsImpl createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y) native;

  _SVGPathSegCurvetoQuadraticSmoothRelImpl createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y) native;

  _SVGPathSegLinetoAbsImpl createSVGPathSegLinetoAbs(num x, num y) native;

  _SVGPathSegLinetoHorizontalAbsImpl createSVGPathSegLinetoHorizontalAbs(num x) native;

  _SVGPathSegLinetoHorizontalRelImpl createSVGPathSegLinetoHorizontalRel(num x) native;

  _SVGPathSegLinetoRelImpl createSVGPathSegLinetoRel(num x, num y) native;

  _SVGPathSegLinetoVerticalAbsImpl createSVGPathSegLinetoVerticalAbs(num y) native;

  _SVGPathSegLinetoVerticalRelImpl createSVGPathSegLinetoVerticalRel(num y) native;

  _SVGPathSegMovetoAbsImpl createSVGPathSegMovetoAbs(num x, num y) native;

  _SVGPathSegMovetoRelImpl createSVGPathSegMovetoRel(num x, num y) native;

  int getPathSegAtLength(num distance) native;

  _SVGPointImpl getPointAtLength(num distance) native;

  num getTotalLength() native;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSeg
abstract class SVGPathSeg {

  static const int PATHSEG_ARC_ABS = 10;

  static const int PATHSEG_ARC_REL = 11;

  static const int PATHSEG_CLOSEPATH = 1;

  static const int PATHSEG_CURVETO_CUBIC_ABS = 6;

  static const int PATHSEG_CURVETO_CUBIC_REL = 7;

  static const int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;

  static const int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;

  static const int PATHSEG_CURVETO_QUADRATIC_ABS = 8;

  static const int PATHSEG_CURVETO_QUADRATIC_REL = 9;

  static const int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;

  static const int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

  static const int PATHSEG_LINETO_ABS = 4;

  static const int PATHSEG_LINETO_HORIZONTAL_ABS = 12;

  static const int PATHSEG_LINETO_HORIZONTAL_REL = 13;

  static const int PATHSEG_LINETO_REL = 5;

  static const int PATHSEG_LINETO_VERTICAL_ABS = 14;

  static const int PATHSEG_LINETO_VERTICAL_REL = 15;

  static const int PATHSEG_MOVETO_ABS = 2;

  static const int PATHSEG_MOVETO_REL = 3;

  static const int PATHSEG_UNKNOWN = 0;

  /** @domName SVGPathSeg.pathSegType */
  int get pathSegType;

  /** @domName SVGPathSeg.pathSegTypeAsLetter */
  String get pathSegTypeAsLetter;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegArcAbs
abstract class SVGPathSegArcAbs implements SVGPathSeg {

  /** @domName SVGPathSegArcAbs.angle */
  num angle;

  /** @domName SVGPathSegArcAbs.largeArcFlag */
  bool largeArcFlag;

  /** @domName SVGPathSegArcAbs.r1 */
  num r1;

  /** @domName SVGPathSegArcAbs.r2 */
  num r2;

  /** @domName SVGPathSegArcAbs.sweepFlag */
  bool sweepFlag;

  /** @domName SVGPathSegArcAbs.x */
  num x;

  /** @domName SVGPathSegArcAbs.y */
  num y;
}

class _SVGPathSegArcAbsImpl extends _SVGPathSegImpl implements SVGPathSegArcAbs native "*SVGPathSegArcAbs" {

  num angle;

  bool largeArcFlag;

  num r1;

  num r2;

  bool sweepFlag;

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegArcRel
abstract class SVGPathSegArcRel implements SVGPathSeg {

  /** @domName SVGPathSegArcRel.angle */
  num angle;

  /** @domName SVGPathSegArcRel.largeArcFlag */
  bool largeArcFlag;

  /** @domName SVGPathSegArcRel.r1 */
  num r1;

  /** @domName SVGPathSegArcRel.r2 */
  num r2;

  /** @domName SVGPathSegArcRel.sweepFlag */
  bool sweepFlag;

  /** @domName SVGPathSegArcRel.x */
  num x;

  /** @domName SVGPathSegArcRel.y */
  num y;
}

class _SVGPathSegArcRelImpl extends _SVGPathSegImpl implements SVGPathSegArcRel native "*SVGPathSegArcRel" {

  num angle;

  bool largeArcFlag;

  num r1;

  num r2;

  bool sweepFlag;

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegClosePath
abstract class SVGPathSegClosePath implements SVGPathSeg {
}

class _SVGPathSegClosePathImpl extends _SVGPathSegImpl implements SVGPathSegClosePath native "*SVGPathSegClosePath" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicAbs
abstract class SVGPathSegCurvetoCubicAbs implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicAbs.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoCubicAbs.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicAbs.y1 */
  num y1;

  /** @domName SVGPathSegCurvetoCubicAbs.y2 */
  num y2;
}

class _SVGPathSegCurvetoCubicAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicAbs native "*SVGPathSegCurvetoCubicAbs" {

  num x;

  num x1;

  num x2;

  num y;

  num y1;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicRel
abstract class SVGPathSegCurvetoCubicRel implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicRel.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicRel.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoCubicRel.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicRel.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicRel.y1 */
  num y1;

  /** @domName SVGPathSegCurvetoCubicRel.y2 */
  num y2;
}

class _SVGPathSegCurvetoCubicRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicRel native "*SVGPathSegCurvetoCubicRel" {

  num x;

  num x1;

  num x2;

  num y;

  num y1;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicSmoothAbs
abstract class SVGPathSegCurvetoCubicSmoothAbs implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.y2 */
  num y2;
}

class _SVGPathSegCurvetoCubicSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothAbs native "*SVGPathSegCurvetoCubicSmoothAbs" {

  num x;

  num x2;

  num y;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicSmoothRel
abstract class SVGPathSegCurvetoCubicSmoothRel implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicSmoothRel.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.y2 */
  num y2;
}

class _SVGPathSegCurvetoCubicSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothRel native "*SVGPathSegCurvetoCubicSmoothRel" {

  num x;

  num x2;

  num y;

  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticAbs
abstract class SVGPathSegCurvetoQuadraticAbs implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticAbs.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoQuadraticAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoQuadraticAbs.y1 */
  num y1;
}

class _SVGPathSegCurvetoQuadraticAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticAbs native "*SVGPathSegCurvetoQuadraticAbs" {

  num x;

  num x1;

  num y;

  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticRel
abstract class SVGPathSegCurvetoQuadraticRel implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticRel.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticRel.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoQuadraticRel.y */
  num y;

  /** @domName SVGPathSegCurvetoQuadraticRel.y1 */
  num y1;
}

class _SVGPathSegCurvetoQuadraticRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticRel native "*SVGPathSegCurvetoQuadraticRel" {

  num x;

  num x1;

  num y;

  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticSmoothAbs
abstract class SVGPathSegCurvetoQuadraticSmoothAbs implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticSmoothAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticSmoothAbs.y */
  num y;
}

class _SVGPathSegCurvetoQuadraticSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothAbs native "*SVGPathSegCurvetoQuadraticSmoothAbs" {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticSmoothRel
abstract class SVGPathSegCurvetoQuadraticSmoothRel implements SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticSmoothRel.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticSmoothRel.y */
  num y;
}

class _SVGPathSegCurvetoQuadraticSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothRel native "*SVGPathSegCurvetoQuadraticSmoothRel" {

  num x;

  num y;
}

class _SVGPathSegImpl implements SVGPathSeg native "*SVGPathSeg" {

  final int pathSegType;

  final String pathSegTypeAsLetter;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoAbs
abstract class SVGPathSegLinetoAbs implements SVGPathSeg {

  /** @domName SVGPathSegLinetoAbs.x */
  num x;

  /** @domName SVGPathSegLinetoAbs.y */
  num y;
}

class _SVGPathSegLinetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoAbs native "*SVGPathSegLinetoAbs" {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoHorizontalAbs
abstract class SVGPathSegLinetoHorizontalAbs implements SVGPathSeg {

  /** @domName SVGPathSegLinetoHorizontalAbs.x */
  num x;
}

class _SVGPathSegLinetoHorizontalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalAbs native "*SVGPathSegLinetoHorizontalAbs" {

  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoHorizontalRel
abstract class SVGPathSegLinetoHorizontalRel implements SVGPathSeg {

  /** @domName SVGPathSegLinetoHorizontalRel.x */
  num x;
}

class _SVGPathSegLinetoHorizontalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalRel native "*SVGPathSegLinetoHorizontalRel" {

  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoRel
abstract class SVGPathSegLinetoRel implements SVGPathSeg {

  /** @domName SVGPathSegLinetoRel.x */
  num x;

  /** @domName SVGPathSegLinetoRel.y */
  num y;
}

class _SVGPathSegLinetoRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoRel native "*SVGPathSegLinetoRel" {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoVerticalAbs
abstract class SVGPathSegLinetoVerticalAbs implements SVGPathSeg {

  /** @domName SVGPathSegLinetoVerticalAbs.y */
  num y;
}

class _SVGPathSegLinetoVerticalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalAbs native "*SVGPathSegLinetoVerticalAbs" {

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoVerticalRel
abstract class SVGPathSegLinetoVerticalRel implements SVGPathSeg {

  /** @domName SVGPathSegLinetoVerticalRel.y */
  num y;
}

class _SVGPathSegLinetoVerticalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalRel native "*SVGPathSegLinetoVerticalRel" {

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegList
abstract class SVGPathSegList implements List<SVGPathSeg> {

  /** @domName SVGPathSegList.numberOfItems */
  int get numberOfItems;

  /** @domName SVGPathSegList.appendItem */
  SVGPathSeg appendItem(SVGPathSeg newItem);

  /** @domName SVGPathSegList.clear */
  void clear();

  /** @domName SVGPathSegList.getItem */
  SVGPathSeg getItem(int index);

  /** @domName SVGPathSegList.initialize */
  SVGPathSeg initialize(SVGPathSeg newItem);

  /** @domName SVGPathSegList.insertItemBefore */
  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index);

  /** @domName SVGPathSegList.removeItem */
  SVGPathSeg removeItem(int index);

  /** @domName SVGPathSegList.replaceItem */
  SVGPathSeg replaceItem(SVGPathSeg newItem, int index);
}

class _SVGPathSegListImpl implements SVGPathSegList, JavaScriptIndexingBehavior native "*SVGPathSegList" {

  final int numberOfItems;

  _SVGPathSegImpl operator[](int index) => JS("_SVGPathSegImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGPathSegImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGPathSeg> mixins.
  // SVGPathSeg is the element type.

  // From Iterable<SVGPathSeg>:

  Iterator<SVGPathSeg> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGPathSeg>(this);
  }

  // From Collection<SVGPathSeg>:

  void add(SVGPathSeg value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGPathSeg value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGPathSeg> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGPathSeg element) => _Collections.contains(this, element);

  void forEach(void f(SVGPathSeg element)) => _Collections.forEach(this, f);

  Collection map(f(SVGPathSeg element)) => _Collections.map(this, [], f);

  Collection<SVGPathSeg> filter(bool f(SVGPathSeg element)) =>
     _Collections.filter(this, <SVGPathSeg>[], f);

  bool every(bool f(SVGPathSeg element)) => _Collections.every(this, f);

  bool some(bool f(SVGPathSeg element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGPathSeg>:

  void sort([Comparator<SVGPathSeg> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGPathSeg element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGPathSeg element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGPathSeg get last => this[length - 1];

  SVGPathSeg removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGPathSeg> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGPathSeg initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGPathSeg> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGPathSeg>[]);

  // -- end List<SVGPathSeg> mixins.

  _SVGPathSegImpl appendItem(_SVGPathSegImpl newItem) native;

  void clear() native;

  _SVGPathSegImpl getItem(int index) native;

  _SVGPathSegImpl initialize(_SVGPathSegImpl newItem) native;

  _SVGPathSegImpl insertItemBefore(_SVGPathSegImpl newItem, int index) native;

  _SVGPathSegImpl removeItem(int index) native;

  _SVGPathSegImpl replaceItem(_SVGPathSegImpl newItem, int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegMovetoAbs
abstract class SVGPathSegMovetoAbs implements SVGPathSeg {

  /** @domName SVGPathSegMovetoAbs.x */
  num x;

  /** @domName SVGPathSegMovetoAbs.y */
  num y;
}

class _SVGPathSegMovetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegMovetoAbs native "*SVGPathSegMovetoAbs" {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegMovetoRel
abstract class SVGPathSegMovetoRel implements SVGPathSeg {

  /** @domName SVGPathSegMovetoRel.x */
  num x;

  /** @domName SVGPathSegMovetoRel.y */
  num y;
}

class _SVGPathSegMovetoRelImpl extends _SVGPathSegImpl implements SVGPathSegMovetoRel native "*SVGPathSegMovetoRel" {

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPatternElement
abstract class SVGPatternElement implements SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  /** @domName SVGPatternElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGPatternElement.patternContentUnits */
  SVGAnimatedEnumeration get patternContentUnits;

  /** @domName SVGPatternElement.patternTransform */
  SVGAnimatedTransformList get patternTransform;

  /** @domName SVGPatternElement.patternUnits */
  SVGAnimatedEnumeration get patternUnits;

  /** @domName SVGPatternElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGPatternElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGPatternElement.y */
  SVGAnimatedLength get y;
}

class _SVGPatternElementImpl extends _SVGElementImpl implements SVGPatternElement native "*SVGPatternElement" {

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedEnumerationImpl patternContentUnits;

  final _SVGAnimatedTransformListImpl patternTransform;

  final _SVGAnimatedEnumerationImpl patternUnits;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGFitToViewBox

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  final _SVGAnimatedRectImpl viewBox;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPoint
abstract class SVGPoint {

  /** @domName SVGPoint.x */
  num x;

  /** @domName SVGPoint.y */
  num y;

  /** @domName SVGPoint.matrixTransform */
  SVGPoint matrixTransform(SVGMatrix matrix);
}

class _SVGPointImpl implements SVGPoint native "*SVGPoint" {

  num x;

  num y;

  _SVGPointImpl matrixTransform(_SVGMatrixImpl matrix) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPointList
abstract class SVGPointList {

  /** @domName SVGPointList.numberOfItems */
  int get numberOfItems;

  /** @domName SVGPointList.appendItem */
  SVGPoint appendItem(SVGPoint item);

  /** @domName SVGPointList.clear */
  void clear();

  /** @domName SVGPointList.getItem */
  SVGPoint getItem(int index);

  /** @domName SVGPointList.initialize */
  SVGPoint initialize(SVGPoint item);

  /** @domName SVGPointList.insertItemBefore */
  SVGPoint insertItemBefore(SVGPoint item, int index);

  /** @domName SVGPointList.removeItem */
  SVGPoint removeItem(int index);

  /** @domName SVGPointList.replaceItem */
  SVGPoint replaceItem(SVGPoint item, int index);
}

class _SVGPointListImpl implements SVGPointList native "*SVGPointList" {

  final int numberOfItems;

  _SVGPointImpl appendItem(_SVGPointImpl item) native;

  void clear() native;

  _SVGPointImpl getItem(int index) native;

  _SVGPointImpl initialize(_SVGPointImpl item) native;

  _SVGPointImpl insertItemBefore(_SVGPointImpl item, int index) native;

  _SVGPointImpl removeItem(int index) native;

  _SVGPointImpl replaceItem(_SVGPointImpl item, int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPolygonElement
abstract class SVGPolygonElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPolygonElement.animatedPoints */
  SVGPointList get animatedPoints;

  /** @domName SVGPolygonElement.points */
  SVGPointList get points;
}

class _SVGPolygonElementImpl extends _SVGElementImpl implements SVGPolygonElement native "*SVGPolygonElement" {

  final _SVGPointListImpl animatedPoints;

  final _SVGPointListImpl points;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPolylineElement
abstract class SVGPolylineElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPolylineElement.animatedPoints */
  SVGPointList get animatedPoints;

  /** @domName SVGPolylineElement.points */
  SVGPointList get points;
}

class _SVGPolylineElementImpl extends _SVGElementImpl implements SVGPolylineElement native "*SVGPolylineElement" {

  final _SVGPointListImpl animatedPoints;

  final _SVGPointListImpl points;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPreserveAspectRatio
abstract class SVGPreserveAspectRatio {

  static const int SVG_MEETORSLICE_MEET = 1;

  static const int SVG_MEETORSLICE_SLICE = 2;

  static const int SVG_MEETORSLICE_UNKNOWN = 0;

  static const int SVG_PRESERVEASPECTRATIO_NONE = 1;

  static const int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;

  static const int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;

  static const int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;

  static const int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;

  static const int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;

  static const int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;

  static const int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;

  static const int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;

  static const int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;

  static const int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;

  /** @domName SVGPreserveAspectRatio.align */
  int align;

  /** @domName SVGPreserveAspectRatio.meetOrSlice */
  int meetOrSlice;
}

class _SVGPreserveAspectRatioImpl implements SVGPreserveAspectRatio native "*SVGPreserveAspectRatio" {

  int align;

  int meetOrSlice;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRadialGradientElement
abstract class SVGRadialGradientElement implements SVGGradientElement {

  /** @domName SVGRadialGradientElement.cx */
  SVGAnimatedLength get cx;

  /** @domName SVGRadialGradientElement.cy */
  SVGAnimatedLength get cy;

  /** @domName SVGRadialGradientElement.fr */
  SVGAnimatedLength get fr;

  /** @domName SVGRadialGradientElement.fx */
  SVGAnimatedLength get fx;

  /** @domName SVGRadialGradientElement.fy */
  SVGAnimatedLength get fy;

  /** @domName SVGRadialGradientElement.r */
  SVGAnimatedLength get r;
}

class _SVGRadialGradientElementImpl extends _SVGGradientElementImpl implements SVGRadialGradientElement native "*SVGRadialGradientElement" {

  final _SVGAnimatedLengthImpl cx;

  final _SVGAnimatedLengthImpl cy;

  final _SVGAnimatedLengthImpl fr;

  final _SVGAnimatedLengthImpl fx;

  final _SVGAnimatedLengthImpl fy;

  final _SVGAnimatedLengthImpl r;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRect
abstract class SVGRect {

  /** @domName SVGRect.height */
  num height;

  /** @domName SVGRect.width */
  num width;

  /** @domName SVGRect.x */
  num x;

  /** @domName SVGRect.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRectElement
abstract class SVGRectElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGRectElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGRectElement.rx */
  SVGAnimatedLength get rx;

  /** @domName SVGRectElement.ry */
  SVGAnimatedLength get ry;

  /** @domName SVGRectElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGRectElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGRectElement.y */
  SVGAnimatedLength get y;
}

class _SVGRectElementImpl extends _SVGElementImpl implements SVGRectElement native "*SVGRectElement" {

  final _SVGAnimatedLengthImpl height;

  final _SVGAnimatedLengthImpl rx;

  final _SVGAnimatedLengthImpl ry;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}

class _SVGRectImpl implements SVGRect native "*SVGRect" {

  num height;

  num width;

  num x;

  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRenderingIntent
abstract class SVGRenderingIntent {

  static const int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;

  static const int RENDERING_INTENT_AUTO = 1;

  static const int RENDERING_INTENT_PERCEPTUAL = 2;

  static const int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;

  static const int RENDERING_INTENT_SATURATION = 4;

  static const int RENDERING_INTENT_UNKNOWN = 0;
}

class _SVGRenderingIntentImpl implements SVGRenderingIntent native "*SVGRenderingIntent" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName SVGSVGElement
abstract class SVGSVGElement extends SVGElement implements SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGLocatable, SVGFitToViewBox, SVGZoomAndPan {
  factory SVGSVGElement() => _SVGSVGElementFactoryProvider.createSVGSVGElement();


  /** @domName SVGSVGElement.contentScriptType */
  String contentScriptType;

  /** @domName SVGSVGElement.contentStyleType */
  String contentStyleType;

  /** @domName SVGSVGElement.currentScale */
  num currentScale;

  /** @domName SVGSVGElement.currentTranslate */
  SVGPoint get currentTranslate;

  /** @domName SVGSVGElement.currentView */
  SVGViewSpec get currentView;

  /** @domName SVGSVGElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGSVGElement.pixelUnitToMillimeterX */
  num get pixelUnitToMillimeterX;

  /** @domName SVGSVGElement.pixelUnitToMillimeterY */
  num get pixelUnitToMillimeterY;

  /** @domName SVGSVGElement.screenPixelToMillimeterX */
  num get screenPixelToMillimeterX;

  /** @domName SVGSVGElement.screenPixelToMillimeterY */
  num get screenPixelToMillimeterY;

  /** @domName SVGSVGElement.useCurrentView */
  bool get useCurrentView;

  /** @domName SVGSVGElement.viewport */
  SVGRect get viewport;

  /** @domName SVGSVGElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGSVGElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGSVGElement.y */
  SVGAnimatedLength get y;

  /** @domName SVGSVGElement.animationsPaused */
  bool animationsPaused();

  /** @domName SVGSVGElement.checkEnclosure */
  bool checkEnclosure(SVGElement element, SVGRect rect);

  /** @domName SVGSVGElement.checkIntersection */
  bool checkIntersection(SVGElement element, SVGRect rect);

  /** @domName SVGSVGElement.createSVGAngle */
  SVGAngle createSVGAngle();

  /** @domName SVGSVGElement.createSVGLength */
  SVGLength createSVGLength();

  /** @domName SVGSVGElement.createSVGMatrix */
  SVGMatrix createSVGMatrix();

  /** @domName SVGSVGElement.createSVGNumber */
  SVGNumber createSVGNumber();

  /** @domName SVGSVGElement.createSVGPoint */
  SVGPoint createSVGPoint();

  /** @domName SVGSVGElement.createSVGRect */
  SVGRect createSVGRect();

  /** @domName SVGSVGElement.createSVGTransform */
  SVGTransform createSVGTransform();

  /** @domName SVGSVGElement.createSVGTransformFromMatrix */
  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  /** @domName SVGSVGElement.deselectAll */
  void deselectAll();

  /** @domName SVGSVGElement.forceRedraw */
  void forceRedraw();

  /** @domName SVGSVGElement.getCurrentTime */
  num getCurrentTime();

  /** @domName SVGSVGElement.getElementById */
  Element getElementById(String elementId);

  /** @domName SVGSVGElement.getEnclosureList */
  List<Node> getEnclosureList(SVGRect rect, SVGElement referenceElement);

  /** @domName SVGSVGElement.getIntersectionList */
  List<Node> getIntersectionList(SVGRect rect, SVGElement referenceElement);

  /** @domName SVGSVGElement.pauseAnimations */
  void pauseAnimations();

  /** @domName SVGSVGElement.setCurrentTime */
  void setCurrentTime(num seconds);

  /** @domName SVGSVGElement.suspendRedraw */
  int suspendRedraw(int maxWaitMilliseconds);

  /** @domName SVGSVGElement.unpauseAnimations */
  void unpauseAnimations();

  /** @domName SVGSVGElement.unsuspendRedraw */
  void unsuspendRedraw(int suspendHandleId);

  /** @domName SVGSVGElement.unsuspendRedrawAll */
  void unsuspendRedrawAll();

}

class _SVGSVGElementImpl extends _SVGElementImpl implements SVGSVGElement native "*SVGSVGElement" {

  String contentScriptType;

  String contentStyleType;

  num currentScale;

  final _SVGPointImpl currentTranslate;

  final _SVGViewSpecImpl currentView;

  final _SVGAnimatedLengthImpl height;

  final num pixelUnitToMillimeterX;

  final num pixelUnitToMillimeterY;

  final num screenPixelToMillimeterX;

  final num screenPixelToMillimeterY;

  final bool useCurrentView;

  final _SVGRectImpl viewport;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  bool animationsPaused() native;

  bool checkEnclosure(_SVGElementImpl element, _SVGRectImpl rect) native;

  bool checkIntersection(_SVGElementImpl element, _SVGRectImpl rect) native;

  _SVGAngleImpl createSVGAngle() native;

  _SVGLengthImpl createSVGLength() native;

  _SVGMatrixImpl createSVGMatrix() native;

  _SVGNumberImpl createSVGNumber() native;

  _SVGPointImpl createSVGPoint() native;

  _SVGRectImpl createSVGRect() native;

  _SVGTransformImpl createSVGTransform() native;

  _SVGTransformImpl createSVGTransformFromMatrix(_SVGMatrixImpl matrix) native;

  void deselectAll() native;

  void forceRedraw() native;

  num getCurrentTime() native;

  _ElementImpl getElementById(String elementId) native;

  List<Node> getEnclosureList(_SVGRectImpl rect, _SVGElementImpl referenceElement) native;

  List<Node> getIntersectionList(_SVGRectImpl rect, _SVGElementImpl referenceElement) native;

  void pauseAnimations() native;

  void setCurrentTime(num seconds) native;

  int suspendRedraw(int maxWaitMilliseconds) native;

  void unpauseAnimations() native;

  void unsuspendRedraw(int suspendHandleId) native;

  void unsuspendRedrawAll() native;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGFitToViewBox

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  final _SVGAnimatedRectImpl viewBox;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGZoomAndPan

  int zoomAndPan;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGScriptElement
abstract class SVGScriptElement implements SVGElement, SVGURIReference, SVGExternalResourcesRequired {

  /** @domName SVGScriptElement.type */
  String type;
}

class _SVGScriptElementImpl extends _SVGElementImpl implements SVGScriptElement native "*SVGScriptElement" {

  String type;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSetElement
abstract class SVGSetElement implements SVGAnimationElement {
}

class _SVGSetElementImpl extends _SVGAnimationElementImpl implements SVGSetElement native "*SVGSetElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStopElement
abstract class SVGStopElement implements SVGElement, SVGStylable {

  /** @domName SVGStopElement.offset */
  SVGAnimatedNumber get offset;
}

class _SVGStopElementImpl extends _SVGElementImpl implements SVGStopElement native "*SVGStopElement" {

  final _SVGAnimatedNumberImpl offset;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStringList
abstract class SVGStringList implements List<String> {

  /** @domName SVGStringList.numberOfItems */
  int get numberOfItems;

  /** @domName SVGStringList.appendItem */
  String appendItem(String item);

  /** @domName SVGStringList.clear */
  void clear();

  /** @domName SVGStringList.getItem */
  String getItem(int index);

  /** @domName SVGStringList.initialize */
  String initialize(String item);

  /** @domName SVGStringList.insertItemBefore */
  String insertItemBefore(String item, int index);

  /** @domName SVGStringList.removeItem */
  String removeItem(int index);

  /** @domName SVGStringList.replaceItem */
  String replaceItem(String item, int index);
}

class _SVGStringListImpl implements SVGStringList, JavaScriptIndexingBehavior native "*SVGStringList" {

  final int numberOfItems;

  String operator[](int index) => JS("String", "#[#]", this, index);

  void operator[]=(int index, String value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<String> mixins.
  // String is the element type.

  // From Iterable<String>:

  Iterator<String> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<String>(this);
  }

  // From Collection<String>:

  void add(String value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(String element) => _Collections.contains(this, element);

  void forEach(void f(String element)) => _Collections.forEach(this, f);

  Collection map(f(String element)) => _Collections.map(this, [], f);

  Collection<String> filter(bool f(String element)) =>
     _Collections.filter(this, <String>[], f);

  bool every(bool f(String element)) => _Collections.every(this, f);

  bool some(bool f(String element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<String>:

  void sort([Comparator<String> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(String element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(String element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  String get last => this[length - 1];

  String removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<String> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [String initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <String>[]);

  // -- end List<String> mixins.

  String appendItem(String item) native;

  void clear() native;

  String getItem(int index) native;

  String initialize(String item) native;

  String insertItemBefore(String item, int index) native;

  String removeItem(int index) native;

  String replaceItem(String item, int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStylable
abstract class SVGStylable {

  /** @domName SVGStylable.className */
  SVGAnimatedString get $dom_svgClassName;

  /** @domName SVGStylable.style */
  CSSStyleDeclaration get style;

  /** @domName SVGStylable.getPresentationAttribute */
  CSSValue getPresentationAttribute(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStyleElement
abstract class SVGStyleElement implements SVGElement, SVGLangSpace {

  /** @domName SVGStyleElement.disabled */
  bool disabled;

  /** @domName SVGStyleElement.media */
  String media;

  /** @domName SVGStyleElement.title */
  String title;

  /** @domName SVGStyleElement.type */
  String type;
}

class _SVGStyleElementImpl extends _SVGElementImpl implements SVGStyleElement native "*SVGStyleElement" {

  bool disabled;

  String media;

  // Shadowing definition.
  String get title => JS("String", "#.title", this);

  void set title(String value) {
    JS("void", "#.title = #", this, value);
  }

  String type;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSwitchElement
abstract class SVGSwitchElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}

class _SVGSwitchElementImpl extends _SVGElementImpl implements SVGSwitchElement native "*SVGSwitchElement" {

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSymbolElement
abstract class SVGSymbolElement implements SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {
}

class _SVGSymbolElementImpl extends _SVGElementImpl implements SVGSymbolElement native "*SVGSymbolElement" {

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGFitToViewBox

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  final _SVGAnimatedRectImpl viewBox;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTRefElement
abstract class SVGTRefElement implements SVGTextPositioningElement, SVGURIReference {
}

class _SVGTRefElementImpl extends _SVGTextPositioningElementImpl implements SVGTRefElement native "*SVGTRefElement" {

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTSpanElement
abstract class SVGTSpanElement implements SVGTextPositioningElement {
}

class _SVGTSpanElementImpl extends _SVGTextPositioningElementImpl implements SVGTSpanElement native "*SVGTSpanElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTests
abstract class SVGTests {

  /** @domName SVGTests.requiredExtensions */
  SVGStringList get requiredExtensions;

  /** @domName SVGTests.requiredFeatures */
  SVGStringList get requiredFeatures;

  /** @domName SVGTests.systemLanguage */
  SVGStringList get systemLanguage;

  /** @domName SVGTests.hasExtension */
  bool hasExtension(String extension);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextContentElement
abstract class SVGTextContentElement implements SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  static const int LENGTHADJUST_SPACING = 1;

  static const int LENGTHADJUST_SPACINGANDGLYPHS = 2;

  static const int LENGTHADJUST_UNKNOWN = 0;

  /** @domName SVGTextContentElement.lengthAdjust */
  SVGAnimatedEnumeration get lengthAdjust;

  /** @domName SVGTextContentElement.textLength */
  SVGAnimatedLength get textLength;

  /** @domName SVGTextContentElement.getCharNumAtPosition */
  int getCharNumAtPosition(SVGPoint point);

  /** @domName SVGTextContentElement.getComputedTextLength */
  num getComputedTextLength();

  /** @domName SVGTextContentElement.getEndPositionOfChar */
  SVGPoint getEndPositionOfChar(int offset);

  /** @domName SVGTextContentElement.getExtentOfChar */
  SVGRect getExtentOfChar(int offset);

  /** @domName SVGTextContentElement.getNumberOfChars */
  int getNumberOfChars();

  /** @domName SVGTextContentElement.getRotationOfChar */
  num getRotationOfChar(int offset);

  /** @domName SVGTextContentElement.getStartPositionOfChar */
  SVGPoint getStartPositionOfChar(int offset);

  /** @domName SVGTextContentElement.getSubStringLength */
  num getSubStringLength(int offset, int length);

  /** @domName SVGTextContentElement.selectSubString */
  void selectSubString(int offset, int length);
}

class _SVGTextContentElementImpl extends _SVGElementImpl implements SVGTextContentElement native "*SVGTextContentElement" {

  final _SVGAnimatedEnumerationImpl lengthAdjust;

  final _SVGAnimatedLengthImpl textLength;

  int getCharNumAtPosition(_SVGPointImpl point) native;

  num getComputedTextLength() native;

  _SVGPointImpl getEndPositionOfChar(int offset) native;

  _SVGRectImpl getExtentOfChar(int offset) native;

  int getNumberOfChars() native;

  num getRotationOfChar(int offset) native;

  _SVGPointImpl getStartPositionOfChar(int offset) native;

  num getSubStringLength(int offset, int length) native;

  void selectSubString(int offset, int length) native;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextElement
abstract class SVGTextElement implements SVGTextPositioningElement, SVGTransformable {
}

class _SVGTextElementImpl extends _SVGTextPositioningElementImpl implements SVGTextElement native "*SVGTextElement" {

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextPathElement
abstract class SVGTextPathElement implements SVGTextContentElement, SVGURIReference {

  static const int TEXTPATH_METHODTYPE_ALIGN = 1;

  static const int TEXTPATH_METHODTYPE_STRETCH = 2;

  static const int TEXTPATH_METHODTYPE_UNKNOWN = 0;

  static const int TEXTPATH_SPACINGTYPE_AUTO = 1;

  static const int TEXTPATH_SPACINGTYPE_EXACT = 2;

  static const int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;

  /** @domName SVGTextPathElement.method */
  SVGAnimatedEnumeration get method;

  /** @domName SVGTextPathElement.spacing */
  SVGAnimatedEnumeration get spacing;

  /** @domName SVGTextPathElement.startOffset */
  SVGAnimatedLength get startOffset;
}

class _SVGTextPathElementImpl extends _SVGTextContentElementImpl implements SVGTextPathElement native "*SVGTextPathElement" {

  final _SVGAnimatedEnumerationImpl method;

  final _SVGAnimatedEnumerationImpl spacing;

  final _SVGAnimatedLengthImpl startOffset;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextPositioningElement
abstract class SVGTextPositioningElement implements SVGTextContentElement {

  /** @domName SVGTextPositioningElement.dx */
  SVGAnimatedLengthList get dx;

  /** @domName SVGTextPositioningElement.dy */
  SVGAnimatedLengthList get dy;

  /** @domName SVGTextPositioningElement.rotate */
  SVGAnimatedNumberList get rotate;

  /** @domName SVGTextPositioningElement.x */
  SVGAnimatedLengthList get x;

  /** @domName SVGTextPositioningElement.y */
  SVGAnimatedLengthList get y;
}

class _SVGTextPositioningElementImpl extends _SVGTextContentElementImpl implements SVGTextPositioningElement native "*SVGTextPositioningElement" {

  final _SVGAnimatedLengthListImpl dx;

  final _SVGAnimatedLengthListImpl dy;

  final _SVGAnimatedNumberListImpl rotate;

  final _SVGAnimatedLengthListImpl x;

  final _SVGAnimatedLengthListImpl y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTitleElement
abstract class SVGTitleElement implements SVGElement, SVGLangSpace, SVGStylable {
}

class _SVGTitleElementImpl extends _SVGElementImpl implements SVGTitleElement native "*SVGTitleElement" {

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransform
abstract class SVGTransform {

  static const int SVG_TRANSFORM_MATRIX = 1;

  static const int SVG_TRANSFORM_ROTATE = 4;

  static const int SVG_TRANSFORM_SCALE = 3;

  static const int SVG_TRANSFORM_SKEWX = 5;

  static const int SVG_TRANSFORM_SKEWY = 6;

  static const int SVG_TRANSFORM_TRANSLATE = 2;

  static const int SVG_TRANSFORM_UNKNOWN = 0;

  /** @domName SVGTransform.angle */
  num get angle;

  /** @domName SVGTransform.matrix */
  SVGMatrix get matrix;

  /** @domName SVGTransform.type */
  int get type;

  /** @domName SVGTransform.setMatrix */
  void setMatrix(SVGMatrix matrix);

  /** @domName SVGTransform.setRotate */
  void setRotate(num angle, num cx, num cy);

  /** @domName SVGTransform.setScale */
  void setScale(num sx, num sy);

  /** @domName SVGTransform.setSkewX */
  void setSkewX(num angle);

  /** @domName SVGTransform.setSkewY */
  void setSkewY(num angle);

  /** @domName SVGTransform.setTranslate */
  void setTranslate(num tx, num ty);
}

class _SVGTransformImpl implements SVGTransform native "*SVGTransform" {

  final num angle;

  final _SVGMatrixImpl matrix;

  final int type;

  void setMatrix(_SVGMatrixImpl matrix) native;

  void setRotate(num angle, num cx, num cy) native;

  void setScale(num sx, num sy) native;

  void setSkewX(num angle) native;

  void setSkewY(num angle) native;

  void setTranslate(num tx, num ty) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransformList
abstract class SVGTransformList implements List<SVGTransform> {

  /** @domName SVGTransformList.numberOfItems */
  int get numberOfItems;

  /** @domName SVGTransformList.appendItem */
  SVGTransform appendItem(SVGTransform item);

  /** @domName SVGTransformList.clear */
  void clear();

  /** @domName SVGTransformList.consolidate */
  SVGTransform consolidate();

  /** @domName SVGTransformList.createSVGTransformFromMatrix */
  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  /** @domName SVGTransformList.getItem */
  SVGTransform getItem(int index);

  /** @domName SVGTransformList.initialize */
  SVGTransform initialize(SVGTransform item);

  /** @domName SVGTransformList.insertItemBefore */
  SVGTransform insertItemBefore(SVGTransform item, int index);

  /** @domName SVGTransformList.removeItem */
  SVGTransform removeItem(int index);

  /** @domName SVGTransformList.replaceItem */
  SVGTransform replaceItem(SVGTransform item, int index);
}

class _SVGTransformListImpl implements SVGTransformList, JavaScriptIndexingBehavior native "*SVGTransformList" {

  final int numberOfItems;

  _SVGTransformImpl operator[](int index) => JS("_SVGTransformImpl", "#[#]", this, index);

  void operator[]=(int index, _SVGTransformImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SVGTransform> mixins.
  // SVGTransform is the element type.

  // From Iterable<SVGTransform>:

  Iterator<SVGTransform> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SVGTransform>(this);
  }

  // From Collection<SVGTransform>:

  void add(SVGTransform value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SVGTransform value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SVGTransform> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SVGTransform element) => _Collections.contains(this, element);

  void forEach(void f(SVGTransform element)) => _Collections.forEach(this, f);

  Collection map(f(SVGTransform element)) => _Collections.map(this, [], f);

  Collection<SVGTransform> filter(bool f(SVGTransform element)) =>
     _Collections.filter(this, <SVGTransform>[], f);

  bool every(bool f(SVGTransform element)) => _Collections.every(this, f);

  bool some(bool f(SVGTransform element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SVGTransform>:

  void sort([Comparator<SVGTransform> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SVGTransform element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SVGTransform element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SVGTransform get last => this[length - 1];

  SVGTransform removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SVGTransform> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SVGTransform initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SVGTransform> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SVGTransform>[]);

  // -- end List<SVGTransform> mixins.

  _SVGTransformImpl appendItem(_SVGTransformImpl item) native;

  void clear() native;

  _SVGTransformImpl consolidate() native;

  _SVGTransformImpl createSVGTransformFromMatrix(_SVGMatrixImpl matrix) native;

  _SVGTransformImpl getItem(int index) native;

  _SVGTransformImpl initialize(_SVGTransformImpl item) native;

  _SVGTransformImpl insertItemBefore(_SVGTransformImpl item, int index) native;

  _SVGTransformImpl removeItem(int index) native;

  _SVGTransformImpl replaceItem(_SVGTransformImpl item, int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransformable
abstract class SVGTransformable implements SVGLocatable {

  /** @domName SVGTransformable.transform */
  SVGAnimatedTransformList get transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGURIReference
abstract class SVGURIReference {

  /** @domName SVGURIReference.href */
  SVGAnimatedString get href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGUnitTypes
abstract class SVGUnitTypes {

  static const int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;

  static const int SVG_UNIT_TYPE_UNKNOWN = 0;

  static const int SVG_UNIT_TYPE_USERSPACEONUSE = 1;
}

class _SVGUnitTypesImpl implements SVGUnitTypes native "*SVGUnitTypes" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGUseElement
abstract class SVGUseElement implements SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGUseElement.animatedInstanceRoot */
  SVGElementInstance get animatedInstanceRoot;

  /** @domName SVGUseElement.height */
  SVGAnimatedLength get height;

  /** @domName SVGUseElement.instanceRoot */
  SVGElementInstance get instanceRoot;

  /** @domName SVGUseElement.width */
  SVGAnimatedLength get width;

  /** @domName SVGUseElement.x */
  SVGAnimatedLength get x;

  /** @domName SVGUseElement.y */
  SVGAnimatedLength get y;
}

class _SVGUseElementImpl extends _SVGElementImpl implements SVGUseElement native "*SVGUseElement" {

  final _SVGElementInstanceImpl animatedInstanceRoot;

  final _SVGAnimatedLengthImpl height;

  final _SVGElementInstanceImpl instanceRoot;

  final _SVGAnimatedLengthImpl width;

  final _SVGAnimatedLengthImpl x;

  final _SVGAnimatedLengthImpl y;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGLangSpace

  String xmllang;

  String xmlspace;

  // From SVGLocatable

  final _SVGElementImpl farthestViewportElement;

  final _SVGElementImpl nearestViewportElement;

  _SVGRectImpl getBBox() native;

  _SVGMatrixImpl getCTM() native;

  _SVGMatrixImpl getScreenCTM() native;

  _SVGMatrixImpl getTransformToElement(_SVGElementImpl element) native;

  // From SVGStylable

  _SVGAnimatedStringImpl get $dom_svgClassName => JS("_SVGAnimatedStringImpl", "#.className", this);

  // Use implementation from Element.
  // final _CSSStyleDeclarationImpl style;

  _CSSValueImpl getPresentationAttribute(String name) native;

  // From SVGTests

  final _SVGStringListImpl requiredExtensions;

  final _SVGStringListImpl requiredFeatures;

  final _SVGStringListImpl systemLanguage;

  bool hasExtension(String extension) native;

  // From SVGTransformable

  final _SVGAnimatedTransformListImpl transform;

  // From SVGURIReference

  final _SVGAnimatedStringImpl href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGVKernElement
abstract class SVGVKernElement implements SVGElement {
}

class _SVGVKernElementImpl extends _SVGElementImpl implements SVGVKernElement native "*SVGVKernElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGViewElement
abstract class SVGViewElement implements SVGElement, SVGExternalResourcesRequired, SVGFitToViewBox, SVGZoomAndPan {

  /** @domName SVGViewElement.viewTarget */
  SVGStringList get viewTarget;
}

class _SVGViewElementImpl extends _SVGElementImpl implements SVGViewElement native "*SVGViewElement" {

  final _SVGStringListImpl viewTarget;

  // From SVGExternalResourcesRequired

  final _SVGAnimatedBooleanImpl externalResourcesRequired;

  // From SVGFitToViewBox

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  final _SVGAnimatedRectImpl viewBox;

  // From SVGZoomAndPan

  int zoomAndPan;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGViewSpec
abstract class SVGViewSpec {

  /** @domName SVGViewSpec.preserveAspectRatio */
  SVGAnimatedPreserveAspectRatio get preserveAspectRatio;

  /** @domName SVGViewSpec.preserveAspectRatioString */
  String get preserveAspectRatioString;

  /** @domName SVGViewSpec.transform */
  SVGTransformList get transform;

  /** @domName SVGViewSpec.transformString */
  String get transformString;

  /** @domName SVGViewSpec.viewBox */
  SVGAnimatedRect get viewBox;

  /** @domName SVGViewSpec.viewBoxString */
  String get viewBoxString;

  /** @domName SVGViewSpec.viewTarget */
  SVGElement get viewTarget;

  /** @domName SVGViewSpec.viewTargetString */
  String get viewTargetString;

  /** @domName SVGViewSpec.zoomAndPan */
  int zoomAndPan;
}

class _SVGViewSpecImpl implements SVGViewSpec native "*SVGViewSpec" {

  final _SVGAnimatedPreserveAspectRatioImpl preserveAspectRatio;

  final String preserveAspectRatioString;

  final _SVGTransformListImpl transform;

  final String transformString;

  final _SVGAnimatedRectImpl viewBox;

  final String viewBoxString;

  final _SVGElementImpl viewTarget;

  final String viewTargetString;

  int zoomAndPan;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGZoomAndPan
abstract class SVGZoomAndPan {

  static const int SVG_ZOOMANDPAN_DISABLE = 1;

  static const int SVG_ZOOMANDPAN_MAGNIFY = 2;

  static const int SVG_ZOOMANDPAN_UNKNOWN = 0;

  /** @domName SVGZoomAndPan.zoomAndPan */
  int zoomAndPan;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGZoomEvent
abstract class SVGZoomEvent implements UIEvent {

  /** @domName SVGZoomEvent.newScale */
  num get newScale;

  /** @domName SVGZoomEvent.newTranslate */
  SVGPoint get newTranslate;

  /** @domName SVGZoomEvent.previousScale */
  num get previousScale;

  /** @domName SVGZoomEvent.previousTranslate */
  SVGPoint get previousTranslate;

  /** @domName SVGZoomEvent.zoomRectScreen */
  SVGRect get zoomRectScreen;
}

class _SVGZoomEventImpl extends _UIEventImpl implements SVGZoomEvent native "*SVGZoomEvent" {

  final num newScale;

  final _SVGPointImpl newTranslate;

  final num previousScale;

  final _SVGPointImpl previousTranslate;

  final _SVGRectImpl zoomRectScreen;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Screen
abstract class Screen {

  /** @domName Screen.availHeight */
  int get availHeight;

  /** @domName Screen.availLeft */
  int get availLeft;

  /** @domName Screen.availTop */
  int get availTop;

  /** @domName Screen.availWidth */
  int get availWidth;

  /** @domName Screen.colorDepth */
  int get colorDepth;

  /** @domName Screen.height */
  int get height;

  /** @domName Screen.pixelDepth */
  int get pixelDepth;

  /** @domName Screen.width */
  int get width;
}

class _ScreenImpl implements Screen native "*Screen" {

  final int availHeight;

  final int availLeft;

  final int availTop;

  final int availWidth;

  final int colorDepth;

  final int height;

  final int pixelDepth;

  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLScriptElement
abstract class ScriptElement implements Element {

  factory ScriptElement() => _Elements.createScriptElement();

  /** @domName HTMLScriptElement.async */
  bool async;

  /** @domName HTMLScriptElement.charset */
  String charset;

  /** @domName HTMLScriptElement.crossOrigin */
  String crossOrigin;

  /** @domName HTMLScriptElement.defer */
  bool defer;

  /** @domName HTMLScriptElement.event */
  String event;

  /** @domName HTMLScriptElement.htmlFor */
  String htmlFor;

  /** @domName HTMLScriptElement.src */
  String src;

  /** @domName HTMLScriptElement.type */
  String type;
}

class _ScriptElementImpl extends _ElementImpl implements ScriptElement native "*HTMLScriptElement" {

  bool async;

  String charset;

  String crossOrigin;

  bool defer;

  String event;

  String htmlFor;

  String src;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ScriptProcessorNode
abstract class ScriptProcessorNode implements AudioNode, EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  ScriptProcessorNodeEvents get on;

  /** @domName ScriptProcessorNode.bufferSize */
  int get bufferSize;
}

abstract class ScriptProcessorNodeEvents implements Events {

  EventListenerList get audioProcess;
}

class _ScriptProcessorNodeImpl extends _AudioNodeImpl implements ScriptProcessorNode native "*ScriptProcessorNode" {

  _ScriptProcessorNodeEventsImpl get on =>
    new _ScriptProcessorNodeEventsImpl(this);

  final int bufferSize;
}

class _ScriptProcessorNodeEventsImpl extends _EventsImpl implements ScriptProcessorNodeEvents {
  _ScriptProcessorNodeEventsImpl(_ptr) : super(_ptr);

  EventListenerList get audioProcess => this['audioprocess'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ScriptProfile
abstract class ScriptProfile {

  /** @domName ScriptProfile.head */
  ScriptProfileNode get head;

  /** @domName ScriptProfile.title */
  String get title;

  /** @domName ScriptProfile.uid */
  int get uid;
}

class _ScriptProfileImpl implements ScriptProfile native "*ScriptProfile" {

  final _ScriptProfileNodeImpl head;

  final String title;

  final int uid;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ScriptProfileNode
abstract class ScriptProfileNode {

  /** @domName ScriptProfileNode.callUID */
  int get callUID;

  /** @domName ScriptProfileNode.functionName */
  String get functionName;

  /** @domName ScriptProfileNode.lineNumber */
  int get lineNumber;

  /** @domName ScriptProfileNode.numberOfCalls */
  int get numberOfCalls;

  /** @domName ScriptProfileNode.selfTime */
  num get selfTime;

  /** @domName ScriptProfileNode.totalTime */
  num get totalTime;

  /** @domName ScriptProfileNode.url */
  String get url;

  /** @domName ScriptProfileNode.visible */
  bool get visible;

  /** @domName ScriptProfileNode.children */
  List<ScriptProfileNode> children();
}

class _ScriptProfileNodeImpl implements ScriptProfileNode native "*ScriptProfileNode" {

  final int callUID;

  final String functionName;

  final int lineNumber;

  final int numberOfCalls;

  final num selfTime;

  final num totalTime;

  final String url;

  final bool visible;

  List<ScriptProfileNode> children() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSelectElement
abstract class SelectElement implements Element {

  factory SelectElement() => _Elements.createSelectElement();

  /** @domName HTMLSelectElement.autofocus */
  bool autofocus;

  /** @domName HTMLSelectElement.disabled */
  bool disabled;

  /** @domName HTMLSelectElement.form */
  FormElement get form;

  /** @domName HTMLSelectElement.labels */
  List<Node> get labels;

  /** @domName HTMLSelectElement.length */
  int length;

  /** @domName HTMLSelectElement.multiple */
  bool multiple;

  /** @domName HTMLSelectElement.name */
  String name;

  /** @domName HTMLSelectElement.options */
  HTMLOptionsCollection get options;

  /** @domName HTMLSelectElement.required */
  bool required;

  /** @domName HTMLSelectElement.selectedIndex */
  int selectedIndex;

  /** @domName HTMLSelectElement.selectedOptions */
  HTMLCollection get selectedOptions;

  /** @domName HTMLSelectElement.size */
  int size;

  /** @domName HTMLSelectElement.type */
  String get type;

  /** @domName HTMLSelectElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLSelectElement.validity */
  ValidityState get validity;

  /** @domName HTMLSelectElement.value */
  String value;

  /** @domName HTMLSelectElement.willValidate */
  bool get willValidate;

  /** @domName HTMLSelectElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLSelectElement.item */
  Node item(int index);

  /** @domName HTMLSelectElement.namedItem */
  Node namedItem(String name);

  /** @domName HTMLSelectElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SelectElementImpl extends _ElementImpl implements SelectElement native "*HTMLSelectElement" {

  bool autofocus;

  bool disabled;

  final _FormElementImpl form;

  final List<Node> labels;

  int length;

  bool multiple;

  String name;

  bool required;

  int selectedIndex;

  int size;

  final String type;

  final String validationMessage;

  final _ValidityStateImpl validity;

  String value;

  final bool willValidate;

  bool checkValidity() native;

  _NodeImpl item(int index) native;

  _NodeImpl namedItem(String name) native;

  void setCustomValidity(String error) native;


  // Override default options, since IE returns SelectElement itself and it
  // does not operate as a List.
  List<OptionElement> get options {
    return this.elements.filter((e) => e is OptionElement);
  }

  List<OptionElement> get selectedOptions {
    // IE does not change the selected flag for single-selection items.
    if (this.multiple) {
      return this.options.filter((o) => o.selected);
    } else {
      return [this.options[this.selectedIndex]];
    }
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SessionDescription
abstract class SessionDescription {

  factory SessionDescription(String sdp) => _SessionDescriptionFactoryProvider.createSessionDescription(sdp);

  /** @domName SessionDescription.addCandidate */
  void addCandidate(IceCandidate candidate);

  /** @domName SessionDescription.toSdp */
  String toSdp();
}

class _SessionDescriptionImpl implements SessionDescription native "*SessionDescription" {

  void addCandidate(_IceCandidateImpl candidate) native;

  String toSdp() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLShadowElement
abstract class ShadowElement implements Element {

  /** @domName HTMLShadowElement.resetStyleInheritance */
  bool resetStyleInheritance;
}

class _ShadowElementImpl extends _ElementImpl implements ShadowElement native "*HTMLShadowElement" {

  bool resetStyleInheritance;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName ShadowRoot
abstract class ShadowRoot implements DocumentFragment {

  factory ShadowRoot(Element host) => _ShadowRootFactoryProvider.createShadowRoot(host);

  /** @domName ShadowRoot.activeElement */
  Element get activeElement;

  /** @domName ShadowRoot.applyAuthorStyles */
  bool applyAuthorStyles;

  /** @domName ShadowRoot.innerHTML */
  String innerHTML;

  /** @domName ShadowRoot.resetStyleInheritance */
  bool resetStyleInheritance;

  /** @domName ShadowRoot.cloneNode */
  Node clone(bool deep);

  /** @domName ShadowRoot.getElementById */
  Element $dom_getElementById(String elementId);

  /** @domName ShadowRoot.getElementsByClassName */
  List<Node> $dom_getElementsByClassName(String className);

  /** @domName ShadowRoot.getElementsByTagName */
  List<Node> $dom_getElementsByTagName(String tagName);

  /** @domName ShadowRoot.getSelection */
  DOMSelection getSelection();

  static bool get supported => _ShadowRootImpl.supported;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ShadowRootImpl extends _DocumentFragmentImpl implements ShadowRoot native "*ShadowRoot" {

  final _ElementImpl activeElement;

  bool applyAuthorStyles;

  String innerHTML;

  bool resetStyleInheritance;

  _NodeImpl clone(bool deep) native "cloneNode";

  _ElementImpl $dom_getElementById(String elementId) native "getElementById";

  List<Node> $dom_getElementsByClassName(String className) native "getElementsByClassName";

  List<Node> $dom_getElementsByTagName(String tagName) native "getElementsByTagName";

  _DOMSelectionImpl getSelection() native;

  static bool get supported =>
      JS('bool', '!!(window.ShadowRoot || window.WebKitShadowRoot)');
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SharedWorker
abstract class SharedWorker implements AbstractWorker {

  factory SharedWorker(String scriptURL, [String name]) {
    if (!?name) {
      return _SharedWorkerFactoryProvider.createSharedWorker(scriptURL);
    }
    return _SharedWorkerFactoryProvider.createSharedWorker(scriptURL, name);
  }

  /** @domName SharedWorker.port */
  MessagePort get port;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SharedWorkerContext
abstract class SharedWorkerContext implements WorkerContext {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SharedWorkerContextEvents get on;

  /** @domName SharedWorkerContext.name */
  String get name;
}

abstract class SharedWorkerContextEvents implements WorkerContextEvents {

  EventListenerList get connect;
}

class _SharedWorkerContextImpl extends _WorkerContextImpl implements SharedWorkerContext native "*SharedWorkerContext" {

  _SharedWorkerContextEventsImpl get on =>
    new _SharedWorkerContextEventsImpl(this);

  final String name;
}

class _SharedWorkerContextEventsImpl extends _WorkerContextEventsImpl implements SharedWorkerContextEvents {
  _SharedWorkerContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get connect => this['connect'];
}

class _SharedWorkerImpl extends _AbstractWorkerImpl implements SharedWorker native "*SharedWorker" {

  final _MessagePortImpl port;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SourceBuffer
abstract class SourceBuffer {

  /** @domName SourceBuffer.buffered */
  TimeRanges get buffered;

  /** @domName SourceBuffer.timestampOffset */
  num timestampOffset;

  /** @domName SourceBuffer.abort */
  void abort();

  /** @domName SourceBuffer.append */
  void append(Uint8Array data);
}

class _SourceBufferImpl implements SourceBuffer native "*SourceBuffer" {

  final _TimeRangesImpl buffered;

  num timestampOffset;

  void abort() native;

  void append(_Uint8ArrayImpl data) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SourceBufferList
abstract class SourceBufferList implements EventTarget, List<SourceBuffer> {

  /** @domName SourceBufferList.length */
  int get length;

  /** @domName SourceBufferList.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SourceBufferList.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName SourceBufferList.item */
  SourceBuffer item(int index);

  /** @domName SourceBufferList.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

class _SourceBufferListImpl extends _EventTargetImpl implements SourceBufferList, JavaScriptIndexingBehavior native "*SourceBufferList" {

  final int length;

  _SourceBufferImpl operator[](int index) => JS("_SourceBufferImpl", "#[#]", this, index);

  void operator[]=(int index, _SourceBufferImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SourceBuffer> mixins.
  // SourceBuffer is the element type.

  // From Iterable<SourceBuffer>:

  Iterator<SourceBuffer> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SourceBuffer>(this);
  }

  // From Collection<SourceBuffer>:

  void add(SourceBuffer value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SourceBuffer value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SourceBuffer> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SourceBuffer element) => _Collections.contains(this, element);

  void forEach(void f(SourceBuffer element)) => _Collections.forEach(this, f);

  Collection map(f(SourceBuffer element)) => _Collections.map(this, [], f);

  Collection<SourceBuffer> filter(bool f(SourceBuffer element)) =>
     _Collections.filter(this, <SourceBuffer>[], f);

  bool every(bool f(SourceBuffer element)) => _Collections.every(this, f);

  bool some(bool f(SourceBuffer element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SourceBuffer>:

  void sort([Comparator<SourceBuffer> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SourceBuffer element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SourceBuffer element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SourceBuffer get last => this[length - 1];

  SourceBuffer removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SourceBuffer> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SourceBuffer initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SourceBuffer> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SourceBuffer>[]);

  // -- end List<SourceBuffer> mixins.

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  _SourceBufferImpl item(int index) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSourceElement
abstract class SourceElement implements Element {

  factory SourceElement() => _Elements.createSourceElement();

  /** @domName HTMLSourceElement.media */
  String media;

  /** @domName HTMLSourceElement.src */
  String src;

  /** @domName HTMLSourceElement.type */
  String type;
}

class _SourceElementImpl extends _ElementImpl implements SourceElement native "*HTMLSourceElement" {

  String media;

  String src;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSpanElement
abstract class SpanElement implements Element {

  factory SpanElement() => _Elements.createSpanElement();
}

class _SpanElementImpl extends _ElementImpl implements SpanElement native "*HTMLSpanElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechGrammar
abstract class SpeechGrammar {

  factory SpeechGrammar() => _SpeechGrammarFactoryProvider.createSpeechGrammar();

  /** @domName SpeechGrammar.src */
  String src;

  /** @domName SpeechGrammar.weight */
  num weight;
}

class _SpeechGrammarImpl implements SpeechGrammar native "*SpeechGrammar" {

  String src;

  num weight;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechGrammarList
abstract class SpeechGrammarList implements List<SpeechGrammar> {

  factory SpeechGrammarList() => _SpeechGrammarListFactoryProvider.createSpeechGrammarList();

  /** @domName SpeechGrammarList.length */
  int get length;

  /** @domName SpeechGrammarList.addFromString */
  void addFromString(String string, [num weight]);

  /** @domName SpeechGrammarList.addFromUri */
  void addFromUri(String src, [num weight]);

  /** @domName SpeechGrammarList.item */
  SpeechGrammar item(int index);
}

class _SpeechGrammarListImpl implements SpeechGrammarList, JavaScriptIndexingBehavior native "*SpeechGrammarList" {

  final int length;

  _SpeechGrammarImpl operator[](int index) => JS("_SpeechGrammarImpl", "#[#]", this, index);

  void operator[]=(int index, _SpeechGrammarImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SpeechGrammar> mixins.
  // SpeechGrammar is the element type.

  // From Iterable<SpeechGrammar>:

  Iterator<SpeechGrammar> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SpeechGrammar>(this);
  }

  // From Collection<SpeechGrammar>:

  void add(SpeechGrammar value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SpeechGrammar value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SpeechGrammar> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SpeechGrammar element) => _Collections.contains(this, element);

  void forEach(void f(SpeechGrammar element)) => _Collections.forEach(this, f);

  Collection map(f(SpeechGrammar element)) => _Collections.map(this, [], f);

  Collection<SpeechGrammar> filter(bool f(SpeechGrammar element)) =>
     _Collections.filter(this, <SpeechGrammar>[], f);

  bool every(bool f(SpeechGrammar element)) => _Collections.every(this, f);

  bool some(bool f(SpeechGrammar element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SpeechGrammar>:

  void sort([Comparator<SpeechGrammar> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SpeechGrammar element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SpeechGrammar element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SpeechGrammar get last => this[length - 1];

  SpeechGrammar removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SpeechGrammar> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SpeechGrammar initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SpeechGrammar> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SpeechGrammar>[]);

  // -- end List<SpeechGrammar> mixins.

  void addFromString(String string, [num weight]) native;

  void addFromUri(String src, [num weight]) native;

  _SpeechGrammarImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputEvent
abstract class SpeechInputEvent implements Event {

  /** @domName SpeechInputEvent.results */
  List<SpeechInputResult> get results;
}

class _SpeechInputEventImpl extends _EventImpl implements SpeechInputEvent native "*SpeechInputEvent" {

  final _SpeechInputResultListImpl results;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputResult
abstract class SpeechInputResult {

  /** @domName SpeechInputResult.confidence */
  num get confidence;

  /** @domName SpeechInputResult.utterance */
  String get utterance;
}

class _SpeechInputResultImpl implements SpeechInputResult native "*SpeechInputResult" {

  final num confidence;

  final String utterance;
}

class _SpeechInputResultListImpl implements List<SpeechInputResult>, JavaScriptIndexingBehavior native "*SpeechInputResultList" {

  final int length;

  _SpeechInputResultImpl operator[](int index) => JS("_SpeechInputResultImpl", "#[#]", this, index);

  void operator[]=(int index, _SpeechInputResultImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SpeechInputResult> mixins.
  // SpeechInputResult is the element type.

  // From Iterable<SpeechInputResult>:

  Iterator<SpeechInputResult> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SpeechInputResult>(this);
  }

  // From Collection<SpeechInputResult>:

  void add(SpeechInputResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SpeechInputResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SpeechInputResult> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SpeechInputResult element) => _Collections.contains(this, element);

  void forEach(void f(SpeechInputResult element)) => _Collections.forEach(this, f);

  Collection map(f(SpeechInputResult element)) => _Collections.map(this, [], f);

  Collection<SpeechInputResult> filter(bool f(SpeechInputResult element)) =>
     _Collections.filter(this, <SpeechInputResult>[], f);

  bool every(bool f(SpeechInputResult element)) => _Collections.every(this, f);

  bool some(bool f(SpeechInputResult element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SpeechInputResult>:

  void sort([Comparator<SpeechInputResult> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SpeechInputResult element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SpeechInputResult element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SpeechInputResult get last => this[length - 1];

  SpeechInputResult removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SpeechInputResult> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SpeechInputResult initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SpeechInputResult> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SpeechInputResult>[]);

  // -- end List<SpeechInputResult> mixins.

  _SpeechInputResultImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognition
abstract class SpeechRecognition implements EventTarget {

  factory SpeechRecognition() => _SpeechRecognitionFactoryProvider.createSpeechRecognition();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SpeechRecognitionEvents get on;

  /** @domName SpeechRecognition.continuous */
  bool continuous;

  /** @domName SpeechRecognition.grammars */
  SpeechGrammarList grammars;

  /** @domName SpeechRecognition.interimResults */
  bool interimResults;

  /** @domName SpeechRecognition.lang */
  String lang;

  /** @domName SpeechRecognition.maxAlternatives */
  int maxAlternatives;

  /** @domName SpeechRecognition.abort */
  void abort();

  /** @domName SpeechRecognition.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SpeechRecognition.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName SpeechRecognition.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SpeechRecognition.start */
  void start();

  /** @domName SpeechRecognition.stop */
  void stop();
}

abstract class SpeechRecognitionEvents implements Events {

  EventListenerList get audioEnd;

  EventListenerList get audioStart;

  EventListenerList get end;

  EventListenerList get error;

  EventListenerList get noMatch;

  EventListenerList get result;

  EventListenerList get soundEnd;

  EventListenerList get soundStart;

  EventListenerList get speechEnd;

  EventListenerList get speechStart;

  EventListenerList get start;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionAlternative
abstract class SpeechRecognitionAlternative {

  /** @domName SpeechRecognitionAlternative.confidence */
  num get confidence;

  /** @domName SpeechRecognitionAlternative.transcript */
  String get transcript;
}

class _SpeechRecognitionAlternativeImpl implements SpeechRecognitionAlternative native "*SpeechRecognitionAlternative" {

  final num confidence;

  final String transcript;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionError
abstract class SpeechRecognitionError implements Event {

  static const int ABORTED = 2;

  static const int AUDIO_CAPTURE = 3;

  static const int BAD_GRAMMAR = 7;

  static const int LANGUAGE_NOT_SUPPORTED = 8;

  static const int NETWORK = 4;

  static const int NOT_ALLOWED = 5;

  static const int NO_SPEECH = 1;

  static const int OTHER = 0;

  static const int SERVICE_NOT_ALLOWED = 6;

  /** @domName SpeechRecognitionError.code */
  int get code;

  /** @domName SpeechRecognitionError.message */
  String get message;
}

class _SpeechRecognitionErrorImpl extends _EventImpl implements SpeechRecognitionError native "*SpeechRecognitionError" {

  final int code;

  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionEvent
abstract class SpeechRecognitionEvent implements Event {

  /** @domName SpeechRecognitionEvent.result */
  SpeechRecognitionResult get result;

  /** @domName SpeechRecognitionEvent.resultHistory */
  List<SpeechRecognitionResult> get resultHistory;

  /** @domName SpeechRecognitionEvent.resultIndex */
  int get resultIndex;
}

class _SpeechRecognitionEventImpl extends _EventImpl implements SpeechRecognitionEvent native "*SpeechRecognitionEvent" {

  final _SpeechRecognitionResultImpl result;

  final _SpeechRecognitionResultListImpl resultHistory;

  final int resultIndex;
}

class _SpeechRecognitionImpl extends _EventTargetImpl implements SpeechRecognition native "*SpeechRecognition" {

  _SpeechRecognitionEventsImpl get on =>
    new _SpeechRecognitionEventsImpl(this);

  bool continuous;

  _SpeechGrammarListImpl grammars;

  bool interimResults;

  String lang;

  int maxAlternatives;

  void abort() native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void start() native;

  void stop() native;
}

class _SpeechRecognitionEventsImpl extends _EventsImpl implements SpeechRecognitionEvents {
  _SpeechRecognitionEventsImpl(_ptr) : super(_ptr);

  EventListenerList get audioEnd => this['audioend'];

  EventListenerList get audioStart => this['audiostart'];

  EventListenerList get end => this['end'];

  EventListenerList get error => this['error'];

  EventListenerList get noMatch => this['nomatch'];

  EventListenerList get result => this['result'];

  EventListenerList get soundEnd => this['soundend'];

  EventListenerList get soundStart => this['soundstart'];

  EventListenerList get speechEnd => this['speechend'];

  EventListenerList get speechStart => this['speechstart'];

  EventListenerList get start => this['start'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionResult
abstract class SpeechRecognitionResult {

  /** @domName SpeechRecognitionResult.emma */
  Document get emma;

  /** @domName SpeechRecognitionResult.finalValue */
  bool get finalValue;

  /** @domName SpeechRecognitionResult.length */
  int get length;

  /** @domName SpeechRecognitionResult.item */
  SpeechRecognitionAlternative item(int index);
}

class _SpeechRecognitionResultImpl implements SpeechRecognitionResult native "*SpeechRecognitionResult" {

  final _DocumentImpl emma;

  bool get finalValue => JS("bool", "#.final", this);

  final int length;

  _SpeechRecognitionAlternativeImpl item(int index) native;
}

class _SpeechRecognitionResultListImpl implements List<SpeechRecognitionResult>, JavaScriptIndexingBehavior native "*SpeechRecognitionResultList" {

  final int length;

  _SpeechRecognitionResultImpl operator[](int index) => JS("_SpeechRecognitionResultImpl", "#[#]", this, index);

  void operator[]=(int index, _SpeechRecognitionResultImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<SpeechRecognitionResult> mixins.
  // SpeechRecognitionResult is the element type.

  // From Iterable<SpeechRecognitionResult>:

  Iterator<SpeechRecognitionResult> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<SpeechRecognitionResult>(this);
  }

  // From Collection<SpeechRecognitionResult>:

  void add(SpeechRecognitionResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(SpeechRecognitionResult value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<SpeechRecognitionResult> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(SpeechRecognitionResult element) => _Collections.contains(this, element);

  void forEach(void f(SpeechRecognitionResult element)) => _Collections.forEach(this, f);

  Collection map(f(SpeechRecognitionResult element)) => _Collections.map(this, [], f);

  Collection<SpeechRecognitionResult> filter(bool f(SpeechRecognitionResult element)) =>
     _Collections.filter(this, <SpeechRecognitionResult>[], f);

  bool every(bool f(SpeechRecognitionResult element)) => _Collections.every(this, f);

  bool some(bool f(SpeechRecognitionResult element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<SpeechRecognitionResult>:

  void sort([Comparator<SpeechRecognitionResult> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(SpeechRecognitionResult element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(SpeechRecognitionResult element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  SpeechRecognitionResult get last => this[length - 1];

  SpeechRecognitionResult removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<SpeechRecognitionResult> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [SpeechRecognitionResult initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<SpeechRecognitionResult> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <SpeechRecognitionResult>[]);

  // -- end List<SpeechRecognitionResult> mixins.

  _SpeechRecognitionResultImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName Storage
abstract class Storage implements Map<String, String> {

  /** @domName Storage.length */
  int get $dom_length;

  /** @domName Storage.clear */
  void $dom_clear();

  /** @domName Storage.getItem */
  String $dom_getItem(String key);

  /** @domName Storage.key */
  String $dom_key(int index);

  /** @domName Storage.removeItem */
  void $dom_removeItem(String key);

  /** @domName Storage.setItem */
  void $dom_setItem(String key, String data);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StorageEvent
abstract class StorageEvent implements Event {

  /** @domName StorageEvent.key */
  String get key;

  /** @domName StorageEvent.newValue */
  String get newValue;

  /** @domName StorageEvent.oldValue */
  String get oldValue;

  /** @domName StorageEvent.storageArea */
  Storage get storageArea;

  /** @domName StorageEvent.url */
  String get url;

  /** @domName StorageEvent.initStorageEvent */
  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg);
}

class _StorageEventImpl extends _EventImpl implements StorageEvent native "*StorageEvent" {

  final String key;

  final String newValue;

  final String oldValue;

  final _StorageImpl storageArea;

  final String url;

  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, _StorageImpl storageAreaArg) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _StorageImpl implements Storage native "*Storage" {

  // TODO(nweiz): update this when maps support lazy iteration
  bool containsValue(String value) => values.some((e) => e == value);

  bool containsKey(String key) => $dom_getItem(key) != null;

  String operator [](String key) => $dom_getItem(key);

  void operator []=(String key, String value) => $dom_setItem(key, value);

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) this[key] = ifAbsent();
    return this[key];
  }

  String remove(String key) {
    final value = this[key];
    $dom_removeItem(key);
    return value;
  }

  void clear() => $dom_clear();

  void forEach(void f(String key, String value)) {
    for (var i = 0; true; i++) {
      final key = $dom_key(i);
      if (key == null) return;

      f(key, this[key]);
    }
  }

  Collection<String> get keys {
    final keys = [];
    forEach((k, v) => keys.add(k));
    return keys;
  }

  Collection<String> get values {
    final values = [];
    forEach((k, v) => values.add(v));
    return values;
  }

  int get length => $dom_length;

  bool get isEmpty => $dom_key(0) == null;

  int get $dom_length => JS("int", "#.length", this);

  void $dom_clear() native "clear";

  String $dom_getItem(String key) native "getItem";

  String $dom_key(int index) native "key";

  void $dom_removeItem(String key) native "removeItem";

  void $dom_setItem(String key, String data) native "setItem";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StorageInfo
abstract class StorageInfo {

  static const int PERSISTENT = 1;

  static const int TEMPORARY = 0;

  /** @domName StorageInfo.queryUsageAndQuota */
  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]);

  /** @domName StorageInfo.requestQuota */
  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StorageInfoErrorCallback(DOMException error);

class _StorageInfoImpl implements StorageInfo native "*StorageInfo" {

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]) native;

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StorageInfoQuotaCallback(int grantedQuotaInBytes);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StorageInfoUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void StringCallback(String data);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLStyleElement
abstract class StyleElement implements Element {

  factory StyleElement() => _Elements.createStyleElement();

  /** @domName HTMLStyleElement.disabled */
  bool disabled;

  /** @domName HTMLStyleElement.media */
  String media;

  /** @domName HTMLStyleElement.scoped */
  bool scoped;

  /** @domName HTMLStyleElement.sheet */
  StyleSheet get sheet;

  /** @domName HTMLStyleElement.type */
  String type;
}

class _StyleElementImpl extends _ElementImpl implements StyleElement native "*HTMLStyleElement" {

  bool disabled;

  String media;

  bool scoped;

  final _StyleSheetImpl sheet;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleMedia
abstract class StyleMedia {

  /** @domName StyleMedia.type */
  String get type;

  /** @domName StyleMedia.matchMedium */
  bool matchMedium(String mediaquery);
}

class _StyleMediaImpl implements StyleMedia native "*StyleMedia" {

  final String type;

  bool matchMedium(String mediaquery) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleSheet
abstract class StyleSheet {

  /** @domName StyleSheet.disabled */
  bool disabled;

  /** @domName StyleSheet.href */
  String get href;

  /** @domName StyleSheet.media */
  MediaList get media;

  /** @domName StyleSheet.ownerNode */
  Node get ownerNode;

  /** @domName StyleSheet.parentStyleSheet */
  StyleSheet get parentStyleSheet;

  /** @domName StyleSheet.title */
  String get title;

  /** @domName StyleSheet.type */
  String get type;
}

class _StyleSheetImpl implements StyleSheet native "*StyleSheet" {

  bool disabled;

  final String href;

  final _MediaListImpl media;

  final _NodeImpl ownerNode;

  final _StyleSheetImpl parentStyleSheet;

  final String title;

  final String type;
}

class _StyleSheetListImpl implements List<StyleSheet>, JavaScriptIndexingBehavior native "*StyleSheetList" {

  final int length;

  _StyleSheetImpl operator[](int index) => JS("_StyleSheetImpl", "#[#]", this, index);

  void operator[]=(int index, _StyleSheetImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<StyleSheet> mixins.
  // StyleSheet is the element type.

  // From Iterable<StyleSheet>:

  Iterator<StyleSheet> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<StyleSheet>(this);
  }

  // From Collection<StyleSheet>:

  void add(StyleSheet value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(StyleSheet value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<StyleSheet> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(StyleSheet element) => _Collections.contains(this, element);

  void forEach(void f(StyleSheet element)) => _Collections.forEach(this, f);

  Collection map(f(StyleSheet element)) => _Collections.map(this, [], f);

  Collection<StyleSheet> filter(bool f(StyleSheet element)) =>
     _Collections.filter(this, <StyleSheet>[], f);

  bool every(bool f(StyleSheet element)) => _Collections.every(this, f);

  bool some(bool f(StyleSheet element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<StyleSheet>:

  void sort([Comparator<StyleSheet> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(StyleSheet element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(StyleSheet element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  StyleSheet get last => this[length - 1];

  StyleSheet removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<StyleSheet> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [StyleSheet initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<StyleSheet> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <StyleSheet>[]);

  // -- end List<StyleSheet> mixins.

  _StyleSheetImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableCaptionElement
abstract class TableCaptionElement implements Element {

  factory TableCaptionElement() => _Elements.createTableCaptionElement();

  /** @domName HTMLTableCaptionElement.align */
  String align;
}

class _TableCaptionElementImpl extends _ElementImpl implements TableCaptionElement native "*HTMLTableCaptionElement" {

  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableCellElement
abstract class TableCellElement implements Element {

  factory TableCellElement() => _Elements.createTableCellElement();

  /** @domName HTMLTableCellElement.abbr */
  String abbr;

  /** @domName HTMLTableCellElement.align */
  String align;

  /** @domName HTMLTableCellElement.axis */
  String axis;

  /** @domName HTMLTableCellElement.bgColor */
  String bgColor;

  /** @domName HTMLTableCellElement.cellIndex */
  int get cellIndex;

  /** @domName HTMLTableCellElement.ch */
  String ch;

  /** @domName HTMLTableCellElement.chOff */
  String chOff;

  /** @domName HTMLTableCellElement.colSpan */
  int colSpan;

  /** @domName HTMLTableCellElement.headers */
  String headers;

  /** @domName HTMLTableCellElement.height */
  String height;

  /** @domName HTMLTableCellElement.noWrap */
  bool noWrap;

  /** @domName HTMLTableCellElement.rowSpan */
  int rowSpan;

  /** @domName HTMLTableCellElement.scope */
  String scope;

  /** @domName HTMLTableCellElement.vAlign */
  String vAlign;

  /** @domName HTMLTableCellElement.width */
  String width;
}

class _TableCellElementImpl extends _ElementImpl implements TableCellElement native "*HTMLTableCellElement" {

  String abbr;

  String align;

  String axis;

  String bgColor;

  final int cellIndex;

  String ch;

  String chOff;

  int colSpan;

  String headers;

  String height;

  bool noWrap;

  int rowSpan;

  String scope;

  String vAlign;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableColElement
abstract class TableColElement implements Element {

  factory TableColElement() => _Elements.createTableColElement();

  /** @domName HTMLTableColElement.align */
  String align;

  /** @domName HTMLTableColElement.ch */
  String ch;

  /** @domName HTMLTableColElement.chOff */
  String chOff;

  /** @domName HTMLTableColElement.span */
  int span;

  /** @domName HTMLTableColElement.vAlign */
  String vAlign;

  /** @domName HTMLTableColElement.width */
  String width;
}

class _TableColElementImpl extends _ElementImpl implements TableColElement native "*HTMLTableColElement" {

  String align;

  String ch;

  String chOff;

  int span;

  String vAlign;

  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableElement
abstract class TableElement implements Element {

  factory TableElement() => _Elements.createTableElement();

  /** @domName HTMLTableElement.align */
  String align;

  /** @domName HTMLTableElement.bgColor */
  String bgColor;

  /** @domName HTMLTableElement.border */
  String border;

  /** @domName HTMLTableElement.caption */
  TableCaptionElement caption;

  /** @domName HTMLTableElement.cellPadding */
  String cellPadding;

  /** @domName HTMLTableElement.cellSpacing */
  String cellSpacing;

  /** @domName HTMLTableElement.frame */
  String frame;

  /** @domName HTMLTableElement.rows */
  HTMLCollection get rows;

  /** @domName HTMLTableElement.rules */
  String rules;

  /** @domName HTMLTableElement.summary */
  String summary;

  /** @domName HTMLTableElement.tBodies */
  HTMLCollection get tBodies;

  /** @domName HTMLTableElement.tFoot */
  TableSectionElement tFoot;

  /** @domName HTMLTableElement.tHead */
  TableSectionElement tHead;

  /** @domName HTMLTableElement.width */
  String width;

  /** @domName HTMLTableElement.createCaption */
  Element createCaption();

  /** @domName HTMLTableElement.createTBody */
  Element createTBody();

  /** @domName HTMLTableElement.createTFoot */
  Element createTFoot();

  /** @domName HTMLTableElement.createTHead */
  Element createTHead();

  /** @domName HTMLTableElement.deleteCaption */
  void deleteCaption();

  /** @domName HTMLTableElement.deleteRow */
  void deleteRow(int index);

  /** @domName HTMLTableElement.deleteTFoot */
  void deleteTFoot();

  /** @domName HTMLTableElement.deleteTHead */
  void deleteTHead();

  /** @domName HTMLTableElement.insertRow */
  Element insertRow(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _TableElementImpl extends _ElementImpl implements TableElement native "*HTMLTableElement" {

  String align;

  String bgColor;

  String border;

  _TableCaptionElementImpl caption;

  String cellPadding;

  String cellSpacing;

  String frame;

  final _HTMLCollectionImpl rows;

  String rules;

  String summary;

  final _HTMLCollectionImpl tBodies;

  _TableSectionElementImpl tFoot;

  _TableSectionElementImpl tHead;

  String width;

  _ElementImpl createCaption() native;

  _ElementImpl createTFoot() native;

  _ElementImpl createTHead() native;

  void deleteCaption() native;

  void deleteRow(int index) native;

  void deleteTFoot() native;

  void deleteTHead() native;

  _ElementImpl insertRow(int index) native;


  _ElementImpl createTBody() {
    if (JS('bool', '!!#.createTBody', this)) {
      return this._createTBody();
    }
    var tbody = new Element.tag('tbody');
    this.elements.add(tbody);
    return tbody;
  }

  _ElementImpl _createTBody() native 'createTBody';
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableRowElement
abstract class TableRowElement implements Element {

  factory TableRowElement() => _Elements.createTableRowElement();

  /** @domName HTMLTableRowElement.align */
  String align;

  /** @domName HTMLTableRowElement.bgColor */
  String bgColor;

  /** @domName HTMLTableRowElement.cells */
  HTMLCollection get cells;

  /** @domName HTMLTableRowElement.ch */
  String ch;

  /** @domName HTMLTableRowElement.chOff */
  String chOff;

  /** @domName HTMLTableRowElement.rowIndex */
  int get rowIndex;

  /** @domName HTMLTableRowElement.sectionRowIndex */
  int get sectionRowIndex;

  /** @domName HTMLTableRowElement.vAlign */
  String vAlign;

  /** @domName HTMLTableRowElement.deleteCell */
  void deleteCell(int index);

  /** @domName HTMLTableRowElement.insertCell */
  Element insertCell(int index);
}

class _TableRowElementImpl extends _ElementImpl implements TableRowElement native "*HTMLTableRowElement" {

  String align;

  String bgColor;

  final _HTMLCollectionImpl cells;

  String ch;

  String chOff;

  final int rowIndex;

  final int sectionRowIndex;

  String vAlign;

  void deleteCell(int index) native;

  _ElementImpl insertCell(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableSectionElement
abstract class TableSectionElement implements Element {

  /** @domName HTMLTableSectionElement.align */
  String align;

  /** @domName HTMLTableSectionElement.ch */
  String ch;

  /** @domName HTMLTableSectionElement.chOff */
  String chOff;

  /** @domName HTMLTableSectionElement.rows */
  HTMLCollection get rows;

  /** @domName HTMLTableSectionElement.vAlign */
  String vAlign;

  /** @domName HTMLTableSectionElement.deleteRow */
  void deleteRow(int index);

  /** @domName HTMLTableSectionElement.insertRow */
  Element insertRow(int index);
}

class _TableSectionElementImpl extends _ElementImpl implements TableSectionElement native "*HTMLTableSectionElement" {

  String align;

  String ch;

  String chOff;

  final _HTMLCollectionImpl rows;

  String vAlign;

  void deleteRow(int index) native;

  _ElementImpl insertRow(int index) native;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName Text
abstract class Text implements CharacterData {

  factory Text(String data) => _TextFactoryProvider.createText(data);

  /** @domName Text.wholeText */
  String get wholeText;

  /** @domName Text.replaceWholeText */
  Text replaceWholeText(String content);

  /** @domName Text.splitText */
  Text splitText(int offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTextAreaElement
abstract class TextAreaElement implements Element {

  factory TextAreaElement() => _Elements.createTextAreaElement();

  /** @domName HTMLTextAreaElement.autofocus */
  bool autofocus;

  /** @domName HTMLTextAreaElement.cols */
  int cols;

  /** @domName HTMLTextAreaElement.defaultValue */
  String defaultValue;

  /** @domName HTMLTextAreaElement.dirName */
  String dirName;

  /** @domName HTMLTextAreaElement.disabled */
  bool disabled;

  /** @domName HTMLTextAreaElement.form */
  FormElement get form;

  /** @domName HTMLTextAreaElement.labels */
  List<Node> get labels;

  /** @domName HTMLTextAreaElement.maxLength */
  int maxLength;

  /** @domName HTMLTextAreaElement.name */
  String name;

  /** @domName HTMLTextAreaElement.placeholder */
  String placeholder;

  /** @domName HTMLTextAreaElement.readOnly */
  bool readOnly;

  /** @domName HTMLTextAreaElement.required */
  bool required;

  /** @domName HTMLTextAreaElement.rows */
  int rows;

  /** @domName HTMLTextAreaElement.selectionDirection */
  String selectionDirection;

  /** @domName HTMLTextAreaElement.selectionEnd */
  int selectionEnd;

  /** @domName HTMLTextAreaElement.selectionStart */
  int selectionStart;

  /** @domName HTMLTextAreaElement.textLength */
  int get textLength;

  /** @domName HTMLTextAreaElement.type */
  String get type;

  /** @domName HTMLTextAreaElement.validationMessage */
  String get validationMessage;

  /** @domName HTMLTextAreaElement.validity */
  ValidityState get validity;

  /** @domName HTMLTextAreaElement.value */
  String value;

  /** @domName HTMLTextAreaElement.willValidate */
  bool get willValidate;

  /** @domName HTMLTextAreaElement.wrap */
  String wrap;

  /** @domName HTMLTextAreaElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLTextAreaElement.select */
  void select();

  /** @domName HTMLTextAreaElement.setCustomValidity */
  void setCustomValidity(String error);

  /** @domName HTMLTextAreaElement.setRangeText */
  void setRangeText(String replacement, [int start, int end, String selectionMode]);

  /** @domName HTMLTextAreaElement.setSelectionRange */
  void setSelectionRange(int start, int end, [String direction]);
}

class _TextAreaElementImpl extends _ElementImpl implements TextAreaElement native "*HTMLTextAreaElement" {

  bool autofocus;

  int cols;

  String defaultValue;

  String dirName;

  bool disabled;

  final _FormElementImpl form;

  final List<Node> labels;

  int maxLength;

  String name;

  String placeholder;

  bool readOnly;

  bool required;

  int rows;

  String selectionDirection;

  int selectionEnd;

  int selectionStart;

  final int textLength;

  final String type;

  final String validationMessage;

  final _ValidityStateImpl validity;

  String value;

  final bool willValidate;

  String wrap;

  bool checkValidity() native;

  void select() native;

  void setCustomValidity(String error) native;

  void setRangeText(String replacement, [int start, int end, String selectionMode]) native;

  void setSelectionRange(int start, int end, [String direction]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextEvent
abstract class TextEvent implements UIEvent {

  /** @domName TextEvent.data */
  String get data;

  /** @domName TextEvent.initTextEvent */
  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, LocalWindow viewArg, String dataArg);
}

class _TextEventImpl extends _UIEventImpl implements TextEvent native "*TextEvent" {

  final String data;

  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, _LocalWindowImpl viewArg, String dataArg) native;
}

class _TextImpl extends _CharacterDataImpl implements Text native "*Text" {

  final String wholeText;

  _TextImpl replaceWholeText(String content) native;

  _TextImpl splitText(int offset) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextMetrics
abstract class TextMetrics {

  /** @domName TextMetrics.width */
  num get width;
}

class _TextMetricsImpl implements TextMetrics native "*TextMetrics" {

  final num width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrack
abstract class TextTrack implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackEvents get on;

  /** @domName TextTrack.activeCues */
  TextTrackCueList get activeCues;

  /** @domName TextTrack.cues */
  TextTrackCueList get cues;

  /** @domName TextTrack.kind */
  String get kind;

  /** @domName TextTrack.label */
  String get label;

  /** @domName TextTrack.language */
  String get language;

  /** @domName TextTrack.mode */
  String mode;

  /** @domName TextTrack.addCue */
  void addCue(TextTrackCue cue);

  /** @domName TextTrack.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrack.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrack.removeCue */
  void removeCue(TextTrackCue cue);

  /** @domName TextTrack.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class TextTrackEvents implements Events {

  EventListenerList get cueChange;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackCue
abstract class TextTrackCue implements EventTarget {

  factory TextTrackCue(num startTime, num endTime, String text) => _TextTrackCueFactoryProvider.createTextTrackCue(startTime, endTime, text);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackCueEvents get on;

  /** @domName TextTrackCue.align */
  String align;

  /** @domName TextTrackCue.endTime */
  num endTime;

  /** @domName TextTrackCue.id */
  String id;

  /** @domName TextTrackCue.line */
  int line;

  /** @domName TextTrackCue.pauseOnExit */
  bool pauseOnExit;

  /** @domName TextTrackCue.position */
  int position;

  /** @domName TextTrackCue.size */
  int size;

  /** @domName TextTrackCue.snapToLines */
  bool snapToLines;

  /** @domName TextTrackCue.startTime */
  num startTime;

  /** @domName TextTrackCue.text */
  String text;

  /** @domName TextTrackCue.track */
  TextTrack get track;

  /** @domName TextTrackCue.vertical */
  String vertical;

  /** @domName TextTrackCue.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrackCue.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrackCue.getCueAsHTML */
  DocumentFragment getCueAsHTML();

  /** @domName TextTrackCue.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class TextTrackCueEvents implements Events {

  EventListenerList get enter;

  EventListenerList get exit;
}

class _TextTrackCueImpl extends _EventTargetImpl implements TextTrackCue native "*TextTrackCue" {

  _TextTrackCueEventsImpl get on =>
    new _TextTrackCueEventsImpl(this);

  String align;

  num endTime;

  String id;

  int line;

  bool pauseOnExit;

  int position;

  int size;

  bool snapToLines;

  num startTime;

  String text;

  final _TextTrackImpl track;

  String vertical;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  _DocumentFragmentImpl getCueAsHTML() native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _TextTrackCueEventsImpl extends _EventsImpl implements TextTrackCueEvents {
  _TextTrackCueEventsImpl(_ptr) : super(_ptr);

  EventListenerList get enter => this['enter'];

  EventListenerList get exit => this['exit'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackCueList
abstract class TextTrackCueList implements List<TextTrackCue> {

  /** @domName TextTrackCueList.length */
  int get length;

  /** @domName TextTrackCueList.getCueById */
  TextTrackCue getCueById(String id);

  /** @domName TextTrackCueList.item */
  TextTrackCue item(int index);
}

class _TextTrackCueListImpl implements TextTrackCueList, JavaScriptIndexingBehavior native "*TextTrackCueList" {

  final int length;

  _TextTrackCueImpl operator[](int index) => JS("_TextTrackCueImpl", "#[#]", this, index);

  void operator[]=(int index, _TextTrackCueImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<TextTrackCue> mixins.
  // TextTrackCue is the element type.

  // From Iterable<TextTrackCue>:

  Iterator<TextTrackCue> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<TextTrackCue>(this);
  }

  // From Collection<TextTrackCue>:

  void add(TextTrackCue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(TextTrackCue value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<TextTrackCue> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(TextTrackCue element) => _Collections.contains(this, element);

  void forEach(void f(TextTrackCue element)) => _Collections.forEach(this, f);

  Collection map(f(TextTrackCue element)) => _Collections.map(this, [], f);

  Collection<TextTrackCue> filter(bool f(TextTrackCue element)) =>
     _Collections.filter(this, <TextTrackCue>[], f);

  bool every(bool f(TextTrackCue element)) => _Collections.every(this, f);

  bool some(bool f(TextTrackCue element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<TextTrackCue>:

  void sort([Comparator<TextTrackCue> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(TextTrackCue element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(TextTrackCue element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  TextTrackCue get last => this[length - 1];

  TextTrackCue removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<TextTrackCue> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [TextTrackCue initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<TextTrackCue> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <TextTrackCue>[]);

  // -- end List<TextTrackCue> mixins.

  _TextTrackCueImpl getCueById(String id) native;

  _TextTrackCueImpl item(int index) native;
}

class _TextTrackImpl extends _EventTargetImpl implements TextTrack native "*TextTrack" {

  _TextTrackEventsImpl get on =>
    new _TextTrackEventsImpl(this);

  final _TextTrackCueListImpl activeCues;

  final _TextTrackCueListImpl cues;

  final String kind;

  final String label;

  final String language;

  String mode;

  void addCue(_TextTrackCueImpl cue) native;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void removeCue(_TextTrackCueImpl cue) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _TextTrackEventsImpl extends _EventsImpl implements TextTrackEvents {
  _TextTrackEventsImpl(_ptr) : super(_ptr);

  EventListenerList get cueChange => this['cuechange'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackList
abstract class TextTrackList implements EventTarget, List<TextTrack> {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackListEvents get on;

  /** @domName TextTrackList.length */
  int get length;

  /** @domName TextTrackList.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrackList.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrackList.item */
  TextTrack item(int index);

  /** @domName TextTrackList.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

abstract class TextTrackListEvents implements Events {

  EventListenerList get addTrack;
}

class _TextTrackListImpl extends _EventTargetImpl implements TextTrackList, JavaScriptIndexingBehavior native "*TextTrackList" {

  _TextTrackListEventsImpl get on =>
    new _TextTrackListEventsImpl(this);

  final int length;

  _TextTrackImpl operator[](int index) => JS("_TextTrackImpl", "#[#]", this, index);

  void operator[]=(int index, _TextTrackImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<TextTrack> mixins.
  // TextTrack is the element type.

  // From Iterable<TextTrack>:

  Iterator<TextTrack> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<TextTrack>(this);
  }

  // From Collection<TextTrack>:

  void add(TextTrack value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(TextTrack value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<TextTrack> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(TextTrack element) => _Collections.contains(this, element);

  void forEach(void f(TextTrack element)) => _Collections.forEach(this, f);

  Collection map(f(TextTrack element)) => _Collections.map(this, [], f);

  Collection<TextTrack> filter(bool f(TextTrack element)) =>
     _Collections.filter(this, <TextTrack>[], f);

  bool every(bool f(TextTrack element)) => _Collections.every(this, f);

  bool some(bool f(TextTrack element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<TextTrack>:

  void sort([Comparator<TextTrack> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(TextTrack element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(TextTrack element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  TextTrack get last => this[length - 1];

  TextTrack removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<TextTrack> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [TextTrack initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<TextTrack> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <TextTrack>[]);

  // -- end List<TextTrack> mixins.

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  _TextTrackImpl item(int index) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}

class _TextTrackListEventsImpl extends _EventsImpl implements TextTrackListEvents {
  _TextTrackListEventsImpl(_ptr) : super(_ptr);

  EventListenerList get addTrack => this['addtrack'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TimeRanges
abstract class TimeRanges {

  /** @domName TimeRanges.length */
  int get length;

  /** @domName TimeRanges.end */
  num end(int index);

  /** @domName TimeRanges.start */
  num start(int index);
}

class _TimeRangesImpl implements TimeRanges native "*TimeRanges" {

  final int length;

  num end(int index) native;

  num start(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void TimeoutHandler();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTitleElement
abstract class TitleElement implements Element {

  factory TitleElement() => _Elements.createTitleElement();
}

class _TitleElementImpl extends _ElementImpl implements TitleElement native "*HTMLTitleElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Touch
abstract class Touch {

  /** @domName Touch.clientX */
  int get clientX;

  /** @domName Touch.clientY */
  int get clientY;

  /** @domName Touch.identifier */
  int get identifier;

  /** @domName Touch.pageX */
  int get pageX;

  /** @domName Touch.pageY */
  int get pageY;

  /** @domName Touch.screenX */
  int get screenX;

  /** @domName Touch.screenY */
  int get screenY;

  /** @domName Touch.target */
  EventTarget get target;

  /** @domName Touch.webkitForce */
  num get webkitForce;

  /** @domName Touch.webkitRadiusX */
  int get webkitRadiusX;

  /** @domName Touch.webkitRadiusY */
  int get webkitRadiusY;

  /** @domName Touch.webkitRotationAngle */
  num get webkitRotationAngle;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TouchEvent
abstract class TouchEvent implements UIEvent {

  /** @domName TouchEvent.altKey */
  bool get altKey;

  /** @domName TouchEvent.changedTouches */
  TouchList get changedTouches;

  /** @domName TouchEvent.ctrlKey */
  bool get ctrlKey;

  /** @domName TouchEvent.metaKey */
  bool get metaKey;

  /** @domName TouchEvent.shiftKey */
  bool get shiftKey;

  /** @domName TouchEvent.targetTouches */
  TouchList get targetTouches;

  /** @domName TouchEvent.touches */
  TouchList get touches;

  /** @domName TouchEvent.initTouchEvent */
  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, LocalWindow view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
}

class _TouchEventImpl extends _UIEventImpl implements TouchEvent native "*TouchEvent" {

  final bool altKey;

  final _TouchListImpl changedTouches;

  final bool ctrlKey;

  final bool metaKey;

  final bool shiftKey;

  final _TouchListImpl targetTouches;

  final _TouchListImpl touches;

  void initTouchEvent(_TouchListImpl touches, _TouchListImpl targetTouches, _TouchListImpl changedTouches, String type, _LocalWindowImpl view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;
}

class _TouchImpl implements Touch native "*Touch" {

  final int clientX;

  final int clientY;

  final int identifier;

  final int pageX;

  final int pageY;

  final int screenX;

  final int screenY;

  EventTarget get target => _convertNativeToDart_EventTarget(this._target);
  EventTarget get _target => JS("EventTarget", "#.target", this);

  final num webkitForce;

  final int webkitRadiusX;

  final int webkitRadiusY;

  final num webkitRotationAngle;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TouchList
abstract class TouchList implements List<Touch> {

  /** @domName TouchList.length */
  int get length;

  /** @domName TouchList.item */
  Touch item(int index);
}

class _TouchListImpl implements TouchList, JavaScriptIndexingBehavior native "*TouchList" {

  final int length;

  _TouchImpl operator[](int index) => JS("_TouchImpl", "#[#]", this, index);

  void operator[]=(int index, _TouchImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Touch> mixins.
  // Touch is the element type.

  // From Iterable<Touch>:

  Iterator<Touch> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Touch>(this);
  }

  // From Collection<Touch>:

  void add(Touch value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Touch value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Touch> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Touch element) => _Collections.contains(this, element);

  void forEach(void f(Touch element)) => _Collections.forEach(this, f);

  Collection map(f(Touch element)) => _Collections.map(this, [], f);

  Collection<Touch> filter(bool f(Touch element)) =>
     _Collections.filter(this, <Touch>[], f);

  bool every(bool f(Touch element)) => _Collections.every(this, f);

  bool some(bool f(Touch element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Touch>:

  void sort([Comparator<Touch> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Touch element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Touch element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Touch get last => this[length - 1];

  Touch removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Touch> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Touch initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Touch> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Touch>[]);

  // -- end List<Touch> mixins.

  _TouchImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTrackElement
abstract class TrackElement implements Element {

  factory TrackElement() => _Elements.createTrackElement();

  static const int ERROR = 3;

  static const int LOADED = 2;

  static const int LOADING = 1;

  static const int NONE = 0;

  /** @domName HTMLTrackElement.defaultValue */
  bool defaultValue;

  /** @domName HTMLTrackElement.kind */
  String kind;

  /** @domName HTMLTrackElement.label */
  String label;

  /** @domName HTMLTrackElement.readyState */
  int get readyState;

  /** @domName HTMLTrackElement.src */
  String src;

  /** @domName HTMLTrackElement.srclang */
  String srclang;

  /** @domName HTMLTrackElement.track */
  TextTrack get track;
}

class _TrackElementImpl extends _ElementImpl implements TrackElement native "*HTMLTrackElement" {

  bool get defaultValue => JS("bool", "#.default", this);

  void set defaultValue(bool value) {
    JS("void", "#.default = #", this, value);
  }

  String kind;

  String label;

  final int readyState;

  String src;

  String srclang;

  final _TextTrackImpl track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TrackEvent
abstract class TrackEvent implements Event {

  /** @domName TrackEvent.track */
  Object get track;
}

class _TrackEventImpl extends _EventImpl implements TrackEvent native "*TrackEvent" {

  final Object track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitTransitionEvent
abstract class TransitionEvent implements Event {

  /** @domName WebKitTransitionEvent.elapsedTime */
  num get elapsedTime;

  /** @domName WebKitTransitionEvent.propertyName */
  String get propertyName;
}

class _TransitionEventImpl extends _EventImpl implements TransitionEvent native "*WebKitTransitionEvent" {

  final num elapsedTime;

  final String propertyName;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TreeWalker
abstract class TreeWalker {

  /** @domName TreeWalker.currentNode */
  Node currentNode;

  /** @domName TreeWalker.expandEntityReferences */
  bool get expandEntityReferences;

  /** @domName TreeWalker.filter */
  NodeFilter get filter;

  /** @domName TreeWalker.root */
  Node get root;

  /** @domName TreeWalker.whatToShow */
  int get whatToShow;

  /** @domName TreeWalker.firstChild */
  Node firstChild();

  /** @domName TreeWalker.lastChild */
  Node lastChild();

  /** @domName TreeWalker.nextNode */
  Node nextNode();

  /** @domName TreeWalker.nextSibling */
  Node nextSibling();

  /** @domName TreeWalker.parentNode */
  Node parentNode();

  /** @domName TreeWalker.previousNode */
  Node previousNode();

  /** @domName TreeWalker.previousSibling */
  Node previousSibling();
}

class _TreeWalkerImpl implements TreeWalker native "*TreeWalker" {

  _NodeImpl currentNode;

  final bool expandEntityReferences;

  final _NodeFilterImpl filter;

  final _NodeImpl root;

  final int whatToShow;

  _NodeImpl firstChild() native;

  _NodeImpl lastChild() native;

  _NodeImpl nextNode() native;

  _NodeImpl nextSibling() native;

  _NodeImpl parentNode() native;

  _NodeImpl previousNode() native;

  _NodeImpl previousSibling() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName UIEvent
abstract class UIEvent implements Event {

  /** @domName UIEvent.charCode */
  int get charCode;

  /** @domName UIEvent.detail */
  int get detail;

  /** @domName UIEvent.keyCode */
  int get keyCode;

  /** @domName UIEvent.layerX */
  int get layerX;

  /** @domName UIEvent.layerY */
  int get layerY;

  /** @domName UIEvent.pageX */
  int get pageX;

  /** @domName UIEvent.pageY */
  int get pageY;

  /** @domName UIEvent.view */
  Window get view;

  /** @domName UIEvent.which */
  int get which;

  /** @domName UIEvent.initUIEvent */
  void initUIEvent(String type, bool canBubble, bool cancelable, LocalWindow view, int detail);
}

class _UIEventImpl extends _EventImpl implements UIEvent native "*UIEvent" {

  final int charCode;

  final int detail;

  final int keyCode;

  final int layerX;

  final int layerY;

  final int pageX;

  final int pageY;

  Window get view => _convertNativeToDart_Window(this._view);
  Window get _view => JS("Window", "#.view", this);

  final int which;

  void initUIEvent(String type, bool canBubble, bool cancelable, _LocalWindowImpl view, int detail) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLUListElement
abstract class UListElement implements Element {

  factory UListElement() => _Elements.createUListElement();

  /** @domName HTMLUListElement.compact */
  bool compact;

  /** @domName HTMLUListElement.type */
  String type;
}

class _UListElementImpl extends _ElementImpl implements UListElement native "*HTMLUListElement" {

  bool compact;

  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint16Array
abstract class Uint16Array implements ArrayBufferView, List<int> {

  factory Uint16Array(int length) =>
    _TypedArrayFactoryProvider.createUint16Array(length);

  factory Uint16Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint16Array_fromList(list);

  factory Uint16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint16Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 2;

  /** @domName Uint16Array.length */
  int get length;

  /** @domName Uint16Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint16Array.subarray */
  Uint16Array subarray(int start, [int end]);
}

class _Uint16ArrayImpl extends _ArrayBufferViewImpl implements Uint16Array, List<int>, JavaScriptIndexingBehavior native "*Uint16Array" {

  final int length;

  int operator[](int index) => JS("int", "#[#]", this, index);

  void operator[]=(int index, int value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(int element) => _Collections.contains(this, element);

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<int>:

  void sort([Comparator<int> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int get last => this[length - 1];

  int removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Uint16ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint32Array
abstract class Uint32Array implements ArrayBufferView, List<int> {

  factory Uint32Array(int length) =>
    _TypedArrayFactoryProvider.createUint32Array(length);

  factory Uint32Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint32Array_fromList(list);

  factory Uint32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint32Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 4;

  /** @domName Uint32Array.length */
  int get length;

  /** @domName Uint32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint32Array.subarray */
  Uint32Array subarray(int start, [int end]);
}

class _Uint32ArrayImpl extends _ArrayBufferViewImpl implements Uint32Array, List<int>, JavaScriptIndexingBehavior native "*Uint32Array" {

  final int length;

  int operator[](int index) => JS("int", "#[#]", this, index);

  void operator[]=(int index, int value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(int element) => _Collections.contains(this, element);

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<int>:

  void sort([Comparator<int> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int get last => this[length - 1];

  int removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Uint32ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint8Array
abstract class Uint8Array implements ArrayBufferView, List<int> {

  factory Uint8Array(int length) =>
    _TypedArrayFactoryProvider.createUint8Array(length);

  factory Uint8Array.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint8Array_fromList(list);

  factory Uint8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint8Array_fromBuffer(buffer, byteOffset, length);

  static const int BYTES_PER_ELEMENT = 1;

  /** @domName Uint8Array.length */
  int get length;

  /** @domName Uint8Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint8Array.subarray */
  Uint8Array subarray(int start, [int end]);
}

class _Uint8ArrayImpl extends _ArrayBufferViewImpl implements Uint8Array, List<int>, JavaScriptIndexingBehavior native "*Uint8Array" {

  final int length;

  int operator[](int index) => JS("int", "#[#]", this, index);

  void operator[]=(int index, int value) => JS("void", "#[#] = #", this, index, value);
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(int element) => _Collections.contains(this, element);

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<int>:

  void sort([Comparator<int> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int get last => this[length - 1];

  int removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset]) native "set";

  _Uint8ArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint8ClampedArray
abstract class Uint8ClampedArray implements Uint8Array {

  factory Uint8ClampedArray(int length) =>
    _TypedArrayFactoryProvider.createUint8ClampedArray(length);

  factory Uint8ClampedArray.fromList(List<int> list) =>
    _TypedArrayFactoryProvider.createUint8ClampedArray_fromList(list);

  factory Uint8ClampedArray.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]) => 
    _TypedArrayFactoryProvider.createUint8ClampedArray_fromBuffer(buffer, byteOffset, length);

  /** @domName Uint8ClampedArray.length */
  int get length;

  /** @domName Uint8ClampedArray.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint8ClampedArray.subarray */
  Uint8ClampedArray subarray(int start, [int end]);
}

class _Uint8ClampedArrayImpl extends _Uint8ArrayImpl implements Uint8ClampedArray native "*Uint8ClampedArray" {

  // Use implementation from Uint8Array.
  // final int length;

  void setElements(Object array, [int offset]) native "set";

  _Uint8ClampedArrayImpl subarray(int start, [int end]) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLUnknownElement
abstract class UnknownElement implements Element {
}

class _UnknownElementImpl extends _ElementImpl implements UnknownElement native "*HTMLUnknownElement" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ValidityState
abstract class ValidityState {

  /** @domName ValidityState.customError */
  bool get customError;

  /** @domName ValidityState.patternMismatch */
  bool get patternMismatch;

  /** @domName ValidityState.rangeOverflow */
  bool get rangeOverflow;

  /** @domName ValidityState.rangeUnderflow */
  bool get rangeUnderflow;

  /** @domName ValidityState.stepMismatch */
  bool get stepMismatch;

  /** @domName ValidityState.tooLong */
  bool get tooLong;

  /** @domName ValidityState.typeMismatch */
  bool get typeMismatch;

  /** @domName ValidityState.valid */
  bool get valid;

  /** @domName ValidityState.valueMissing */
  bool get valueMissing;
}

class _ValidityStateImpl implements ValidityState native "*ValidityState" {

  final bool customError;

  final bool patternMismatch;

  final bool rangeOverflow;

  final bool rangeUnderflow;

  final bool stepMismatch;

  final bool tooLong;

  final bool typeMismatch;

  final bool valid;

  final bool valueMissing;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLVideoElement
abstract class VideoElement implements MediaElement {

  factory VideoElement() => _Elements.createVideoElement();

  /** @domName HTMLVideoElement.height */
  int height;

  /** @domName HTMLVideoElement.poster */
  String poster;

  /** @domName HTMLVideoElement.videoHeight */
  int get videoHeight;

  /** @domName HTMLVideoElement.videoWidth */
  int get videoWidth;

  /** @domName HTMLVideoElement.webkitDecodedFrameCount */
  int get webkitDecodedFrameCount;

  /** @domName HTMLVideoElement.webkitDisplayingFullscreen */
  bool get webkitDisplayingFullscreen;

  /** @domName HTMLVideoElement.webkitDroppedFrameCount */
  int get webkitDroppedFrameCount;

  /** @domName HTMLVideoElement.webkitSupportsFullscreen */
  bool get webkitSupportsFullscreen;

  /** @domName HTMLVideoElement.width */
  int width;

  /** @domName HTMLVideoElement.webkitEnterFullScreen */
  void webkitEnterFullScreen();

  /** @domName HTMLVideoElement.webkitEnterFullscreen */
  void webkitEnterFullscreen();

  /** @domName HTMLVideoElement.webkitExitFullScreen */
  void webkitExitFullScreen();

  /** @domName HTMLVideoElement.webkitExitFullscreen */
  void webkitExitFullscreen();
}

class _VideoElementImpl extends _MediaElementImpl implements VideoElement native "*HTMLVideoElement" {

  int height;

  String poster;

  final int videoHeight;

  final int videoWidth;

  final int webkitDecodedFrameCount;

  final bool webkitDisplayingFullscreen;

  final int webkitDroppedFrameCount;

  final bool webkitSupportsFullscreen;

  int width;

  void webkitEnterFullScreen() native;

  void webkitEnterFullscreen() native;

  void webkitExitFullScreen() native;

  void webkitExitFullscreen() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


typedef void VoidCallback();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WaveShaperNode
abstract class WaveShaperNode implements AudioNode {

  /** @domName WaveShaperNode.curve */
  Float32Array curve;
}

class _WaveShaperNodeImpl extends _AudioNodeImpl implements WaveShaperNode native "*WaveShaperNode" {

  _Float32ArrayImpl curve;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WaveTable
abstract class WaveTable {
}

class _WaveTableImpl implements WaveTable native "*WaveTable" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLActiveInfo
abstract class WebGLActiveInfo {

  /** @domName WebGLActiveInfo.name */
  String get name;

  /** @domName WebGLActiveInfo.size */
  int get size;

  /** @domName WebGLActiveInfo.type */
  int get type;
}

class _WebGLActiveInfoImpl implements WebGLActiveInfo native "*WebGLActiveInfo" {

  final String name;

  final int size;

  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLBuffer
abstract class WebGLBuffer {
}

class _WebGLBufferImpl implements WebGLBuffer native "*WebGLBuffer" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLCompressedTextureS3TC
abstract class WebGLCompressedTextureS3TC {

  static const int COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;

  static const int COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;

  static const int COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

  static const int COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
}

class _WebGLCompressedTextureS3TCImpl implements WebGLCompressedTextureS3TC native "*WebGLCompressedTextureS3TC" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLContextAttributes
abstract class WebGLContextAttributes {

  /** @domName WebGLContextAttributes.alpha */
  bool alpha;

  /** @domName WebGLContextAttributes.antialias */
  bool antialias;

  /** @domName WebGLContextAttributes.depth */
  bool depth;

  /** @domName WebGLContextAttributes.premultipliedAlpha */
  bool premultipliedAlpha;

  /** @domName WebGLContextAttributes.preserveDrawingBuffer */
  bool preserveDrawingBuffer;

  /** @domName WebGLContextAttributes.stencil */
  bool stencil;
}

class _WebGLContextAttributesImpl implements WebGLContextAttributes native "*WebGLContextAttributes" {

  bool alpha;

  bool antialias;

  bool depth;

  bool premultipliedAlpha;

  bool preserveDrawingBuffer;

  bool stencil;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLContextEvent
abstract class WebGLContextEvent implements Event {

  /** @domName WebGLContextEvent.statusMessage */
  String get statusMessage;
}

class _WebGLContextEventImpl extends _EventImpl implements WebGLContextEvent native "*WebGLContextEvent" {

  final String statusMessage;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLDebugRendererInfo
abstract class WebGLDebugRendererInfo {

  static const int UNMASKED_RENDERER_WEBGL = 0x9246;

  static const int UNMASKED_VENDOR_WEBGL = 0x9245;
}

class _WebGLDebugRendererInfoImpl implements WebGLDebugRendererInfo native "*WebGLDebugRendererInfo" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLDebugShaders
abstract class WebGLDebugShaders {

  /** @domName WebGLDebugShaders.getTranslatedShaderSource */
  String getTranslatedShaderSource(WebGLShader shader);
}

class _WebGLDebugShadersImpl implements WebGLDebugShaders native "*WebGLDebugShaders" {

  String getTranslatedShaderSource(_WebGLShaderImpl shader) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLDepthTexture
abstract class WebGLDepthTexture {

  static const int UNSIGNED_INT_24_8_WEBGL = 0x84FA;
}

class _WebGLDepthTextureImpl implements WebGLDepthTexture native "*WebGLDepthTexture" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLFramebuffer
abstract class WebGLFramebuffer {
}

class _WebGLFramebufferImpl implements WebGLFramebuffer native "*WebGLFramebuffer" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLLoseContext
abstract class WebGLLoseContext {

  /** @domName WebGLLoseContext.loseContext */
  void loseContext();

  /** @domName WebGLLoseContext.restoreContext */
  void restoreContext();
}

class _WebGLLoseContextImpl implements WebGLLoseContext native "*WebGLLoseContext" {

  void loseContext() native;

  void restoreContext() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLProgram
abstract class WebGLProgram {
}

class _WebGLProgramImpl implements WebGLProgram native "*WebGLProgram" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLRenderbuffer
abstract class WebGLRenderbuffer {
}

class _WebGLRenderbufferImpl implements WebGLRenderbuffer native "*WebGLRenderbuffer" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLRenderingContext
abstract class WebGLRenderingContext implements CanvasRenderingContext {

  static const int ACTIVE_ATTRIBUTES = 0x8B89;

  static const int ACTIVE_TEXTURE = 0x84E0;

  static const int ACTIVE_UNIFORMS = 0x8B86;

  static const int ALIASED_LINE_WIDTH_RANGE = 0x846E;

  static const int ALIASED_POINT_SIZE_RANGE = 0x846D;

  static const int ALPHA = 0x1906;

  static const int ALPHA_BITS = 0x0D55;

  static const int ALWAYS = 0x0207;

  static const int ARRAY_BUFFER = 0x8892;

  static const int ARRAY_BUFFER_BINDING = 0x8894;

  static const int ATTACHED_SHADERS = 0x8B85;

  static const int BACK = 0x0405;

  static const int BLEND = 0x0BE2;

  static const int BLEND_COLOR = 0x8005;

  static const int BLEND_DST_ALPHA = 0x80CA;

  static const int BLEND_DST_RGB = 0x80C8;

  static const int BLEND_EQUATION = 0x8009;

  static const int BLEND_EQUATION_ALPHA = 0x883D;

  static const int BLEND_EQUATION_RGB = 0x8009;

  static const int BLEND_SRC_ALPHA = 0x80CB;

  static const int BLEND_SRC_RGB = 0x80C9;

  static const int BLUE_BITS = 0x0D54;

  static const int BOOL = 0x8B56;

  static const int BOOL_VEC2 = 0x8B57;

  static const int BOOL_VEC3 = 0x8B58;

  static const int BOOL_VEC4 = 0x8B59;

  static const int BROWSER_DEFAULT_WEBGL = 0x9244;

  static const int BUFFER_SIZE = 0x8764;

  static const int BUFFER_USAGE = 0x8765;

  static const int BYTE = 0x1400;

  static const int CCW = 0x0901;

  static const int CLAMP_TO_EDGE = 0x812F;

  static const int COLOR_ATTACHMENT0 = 0x8CE0;

  static const int COLOR_BUFFER_BIT = 0x00004000;

  static const int COLOR_CLEAR_VALUE = 0x0C22;

  static const int COLOR_WRITEMASK = 0x0C23;

  static const int COMPILE_STATUS = 0x8B81;

  static const int COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  static const int CONSTANT_ALPHA = 0x8003;

  static const int CONSTANT_COLOR = 0x8001;

  static const int CONTEXT_LOST_WEBGL = 0x9242;

  static const int CULL_FACE = 0x0B44;

  static const int CULL_FACE_MODE = 0x0B45;

  static const int CURRENT_PROGRAM = 0x8B8D;

  static const int CURRENT_VERTEX_ATTRIB = 0x8626;

  static const int CW = 0x0900;

  static const int DECR = 0x1E03;

  static const int DECR_WRAP = 0x8508;

  static const int DELETE_STATUS = 0x8B80;

  static const int DEPTH_ATTACHMENT = 0x8D00;

  static const int DEPTH_BITS = 0x0D56;

  static const int DEPTH_BUFFER_BIT = 0x00000100;

  static const int DEPTH_CLEAR_VALUE = 0x0B73;

  static const int DEPTH_COMPONENT = 0x1902;

  static const int DEPTH_COMPONENT16 = 0x81A5;

  static const int DEPTH_FUNC = 0x0B74;

  static const int DEPTH_RANGE = 0x0B70;

  static const int DEPTH_STENCIL = 0x84F9;

  static const int DEPTH_STENCIL_ATTACHMENT = 0x821A;

  static const int DEPTH_TEST = 0x0B71;

  static const int DEPTH_WRITEMASK = 0x0B72;

  static const int DITHER = 0x0BD0;

  static const int DONT_CARE = 0x1100;

  static const int DST_ALPHA = 0x0304;

  static const int DST_COLOR = 0x0306;

  static const int DYNAMIC_DRAW = 0x88E8;

  static const int ELEMENT_ARRAY_BUFFER = 0x8893;

  static const int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

  static const int EQUAL = 0x0202;

  static const int FASTEST = 0x1101;

  static const int FLOAT = 0x1406;

  static const int FLOAT_MAT2 = 0x8B5A;

  static const int FLOAT_MAT3 = 0x8B5B;

  static const int FLOAT_MAT4 = 0x8B5C;

  static const int FLOAT_VEC2 = 0x8B50;

  static const int FLOAT_VEC3 = 0x8B51;

  static const int FLOAT_VEC4 = 0x8B52;

  static const int FRAGMENT_SHADER = 0x8B30;

  static const int FRAMEBUFFER = 0x8D40;

  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;

  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;

  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;

  static const int FRAMEBUFFER_BINDING = 0x8CA6;

  static const int FRAMEBUFFER_COMPLETE = 0x8CD5;

  static const int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;

  static const int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;

  static const int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;

  static const int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  static const int FRONT = 0x0404;

  static const int FRONT_AND_BACK = 0x0408;

  static const int FRONT_FACE = 0x0B46;

  static const int FUNC_ADD = 0x8006;

  static const int FUNC_REVERSE_SUBTRACT = 0x800B;

  static const int FUNC_SUBTRACT = 0x800A;

  static const int GENERATE_MIPMAP_HINT = 0x8192;

  static const int GEQUAL = 0x0206;

  static const int GREATER = 0x0204;

  static const int GREEN_BITS = 0x0D53;

  static const int HIGH_FLOAT = 0x8DF2;

  static const int HIGH_INT = 0x8DF5;

  static const int INCR = 0x1E02;

  static const int INCR_WRAP = 0x8507;

  static const int INT = 0x1404;

  static const int INT_VEC2 = 0x8B53;

  static const int INT_VEC3 = 0x8B54;

  static const int INT_VEC4 = 0x8B55;

  static const int INVALID_ENUM = 0x0500;

  static const int INVALID_FRAMEBUFFER_OPERATION = 0x0506;

  static const int INVALID_OPERATION = 0x0502;

  static const int INVALID_VALUE = 0x0501;

  static const int INVERT = 0x150A;

  static const int KEEP = 0x1E00;

  static const int LEQUAL = 0x0203;

  static const int LESS = 0x0201;

  static const int LINEAR = 0x2601;

  static const int LINEAR_MIPMAP_LINEAR = 0x2703;

  static const int LINEAR_MIPMAP_NEAREST = 0x2701;

  static const int LINES = 0x0001;

  static const int LINE_LOOP = 0x0002;

  static const int LINE_STRIP = 0x0003;

  static const int LINE_WIDTH = 0x0B21;

  static const int LINK_STATUS = 0x8B82;

  static const int LOW_FLOAT = 0x8DF0;

  static const int LOW_INT = 0x8DF3;

  static const int LUMINANCE = 0x1909;

  static const int LUMINANCE_ALPHA = 0x190A;

  static const int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;

  static const int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

  static const int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

  static const int MAX_RENDERBUFFER_SIZE = 0x84E8;

  static const int MAX_TEXTURE_IMAGE_UNITS = 0x8872;

  static const int MAX_TEXTURE_SIZE = 0x0D33;

  static const int MAX_VARYING_VECTORS = 0x8DFC;

  static const int MAX_VERTEX_ATTRIBS = 0x8869;

  static const int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;

  static const int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;

  static const int MAX_VIEWPORT_DIMS = 0x0D3A;

  static const int MEDIUM_FLOAT = 0x8DF1;

  static const int MEDIUM_INT = 0x8DF4;

  static const int MIRRORED_REPEAT = 0x8370;

  static const int NEAREST = 0x2600;

  static const int NEAREST_MIPMAP_LINEAR = 0x2702;

  static const int NEAREST_MIPMAP_NEAREST = 0x2700;

  static const int NEVER = 0x0200;

  static const int NICEST = 0x1102;

  static const int NONE = 0;

  static const int NOTEQUAL = 0x0205;

  static const int NO_ERROR = 0;

  static const int ONE = 1;

  static const int ONE_MINUS_CONSTANT_ALPHA = 0x8004;

  static const int ONE_MINUS_CONSTANT_COLOR = 0x8002;

  static const int ONE_MINUS_DST_ALPHA = 0x0305;

  static const int ONE_MINUS_DST_COLOR = 0x0307;

  static const int ONE_MINUS_SRC_ALPHA = 0x0303;

  static const int ONE_MINUS_SRC_COLOR = 0x0301;

  static const int OUT_OF_MEMORY = 0x0505;

  static const int PACK_ALIGNMENT = 0x0D05;

  static const int POINTS = 0x0000;

  static const int POLYGON_OFFSET_FACTOR = 0x8038;

  static const int POLYGON_OFFSET_FILL = 0x8037;

  static const int POLYGON_OFFSET_UNITS = 0x2A00;

  static const int RED_BITS = 0x0D52;

  static const int RENDERBUFFER = 0x8D41;

  static const int RENDERBUFFER_ALPHA_SIZE = 0x8D53;

  static const int RENDERBUFFER_BINDING = 0x8CA7;

  static const int RENDERBUFFER_BLUE_SIZE = 0x8D52;

  static const int RENDERBUFFER_DEPTH_SIZE = 0x8D54;

  static const int RENDERBUFFER_GREEN_SIZE = 0x8D51;

  static const int RENDERBUFFER_HEIGHT = 0x8D43;

  static const int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;

  static const int RENDERBUFFER_RED_SIZE = 0x8D50;

  static const int RENDERBUFFER_STENCIL_SIZE = 0x8D55;

  static const int RENDERBUFFER_WIDTH = 0x8D42;

  static const int RENDERER = 0x1F01;

  static const int REPEAT = 0x2901;

  static const int REPLACE = 0x1E01;

  static const int RGB = 0x1907;

  static const int RGB565 = 0x8D62;

  static const int RGB5_A1 = 0x8057;

  static const int RGBA = 0x1908;

  static const int RGBA4 = 0x8056;

  static const int SAMPLER_2D = 0x8B5E;

  static const int SAMPLER_CUBE = 0x8B60;

  static const int SAMPLES = 0x80A9;

  static const int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;

  static const int SAMPLE_BUFFERS = 0x80A8;

  static const int SAMPLE_COVERAGE = 0x80A0;

  static const int SAMPLE_COVERAGE_INVERT = 0x80AB;

  static const int SAMPLE_COVERAGE_VALUE = 0x80AA;

  static const int SCISSOR_BOX = 0x0C10;

  static const int SCISSOR_TEST = 0x0C11;

  static const int SHADER_TYPE = 0x8B4F;

  static const int SHADING_LANGUAGE_VERSION = 0x8B8C;

  static const int SHORT = 0x1402;

  static const int SRC_ALPHA = 0x0302;

  static const int SRC_ALPHA_SATURATE = 0x0308;

  static const int SRC_COLOR = 0x0300;

  static const int STATIC_DRAW = 0x88E4;

  static const int STENCIL_ATTACHMENT = 0x8D20;

  static const int STENCIL_BACK_FAIL = 0x8801;

  static const int STENCIL_BACK_FUNC = 0x8800;

  static const int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;

  static const int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;

  static const int STENCIL_BACK_REF = 0x8CA3;

  static const int STENCIL_BACK_VALUE_MASK = 0x8CA4;

  static const int STENCIL_BACK_WRITEMASK = 0x8CA5;

  static const int STENCIL_BITS = 0x0D57;

  static const int STENCIL_BUFFER_BIT = 0x00000400;

  static const int STENCIL_CLEAR_VALUE = 0x0B91;

  static const int STENCIL_FAIL = 0x0B94;

  static const int STENCIL_FUNC = 0x0B92;

  static const int STENCIL_INDEX = 0x1901;

  static const int STENCIL_INDEX8 = 0x8D48;

  static const int STENCIL_PASS_DEPTH_FAIL = 0x0B95;

  static const int STENCIL_PASS_DEPTH_PASS = 0x0B96;

  static const int STENCIL_REF = 0x0B97;

  static const int STENCIL_TEST = 0x0B90;

  static const int STENCIL_VALUE_MASK = 0x0B93;

  static const int STENCIL_WRITEMASK = 0x0B98;

  static const int STREAM_DRAW = 0x88E0;

  static const int SUBPIXEL_BITS = 0x0D50;

  static const int TEXTURE = 0x1702;

  static const int TEXTURE0 = 0x84C0;

  static const int TEXTURE1 = 0x84C1;

  static const int TEXTURE10 = 0x84CA;

  static const int TEXTURE11 = 0x84CB;

  static const int TEXTURE12 = 0x84CC;

  static const int TEXTURE13 = 0x84CD;

  static const int TEXTURE14 = 0x84CE;

  static const int TEXTURE15 = 0x84CF;

  static const int TEXTURE16 = 0x84D0;

  static const int TEXTURE17 = 0x84D1;

  static const int TEXTURE18 = 0x84D2;

  static const int TEXTURE19 = 0x84D3;

  static const int TEXTURE2 = 0x84C2;

  static const int TEXTURE20 = 0x84D4;

  static const int TEXTURE21 = 0x84D5;

  static const int TEXTURE22 = 0x84D6;

  static const int TEXTURE23 = 0x84D7;

  static const int TEXTURE24 = 0x84D8;

  static const int TEXTURE25 = 0x84D9;

  static const int TEXTURE26 = 0x84DA;

  static const int TEXTURE27 = 0x84DB;

  static const int TEXTURE28 = 0x84DC;

  static const int TEXTURE29 = 0x84DD;

  static const int TEXTURE3 = 0x84C3;

  static const int TEXTURE30 = 0x84DE;

  static const int TEXTURE31 = 0x84DF;

  static const int TEXTURE4 = 0x84C4;

  static const int TEXTURE5 = 0x84C5;

  static const int TEXTURE6 = 0x84C6;

  static const int TEXTURE7 = 0x84C7;

  static const int TEXTURE8 = 0x84C8;

  static const int TEXTURE9 = 0x84C9;

  static const int TEXTURE_2D = 0x0DE1;

  static const int TEXTURE_BINDING_2D = 0x8069;

  static const int TEXTURE_BINDING_CUBE_MAP = 0x8514;

  static const int TEXTURE_CUBE_MAP = 0x8513;

  static const int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;

  static const int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;

  static const int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;

  static const int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  static const int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;

  static const int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;

  static const int TEXTURE_MAG_FILTER = 0x2800;

  static const int TEXTURE_MIN_FILTER = 0x2801;

  static const int TEXTURE_WRAP_S = 0x2802;

  static const int TEXTURE_WRAP_T = 0x2803;

  static const int TRIANGLES = 0x0004;

  static const int TRIANGLE_FAN = 0x0006;

  static const int TRIANGLE_STRIP = 0x0005;

  static const int UNPACK_ALIGNMENT = 0x0CF5;

  static const int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  static const int UNPACK_FLIP_Y_WEBGL = 0x9240;

  static const int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;

  static const int UNSIGNED_BYTE = 0x1401;

  static const int UNSIGNED_INT = 0x1405;

  static const int UNSIGNED_SHORT = 0x1403;

  static const int UNSIGNED_SHORT_4_4_4_4 = 0x8033;

  static const int UNSIGNED_SHORT_5_5_5_1 = 0x8034;

  static const int UNSIGNED_SHORT_5_6_5 = 0x8363;

  static const int VALIDATE_STATUS = 0x8B83;

  static const int VENDOR = 0x1F00;

  static const int VERSION = 0x1F02;

  static const int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

  static const int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;

  static const int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;

  static const int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;

  static const int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;

  static const int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;

  static const int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;

  static const int VERTEX_SHADER = 0x8B31;

  static const int VIEWPORT = 0x0BA2;

  static const int ZERO = 0;

  /** @domName WebGLRenderingContext.drawingBufferHeight */
  int get drawingBufferHeight;

  /** @domName WebGLRenderingContext.drawingBufferWidth */
  int get drawingBufferWidth;

  /** @domName WebGLRenderingContext.activeTexture */
  void activeTexture(int texture);

  /** @domName WebGLRenderingContext.attachShader */
  void attachShader(WebGLProgram program, WebGLShader shader);

  /** @domName WebGLRenderingContext.bindAttribLocation */
  void bindAttribLocation(WebGLProgram program, int index, String name);

  /** @domName WebGLRenderingContext.bindBuffer */
  void bindBuffer(int target, WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.bindFramebuffer */
  void bindFramebuffer(int target, WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.bindRenderbuffer */
  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.bindTexture */
  void bindTexture(int target, WebGLTexture texture);

  /** @domName WebGLRenderingContext.blendColor */
  void blendColor(num red, num green, num blue, num alpha);

  /** @domName WebGLRenderingContext.blendEquation */
  void blendEquation(int mode);

  /** @domName WebGLRenderingContext.blendEquationSeparate */
  void blendEquationSeparate(int modeRGB, int modeAlpha);

  /** @domName WebGLRenderingContext.blendFunc */
  void blendFunc(int sfactor, int dfactor);

  /** @domName WebGLRenderingContext.blendFuncSeparate */
  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha);

  /** @domName WebGLRenderingContext.bufferData */
  void bufferData(int target, data_OR_size, int usage);

  /** @domName WebGLRenderingContext.bufferSubData */
  void bufferSubData(int target, int offset, data);

  /** @domName WebGLRenderingContext.checkFramebufferStatus */
  int checkFramebufferStatus(int target);

  /** @domName WebGLRenderingContext.clear */
  void clear(int mask);

  /** @domName WebGLRenderingContext.clearColor */
  void clearColor(num red, num green, num blue, num alpha);

  /** @domName WebGLRenderingContext.clearDepth */
  void clearDepth(num depth);

  /** @domName WebGLRenderingContext.clearStencil */
  void clearStencil(int s);

  /** @domName WebGLRenderingContext.colorMask */
  void colorMask(bool red, bool green, bool blue, bool alpha);

  /** @domName WebGLRenderingContext.compileShader */
  void compileShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.compressedTexImage2D */
  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data);

  /** @domName WebGLRenderingContext.compressedTexSubImage2D */
  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data);

  /** @domName WebGLRenderingContext.copyTexImage2D */
  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border);

  /** @domName WebGLRenderingContext.copyTexSubImage2D */
  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height);

  /** @domName WebGLRenderingContext.createBuffer */
  WebGLBuffer createBuffer();

  /** @domName WebGLRenderingContext.createFramebuffer */
  WebGLFramebuffer createFramebuffer();

  /** @domName WebGLRenderingContext.createProgram */
  WebGLProgram createProgram();

  /** @domName WebGLRenderingContext.createRenderbuffer */
  WebGLRenderbuffer createRenderbuffer();

  /** @domName WebGLRenderingContext.createShader */
  WebGLShader createShader(int type);

  /** @domName WebGLRenderingContext.createTexture */
  WebGLTexture createTexture();

  /** @domName WebGLRenderingContext.cullFace */
  void cullFace(int mode);

  /** @domName WebGLRenderingContext.deleteBuffer */
  void deleteBuffer(WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.deleteFramebuffer */
  void deleteFramebuffer(WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.deleteProgram */
  void deleteProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.deleteRenderbuffer */
  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.deleteShader */
  void deleteShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.deleteTexture */
  void deleteTexture(WebGLTexture texture);

  /** @domName WebGLRenderingContext.depthFunc */
  void depthFunc(int func);

  /** @domName WebGLRenderingContext.depthMask */
  void depthMask(bool flag);

  /** @domName WebGLRenderingContext.depthRange */
  void depthRange(num zNear, num zFar);

  /** @domName WebGLRenderingContext.detachShader */
  void detachShader(WebGLProgram program, WebGLShader shader);

  /** @domName WebGLRenderingContext.disable */
  void disable(int cap);

  /** @domName WebGLRenderingContext.disableVertexAttribArray */
  void disableVertexAttribArray(int index);

  /** @domName WebGLRenderingContext.drawArrays */
  void drawArrays(int mode, int first, int count);

  /** @domName WebGLRenderingContext.drawElements */
  void drawElements(int mode, int count, int type, int offset);

  /** @domName WebGLRenderingContext.enable */
  void enable(int cap);

  /** @domName WebGLRenderingContext.enableVertexAttribArray */
  void enableVertexAttribArray(int index);

  /** @domName WebGLRenderingContext.finish */
  void finish();

  /** @domName WebGLRenderingContext.flush */
  void flush();

  /** @domName WebGLRenderingContext.framebufferRenderbuffer */
  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.framebufferTexture2D */
  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level);

  /** @domName WebGLRenderingContext.frontFace */
  void frontFace(int mode);

  /** @domName WebGLRenderingContext.generateMipmap */
  void generateMipmap(int target);

  /** @domName WebGLRenderingContext.getActiveAttrib */
  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index);

  /** @domName WebGLRenderingContext.getActiveUniform */
  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index);

  /** @domName WebGLRenderingContext.getAttachedShaders */
  void getAttachedShaders(WebGLProgram program);

  /** @domName WebGLRenderingContext.getAttribLocation */
  int getAttribLocation(WebGLProgram program, String name);

  /** @domName WebGLRenderingContext.getBufferParameter */
  Object getBufferParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getContextAttributes */
  WebGLContextAttributes getContextAttributes();

  /** @domName WebGLRenderingContext.getError */
  int getError();

  /** @domName WebGLRenderingContext.getExtension */
  Object getExtension(String name);

  /** @domName WebGLRenderingContext.getFramebufferAttachmentParameter */
  Object getFramebufferAttachmentParameter(int target, int attachment, int pname);

  /** @domName WebGLRenderingContext.getParameter */
  Object getParameter(int pname);

  /** @domName WebGLRenderingContext.getProgramInfoLog */
  String getProgramInfoLog(WebGLProgram program);

  /** @domName WebGLRenderingContext.getProgramParameter */
  Object getProgramParameter(WebGLProgram program, int pname);

  /** @domName WebGLRenderingContext.getRenderbufferParameter */
  Object getRenderbufferParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getShaderInfoLog */
  String getShaderInfoLog(WebGLShader shader);

  /** @domName WebGLRenderingContext.getShaderParameter */
  Object getShaderParameter(WebGLShader shader, int pname);

  /** @domName WebGLRenderingContext.getShaderPrecisionFormat */
  WebGLShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype);

  /** @domName WebGLRenderingContext.getShaderSource */
  String getShaderSource(WebGLShader shader);

  /** @domName WebGLRenderingContext.getSupportedExtensions */
  List<String> getSupportedExtensions();

  /** @domName WebGLRenderingContext.getTexParameter */
  Object getTexParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getUniform */
  Object getUniform(WebGLProgram program, WebGLUniformLocation location);

  /** @domName WebGLRenderingContext.getUniformLocation */
  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name);

  /** @domName WebGLRenderingContext.getVertexAttrib */
  Object getVertexAttrib(int index, int pname);

  /** @domName WebGLRenderingContext.getVertexAttribOffset */
  int getVertexAttribOffset(int index, int pname);

  /** @domName WebGLRenderingContext.hint */
  void hint(int target, int mode);

  /** @domName WebGLRenderingContext.isBuffer */
  bool isBuffer(WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.isContextLost */
  bool isContextLost();

  /** @domName WebGLRenderingContext.isEnabled */
  bool isEnabled(int cap);

  /** @domName WebGLRenderingContext.isFramebuffer */
  bool isFramebuffer(WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.isProgram */
  bool isProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.isRenderbuffer */
  bool isRenderbuffer(WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.isShader */
  bool isShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.isTexture */
  bool isTexture(WebGLTexture texture);

  /** @domName WebGLRenderingContext.lineWidth */
  void lineWidth(num width);

  /** @domName WebGLRenderingContext.linkProgram */
  void linkProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.pixelStorei */
  void pixelStorei(int pname, int param);

  /** @domName WebGLRenderingContext.polygonOffset */
  void polygonOffset(num factor, num units);

  /** @domName WebGLRenderingContext.readPixels */
  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels);

  /** @domName WebGLRenderingContext.releaseShaderCompiler */
  void releaseShaderCompiler();

  /** @domName WebGLRenderingContext.renderbufferStorage */
  void renderbufferStorage(int target, int internalformat, int width, int height);

  /** @domName WebGLRenderingContext.sampleCoverage */
  void sampleCoverage(num value, bool invert);

  /** @domName WebGLRenderingContext.scissor */
  void scissor(int x, int y, int width, int height);

  /** @domName WebGLRenderingContext.shaderSource */
  void shaderSource(WebGLShader shader, String string);

  /** @domName WebGLRenderingContext.stencilFunc */
  void stencilFunc(int func, int ref, int mask);

  /** @domName WebGLRenderingContext.stencilFuncSeparate */
  void stencilFuncSeparate(int face, int func, int ref, int mask);

  /** @domName WebGLRenderingContext.stencilMask */
  void stencilMask(int mask);

  /** @domName WebGLRenderingContext.stencilMaskSeparate */
  void stencilMaskSeparate(int face, int mask);

  /** @domName WebGLRenderingContext.stencilOp */
  void stencilOp(int fail, int zfail, int zpass);

  /** @domName WebGLRenderingContext.stencilOpSeparate */
  void stencilOpSeparate(int face, int fail, int zfail, int zpass);

  /** @domName WebGLRenderingContext.texImage2D */
  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format, int type, ArrayBufferView pixels]);

  /** @domName WebGLRenderingContext.texParameterf */
  void texParameterf(int target, int pname, num param);

  /** @domName WebGLRenderingContext.texParameteri */
  void texParameteri(int target, int pname, int param);

  /** @domName WebGLRenderingContext.texSubImage2D */
  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type, ArrayBufferView pixels]);

  /** @domName WebGLRenderingContext.uniform1f */
  void uniform1f(WebGLUniformLocation location, num x);

  /** @domName WebGLRenderingContext.uniform1fv */
  void uniform1fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform1i */
  void uniform1i(WebGLUniformLocation location, int x);

  /** @domName WebGLRenderingContext.uniform1iv */
  void uniform1iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform2f */
  void uniform2f(WebGLUniformLocation location, num x, num y);

  /** @domName WebGLRenderingContext.uniform2fv */
  void uniform2fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform2i */
  void uniform2i(WebGLUniformLocation location, int x, int y);

  /** @domName WebGLRenderingContext.uniform2iv */
  void uniform2iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform3f */
  void uniform3f(WebGLUniformLocation location, num x, num y, num z);

  /** @domName WebGLRenderingContext.uniform3fv */
  void uniform3fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform3i */
  void uniform3i(WebGLUniformLocation location, int x, int y, int z);

  /** @domName WebGLRenderingContext.uniform3iv */
  void uniform3iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform4f */
  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w);

  /** @domName WebGLRenderingContext.uniform4fv */
  void uniform4fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform4i */
  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w);

  /** @domName WebGLRenderingContext.uniform4iv */
  void uniform4iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniformMatrix2fv */
  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.uniformMatrix3fv */
  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.uniformMatrix4fv */
  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.useProgram */
  void useProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.validateProgram */
  void validateProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.vertexAttrib1f */
  void vertexAttrib1f(int indx, num x);

  /** @domName WebGLRenderingContext.vertexAttrib1fv */
  void vertexAttrib1fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib2f */
  void vertexAttrib2f(int indx, num x, num y);

  /** @domName WebGLRenderingContext.vertexAttrib2fv */
  void vertexAttrib2fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib3f */
  void vertexAttrib3f(int indx, num x, num y, num z);

  /** @domName WebGLRenderingContext.vertexAttrib3fv */
  void vertexAttrib3fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib4f */
  void vertexAttrib4f(int indx, num x, num y, num z, num w);

  /** @domName WebGLRenderingContext.vertexAttrib4fv */
  void vertexAttrib4fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttribPointer */
  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset);

  /** @domName WebGLRenderingContext.viewport */
  void viewport(int x, int y, int width, int height);
}

class _WebGLRenderingContextImpl extends _CanvasRenderingContextImpl implements WebGLRenderingContext native "*WebGLRenderingContext" {

  final int drawingBufferHeight;

  final int drawingBufferWidth;

  void activeTexture(int texture) native;

  void attachShader(_WebGLProgramImpl program, _WebGLShaderImpl shader) native;

  void bindAttribLocation(_WebGLProgramImpl program, int index, String name) native;

  void bindBuffer(int target, _WebGLBufferImpl buffer) native;

  void bindFramebuffer(int target, _WebGLFramebufferImpl framebuffer) native;

  void bindRenderbuffer(int target, _WebGLRenderbufferImpl renderbuffer) native;

  void bindTexture(int target, _WebGLTextureImpl texture) native;

  void blendColor(num red, num green, num blue, num alpha) native;

  void blendEquation(int mode) native;

  void blendEquationSeparate(int modeRGB, int modeAlpha) native;

  void blendFunc(int sfactor, int dfactor) native;

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) native;

  void bufferData(int target, data_OR_size, int usage) native;

  void bufferSubData(int target, int offset, data) native;

  int checkFramebufferStatus(int target) native;

  void clear(int mask) native;

  void clearColor(num red, num green, num blue, num alpha) native;

  void clearDepth(num depth) native;

  void clearStencil(int s) native;

  void colorMask(bool red, bool green, bool blue, bool alpha) native;

  void compileShader(_WebGLShaderImpl shader) native;

  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, _ArrayBufferViewImpl data) native;

  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, _ArrayBufferViewImpl data) native;

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) native;

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) native;

  _WebGLBufferImpl createBuffer() native;

  _WebGLFramebufferImpl createFramebuffer() native;

  _WebGLProgramImpl createProgram() native;

  _WebGLRenderbufferImpl createRenderbuffer() native;

  _WebGLShaderImpl createShader(int type) native;

  _WebGLTextureImpl createTexture() native;

  void cullFace(int mode) native;

  void deleteBuffer(_WebGLBufferImpl buffer) native;

  void deleteFramebuffer(_WebGLFramebufferImpl framebuffer) native;

  void deleteProgram(_WebGLProgramImpl program) native;

  void deleteRenderbuffer(_WebGLRenderbufferImpl renderbuffer) native;

  void deleteShader(_WebGLShaderImpl shader) native;

  void deleteTexture(_WebGLTextureImpl texture) native;

  void depthFunc(int func) native;

  void depthMask(bool flag) native;

  void depthRange(num zNear, num zFar) native;

  void detachShader(_WebGLProgramImpl program, _WebGLShaderImpl shader) native;

  void disable(int cap) native;

  void disableVertexAttribArray(int index) native;

  void drawArrays(int mode, int first, int count) native;

  void drawElements(int mode, int count, int type, int offset) native;

  void enable(int cap) native;

  void enableVertexAttribArray(int index) native;

  void finish() native;

  void flush() native;

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, _WebGLRenderbufferImpl renderbuffer) native;

  void framebufferTexture2D(int target, int attachment, int textarget, _WebGLTextureImpl texture, int level) native;

  void frontFace(int mode) native;

  void generateMipmap(int target) native;

  _WebGLActiveInfoImpl getActiveAttrib(_WebGLProgramImpl program, int index) native;

  _WebGLActiveInfoImpl getActiveUniform(_WebGLProgramImpl program, int index) native;

  void getAttachedShaders(_WebGLProgramImpl program) native;

  int getAttribLocation(_WebGLProgramImpl program, String name) native;

  Object getBufferParameter(int target, int pname) native;

  _WebGLContextAttributesImpl getContextAttributes() native;

  int getError() native;

  Object getExtension(String name) native;

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) native;

  Object getParameter(int pname) native;

  String getProgramInfoLog(_WebGLProgramImpl program) native;

  Object getProgramParameter(_WebGLProgramImpl program, int pname) native;

  Object getRenderbufferParameter(int target, int pname) native;

  String getShaderInfoLog(_WebGLShaderImpl shader) native;

  Object getShaderParameter(_WebGLShaderImpl shader, int pname) native;

  _WebGLShaderPrecisionFormatImpl getShaderPrecisionFormat(int shadertype, int precisiontype) native;

  String getShaderSource(_WebGLShaderImpl shader) native;

  List<String> getSupportedExtensions() native;

  Object getTexParameter(int target, int pname) native;

  Object getUniform(_WebGLProgramImpl program, _WebGLUniformLocationImpl location) native;

  _WebGLUniformLocationImpl getUniformLocation(_WebGLProgramImpl program, String name) native;

  Object getVertexAttrib(int index, int pname) native;

  int getVertexAttribOffset(int index, int pname) native;

  void hint(int target, int mode) native;

  bool isBuffer(_WebGLBufferImpl buffer) native;

  bool isContextLost() native;

  bool isEnabled(int cap) native;

  bool isFramebuffer(_WebGLFramebufferImpl framebuffer) native;

  bool isProgram(_WebGLProgramImpl program) native;

  bool isRenderbuffer(_WebGLRenderbufferImpl renderbuffer) native;

  bool isShader(_WebGLShaderImpl shader) native;

  bool isTexture(_WebGLTextureImpl texture) native;

  void lineWidth(num width) native;

  void linkProgram(_WebGLProgramImpl program) native;

  void pixelStorei(int pname, int param) native;

  void polygonOffset(num factor, num units) native;

  void readPixels(int x, int y, int width, int height, int format, int type, _ArrayBufferViewImpl pixels) native;

  void releaseShaderCompiler() native;

  void renderbufferStorage(int target, int internalformat, int width, int height) native;

  void sampleCoverage(num value, bool invert) native;

  void scissor(int x, int y, int width, int height) native;

  void shaderSource(_WebGLShaderImpl shader, String string) native;

  void stencilFunc(int func, int ref, int mask) native;

  void stencilFuncSeparate(int face, int func, int ref, int mask) native;

  void stencilMask(int mask) native;

  void stencilMaskSeparate(int face, int mask) native;

  void stencilOp(int fail, int zfail, int zpass) native;

  void stencilOpSeparate(int face, int fail, int zfail, int zpass) native;

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [format, type, pixels]) {
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is int || border_OR_canvas_OR_image_OR_pixels_OR_video == null) &&
        (format is int || format == null) &&
        (type is int || type == null) &&
        (pixels is ArrayBufferView || pixels == null)) {
      _texImage2D_1(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is ImageData || border_OR_canvas_OR_image_OR_pixels_OR_video == null) &&
        !?format &&
        !?type &&
        !?pixels) {
      var pixels_1 = _convertDartToNative_ImageData(border_OR_canvas_OR_image_OR_pixels_OR_video);
      _texImage2D_2(target, level, internalformat, format_OR_width, height_OR_type, pixels_1);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is ImageElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) &&
        !?format &&
        !?type &&
        !?pixels) {
      _texImage2D_3(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is CanvasElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) &&
        !?format &&
        !?type &&
        !?pixels) {
      _texImage2D_4(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is VideoElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) &&
        !?format &&
        !?type &&
        !?pixels) {
      _texImage2D_5(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  void _texImage2D_1(target, level, internalformat, width, height, int border, int format, int type, _ArrayBufferViewImpl pixels) native "texImage2D";
  void _texImage2D_2(target, level, internalformat, format, type, pixels) native "texImage2D";
  void _texImage2D_3(target, level, internalformat, format, type, _ImageElementImpl image) native "texImage2D";
  void _texImage2D_4(target, level, internalformat, format, type, _CanvasElementImpl canvas) native "texImage2D";
  void _texImage2D_5(target, level, internalformat, format, type, _VideoElementImpl video) native "texImage2D";

  void texParameterf(int target, int pname, num param) native;

  void texParameteri(int target, int pname, int param) native;

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [type, pixels]) {
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is int || canvas_OR_format_OR_image_OR_pixels_OR_video == null) &&
        (type is int || type == null) &&
        (pixels is ArrayBufferView || pixels == null)) {
      _texSubImage2D_1(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is ImageData || canvas_OR_format_OR_image_OR_pixels_OR_video == null) &&
        !?type &&
        !?pixels) {
      var pixels_1 = _convertDartToNative_ImageData(canvas_OR_format_OR_image_OR_pixels_OR_video);
      _texSubImage2D_2(target, level, xoffset, yoffset, format_OR_width, height_OR_type, pixels_1);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is ImageElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) &&
        !?type &&
        !?pixels) {
      _texSubImage2D_3(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is CanvasElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) &&
        !?type &&
        !?pixels) {
      _texSubImage2D_4(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is VideoElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) &&
        !?type &&
        !?pixels) {
      _texSubImage2D_5(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    throw const Exception("Incorrect number or type of arguments");
  }
  void _texSubImage2D_1(target, level, xoffset, yoffset, width, height, int format, int type, _ArrayBufferViewImpl pixels) native "texSubImage2D";
  void _texSubImage2D_2(target, level, xoffset, yoffset, format, type, pixels) native "texSubImage2D";
  void _texSubImage2D_3(target, level, xoffset, yoffset, format, type, _ImageElementImpl image) native "texSubImage2D";
  void _texSubImage2D_4(target, level, xoffset, yoffset, format, type, _CanvasElementImpl canvas) native "texSubImage2D";
  void _texSubImage2D_5(target, level, xoffset, yoffset, format, type, _VideoElementImpl video) native "texSubImage2D";

  void uniform1f(_WebGLUniformLocationImpl location, num x) native;

  void uniform1fv(_WebGLUniformLocationImpl location, _Float32ArrayImpl v) native;

  void uniform1i(_WebGLUniformLocationImpl location, int x) native;

  void uniform1iv(_WebGLUniformLocationImpl location, _Int32ArrayImpl v) native;

  void uniform2f(_WebGLUniformLocationImpl location, num x, num y) native;

  void uniform2fv(_WebGLUniformLocationImpl location, _Float32ArrayImpl v) native;

  void uniform2i(_WebGLUniformLocationImpl location, int x, int y) native;

  void uniform2iv(_WebGLUniformLocationImpl location, _Int32ArrayImpl v) native;

  void uniform3f(_WebGLUniformLocationImpl location, num x, num y, num z) native;

  void uniform3fv(_WebGLUniformLocationImpl location, _Float32ArrayImpl v) native;

  void uniform3i(_WebGLUniformLocationImpl location, int x, int y, int z) native;

  void uniform3iv(_WebGLUniformLocationImpl location, _Int32ArrayImpl v) native;

  void uniform4f(_WebGLUniformLocationImpl location, num x, num y, num z, num w) native;

  void uniform4fv(_WebGLUniformLocationImpl location, _Float32ArrayImpl v) native;

  void uniform4i(_WebGLUniformLocationImpl location, int x, int y, int z, int w) native;

  void uniform4iv(_WebGLUniformLocationImpl location, _Int32ArrayImpl v) native;

  void uniformMatrix2fv(_WebGLUniformLocationImpl location, bool transpose, _Float32ArrayImpl array) native;

  void uniformMatrix3fv(_WebGLUniformLocationImpl location, bool transpose, _Float32ArrayImpl array) native;

  void uniformMatrix4fv(_WebGLUniformLocationImpl location, bool transpose, _Float32ArrayImpl array) native;

  void useProgram(_WebGLProgramImpl program) native;

  void validateProgram(_WebGLProgramImpl program) native;

  void vertexAttrib1f(int indx, num x) native;

  void vertexAttrib1fv(int indx, _Float32ArrayImpl values) native;

  void vertexAttrib2f(int indx, num x, num y) native;

  void vertexAttrib2fv(int indx, _Float32ArrayImpl values) native;

  void vertexAttrib3f(int indx, num x, num y, num z) native;

  void vertexAttrib3fv(int indx, _Float32ArrayImpl values) native;

  void vertexAttrib4f(int indx, num x, num y, num z, num w) native;

  void vertexAttrib4fv(int indx, _Float32ArrayImpl values) native;

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) native;

  void viewport(int x, int y, int width, int height) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLShader
abstract class WebGLShader {
}

class _WebGLShaderImpl implements WebGLShader native "*WebGLShader" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLShaderPrecisionFormat
abstract class WebGLShaderPrecisionFormat {

  /** @domName WebGLShaderPrecisionFormat.precision */
  int get precision;

  /** @domName WebGLShaderPrecisionFormat.rangeMax */
  int get rangeMax;

  /** @domName WebGLShaderPrecisionFormat.rangeMin */
  int get rangeMin;
}

class _WebGLShaderPrecisionFormatImpl implements WebGLShaderPrecisionFormat native "*WebGLShaderPrecisionFormat" {

  final int precision;

  final int rangeMax;

  final int rangeMin;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLTexture
abstract class WebGLTexture {
}

class _WebGLTextureImpl implements WebGLTexture native "*WebGLTexture" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLUniformLocation
abstract class WebGLUniformLocation {
}

class _WebGLUniformLocationImpl implements WebGLUniformLocation native "*WebGLUniformLocation" {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLVertexArrayObjectOES
abstract class WebGLVertexArrayObjectOES {
}

class _WebGLVertexArrayObjectOESImpl implements WebGLVertexArrayObjectOES native "*WebGLVertexArrayObjectOES" {
}

class _WebKitAnimationListImpl implements List<Animation>, JavaScriptIndexingBehavior native "*WebKitAnimationList" {

  final int length;

  _AnimationImpl operator[](int index) => JS("_AnimationImpl", "#[#]", this, index);

  void operator[]=(int index, _AnimationImpl value) {
    throw new UnsupportedError("Cannot assign element of immutable List.");
  }
  // -- start List<Animation> mixins.
  // Animation is the element type.

  // From Iterable<Animation>:

  Iterator<Animation> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Animation>(this);
  }

  // From Collection<Animation>:

  void add(Animation value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast(Animation value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<Animation> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  bool contains(Animation element) => _Collections.contains(this, element);

  void forEach(void f(Animation element)) => _Collections.forEach(this, f);

  Collection map(f(Animation element)) => _Collections.map(this, [], f);

  Collection<Animation> filter(bool f(Animation element)) =>
     _Collections.filter(this, <Animation>[], f);

  bool every(bool f(Animation element)) => _Collections.every(this, f);

  bool some(bool f(Animation element)) => _Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<Animation>:

  void sort([Comparator<Animation> compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf(Animation element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Animation element, [int start]) {
    if (start == null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Animation get last => this[length - 1];

  Animation removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<Animation> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Animation initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<Animation> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Animation>[]);

  // -- end List<Animation> mixins.

  _AnimationImpl item(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSFilterValue
abstract class WebKitCSSFilterValue implements List<CSSValue> {

  static const int CSS_FILTER_BLUR = 10;

  static const int CSS_FILTER_BRIGHTNESS = 8;

  static const int CSS_FILTER_CONTRAST = 9;

  static const int CSS_FILTER_CUSTOM = 12;

  static const int CSS_FILTER_DROP_SHADOW = 11;

  static const int CSS_FILTER_GRAYSCALE = 2;

  static const int CSS_FILTER_HUE_ROTATE = 5;

  static const int CSS_FILTER_INVERT = 6;

  static const int CSS_FILTER_OPACITY = 7;

  static const int CSS_FILTER_REFERENCE = 1;

  static const int CSS_FILTER_SATURATE = 4;

  static const int CSS_FILTER_SEPIA = 3;

  /** @domName WebKitCSSFilterValue.operationType */
  int get operationType;
}

class _WebKitCSSFilterValueImpl extends _CSSValueListImpl implements WebKitCSSFilterValue native "*WebKitCSSFilterValue" {

  final int operationType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitNamedFlow
abstract class WebKitNamedFlow implements EventTarget {

  /** @domName WebKitNamedFlow.firstEmptyRegionIndex */
  int get firstEmptyRegionIndex;

  /** @domName WebKitNamedFlow.name */
  String get name;

  /** @domName WebKitNamedFlow.overset */
  bool get overset;

  /** @domName WebKitNamedFlow.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WebKitNamedFlow.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName WebKitNamedFlow.getContent */
  List<Node> getContent();

  /** @domName WebKitNamedFlow.getRegions */
  List<Node> getRegions();

  /** @domName WebKitNamedFlow.getRegionsByContent */
  List<Node> getRegionsByContent(Node contentNode);

  /** @domName WebKitNamedFlow.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

class _WebKitNamedFlowImpl extends _EventTargetImpl implements WebKitNamedFlow native "*WebKitNamedFlow" {

  final int firstEmptyRegionIndex;

  final String name;

  final bool overset;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  bool $dom_dispatchEvent(_EventImpl event) native "dispatchEvent";

  List<Node> getContent() native;

  List<Node> getRegions() native;

  List<Node> getRegionsByContent(_NodeImpl contentNode) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.


/// @domName WebSocket
abstract class WebSocket implements EventTarget {

  factory WebSocket(String url) => _WebSocketFactoryProvider.createWebSocket(url);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WebSocketEvents get on;

  static const int CLOSED = 3;

  static const int CLOSING = 2;

  static const int CONNECTING = 0;

  static const int OPEN = 1;

  /** @domName WebSocket.URL */
  String get URL;

  /** @domName WebSocket.binaryType */
  String binaryType;

  /** @domName WebSocket.bufferedAmount */
  int get bufferedAmount;

  /** @domName WebSocket.extensions */
  String get extensions;

  /** @domName WebSocket.protocol */
  String get protocol;

  /** @domName WebSocket.readyState */
  int get readyState;

  /** @domName WebSocket.url */
  String get url;

  /** @domName WebSocket.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WebSocket.close */
  void close([int code, String reason]);

  /** @domName WebSocket.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName WebSocket.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WebSocket.send */
  void send(data);
}

abstract class WebSocketEvents implements Events {

  EventListenerList get close;

  EventListenerList get error;

  EventListenerList get message;

  EventListenerList get open;
}

class _WebSocketImpl extends _EventTargetImpl implements WebSocket native "*WebSocket" {

  _WebSocketEventsImpl get on =>
    new _WebSocketEventsImpl(this);

  final String URL;

  String binaryType;

  final int bufferedAmount;

  final String extensions;

  final String protocol;

  final int readyState;

  final String url;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void close([int code, String reason]) native;

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  void send(data) native;
}

class _WebSocketEventsImpl extends _EventsImpl implements WebSocketEvents {
  _WebSocketEventsImpl(_ptr) : super(_ptr);

  EventListenerList get close => this['close'];

  EventListenerList get error => this['error'];

  EventListenerList get message => this['message'];

  EventListenerList get open => this['open'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


/// @domName WheelEvent
abstract class WheelEvent implements MouseEvent {

  /** @domName WheelEvent.webkitDirectionInvertedFromDevice */
  bool get webkitDirectionInvertedFromDevice;

  /** @domName WheelEvent.wheelDeltaX */
  int get $dom_wheelDeltaX;

  /** @domName WheelEvent.wheelDeltaY */
  int get $dom_wheelDeltaY;

  /** @domName WheelEvent.initWebKitWheelEvent */
  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, LocalWindow view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);


  /** @domName WheelEvent.deltaX */
  abstract num get deltaX;

  /** @domName WheelEvent.deltaY */
  abstract num get deltaY;

  /** @domName WheelEvent.deltaMode */
  abstract int get deltaMode;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WheelEventImpl extends _MouseEventImpl implements WheelEvent native "*WheelEvent" {

  final bool webkitDirectionInvertedFromDevice;

  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, _LocalWindowImpl view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;


  num get deltaY {
    if (JS('bool', '#.deltaY !== undefined', this)) {
      // W3C WheelEvent
      return this._deltaY;
    } else if (JS('bool', '#.wheelDelta !== undefined', this)) {
      // Chrome and IE
      return this._wheelDelta;
    } else if (JS('bool', '#.detail !== undefined', this)) {
      // Firefox

      // Handle DOMMouseScroll case where it uses detail and the axis to
      // differentiate.
      if (JS('bool', '#.axis == MouseScrollEvent.VERTICAL_AXIS', this)) {
        var detail = this._detail;
        // Firefox is normally the number of lines to scale (normally 3)
        // so multiply it by 40 to get pixels to move, matching IE & WebKit.
        if (detail < 100) {
          return detail * 40;
        }
        return detail;
      }
      return 0;
    }
    throw new UnsupportedError(
        'deltaY is not supported');
  }

  num get deltaX {
    if (JS('bool', '#.deltaX !== undefined', this)) {
      // W3C WheelEvent
      return this._deltaX;
    } else if (JS('bool', '#.wheelDeltaX !== undefined', this)) {
      // Chrome
      return this._wheelDeltaX;
    } else if (JS('bool', '#.detail !== undefined', this)) {
      // Firefox and IE.
      // IE will have detail set but will not set axis.

      // Handle DOMMouseScroll case where it uses detail and the axis to
      // differentiate.
      if (JS('bool', '#.axis !== undefined && #.axis == MouseScrollEvent.HORIZONTAL_AXIS', this, this)) {
        var detail = this._detail;
        // Firefox is normally the number of lines to scale (normally 3)
        // so multiply it by 40 to get pixels to move, matching IE & WebKit.
        if (detail < 100) {
          return detail * 40;
        }
        return detail;
      }
      return 0;
    }
    throw new UnsupportedError(
        'deltaX is not supported');
  }

  int get deltaMode {
    if (JS('bool', '!!#.deltaMode', this)) {
      // If not available then we're poly-filling and doing pixel scroll.
      return 0;
    }
    return this._deltaMode;
  }

  num get _deltaY => JS('num', '#.deltaY', this);
  num get _deltaX => JS('num', '#.deltaX', this);
  num get _wheelDelta => JS('num', '#.wheelDelta', this);
  num get _wheelDeltaX => JS('num', '#.wheelDeltaX', this);
  num get _detail => JS('num', '#.detail', this);
  int get _deltaMode => JS('int', '#.deltaMode', this);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Worker
abstract class Worker implements AbstractWorker {

  factory Worker(String scriptUrl) => _WorkerFactoryProvider.createWorker(scriptUrl);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WorkerEvents get on;

  /** @domName Worker.postMessage */
  void postMessage(/*SerializedScriptValue*/ message, [List messagePorts]);

  /** @domName Worker.terminate */
  void terminate();
}

abstract class WorkerEvents implements AbstractWorkerEvents {

  EventListenerList get message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerContext
abstract class WorkerContext implements EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WorkerContextEvents get on;

  static const int PERSISTENT = 1;

  static const int TEMPORARY = 0;

  /** @domName WorkerContext.indexedDB */
  IDBFactory get indexedDB;

  /** @domName WorkerContext.location */
  WorkerLocation get location;

  /** @domName WorkerContext.navigator */
  WorkerNavigator get navigator;

  /** @domName WorkerContext.self */
  WorkerContext get self;

  /** @domName WorkerContext.webkitIndexedDB */
  IDBFactory get webkitIndexedDB;

  /** @domName WorkerContext.webkitNotifications */
  NotificationCenter get webkitNotifications;

  /** @domName WorkerContext.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WorkerContext.clearInterval */
  void clearInterval(int handle);

  /** @domName WorkerContext.clearTimeout */
  void clearTimeout(int handle);

  /** @domName WorkerContext.close */
  void close();

  /** @domName WorkerContext.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName WorkerContext.importScripts */
  void importScripts();

  /** @domName WorkerContext.openDatabase */
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName WorkerContext.openDatabaseSync */
  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName WorkerContext.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WorkerContext.setInterval */
  int setInterval(TimeoutHandler handler, int timeout);

  /** @domName WorkerContext.setTimeout */
  int setTimeout(TimeoutHandler handler, int timeout);

  /** @domName WorkerContext.webkitRequestFileSystem */
  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback, ErrorCallback errorCallback]);

  /** @domName WorkerContext.webkitRequestFileSystemSync */
  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size);

  /** @domName WorkerContext.webkitResolveLocalFileSystemSyncURL */
  EntrySync webkitResolveLocalFileSystemSyncURL(String url);

  /** @domName WorkerContext.webkitResolveLocalFileSystemURL */
  void webkitResolveLocalFileSystemURL(String url, EntryCallback successCallback, [ErrorCallback errorCallback]);
}

abstract class WorkerContextEvents implements Events {

  EventListenerList get error;
}

class _WorkerContextImpl extends _EventTargetImpl implements WorkerContext native "*WorkerContext" {

  _WorkerContextEventsImpl get on =>
    new _WorkerContextEventsImpl(this);

  final _IDBFactoryImpl indexedDB;

  final _WorkerLocationImpl location;

  final _WorkerNavigatorImpl navigator;

  final _WorkerContextImpl self;

  final _IDBFactoryImpl webkitIndexedDB;

  final _NotificationCenterImpl webkitNotifications;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native "addEventListener";

  void clearInterval(int handle) native;

  void clearTimeout(int handle) native;

  void close() native;

  bool $dom_dispatchEvent(_EventImpl evt) native "dispatchEvent";

  void importScripts() native;

  _DatabaseImpl openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native;

  _DatabaseSyncImpl openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native;

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native "removeEventListener";

  int setInterval(TimeoutHandler handler, int timeout) native;

  int setTimeout(TimeoutHandler handler, int timeout) native;

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback, ErrorCallback errorCallback]) native;

  _DOMFileSystemSyncImpl webkitRequestFileSystemSync(int type, int size) native;

  _EntrySyncImpl webkitResolveLocalFileSystemSyncURL(String url) native;

  void webkitResolveLocalFileSystemURL(String url, EntryCallback successCallback, [ErrorCallback errorCallback]) native;
}

class _WorkerContextEventsImpl extends _EventsImpl implements WorkerContextEvents {
  _WorkerContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error => this['error'];
}

class _WorkerImpl extends _AbstractWorkerImpl implements Worker native "*Worker" {

  _WorkerEventsImpl get on =>
    new _WorkerEventsImpl(this);

  void postMessage(/*SerializedScriptValue*/ message, [messagePorts]) {
    if (?messagePorts) {
      var message_1 = _convertDartToNative_SerializedScriptValue(message);
      _postMessage_1(message_1, messagePorts);
      return;
    }
    var message_2 = _convertDartToNative_SerializedScriptValue(message);
    _postMessage_2(message_2);
    return;
  }
  void _postMessage_1(message, List messagePorts) native "postMessage";
  void _postMessage_2(message) native "postMessage";

  void terminate() native;
}

class _WorkerEventsImpl extends _AbstractWorkerEventsImpl implements WorkerEvents {
  _WorkerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message => this['message'];
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerLocation
abstract class WorkerLocation {

  /** @domName WorkerLocation.hash */
  String get hash;

  /** @domName WorkerLocation.host */
  String get host;

  /** @domName WorkerLocation.hostname */
  String get hostname;

  /** @domName WorkerLocation.href */
  String get href;

  /** @domName WorkerLocation.pathname */
  String get pathname;

  /** @domName WorkerLocation.port */
  String get port;

  /** @domName WorkerLocation.protocol */
  String get protocol;

  /** @domName WorkerLocation.search */
  String get search;

  /** @domName WorkerLocation.toString */
  String toString();
}

class _WorkerLocationImpl implements WorkerLocation native "*WorkerLocation" {

  final String hash;

  final String host;

  final String hostname;

  final String href;

  final String pathname;

  final String port;

  final String protocol;

  final String search;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerNavigator
abstract class WorkerNavigator {

  /** @domName WorkerNavigator.appName */
  String get appName;

  /** @domName WorkerNavigator.appVersion */
  String get appVersion;

  /** @domName WorkerNavigator.onLine */
  bool get onLine;

  /** @domName WorkerNavigator.platform */
  String get platform;

  /** @domName WorkerNavigator.userAgent */
  String get userAgent;
}

class _WorkerNavigatorImpl implements WorkerNavigator native "*WorkerNavigator" {

  final String appName;

  final String appVersion;

  final bool onLine;

  final String platform;

  final String userAgent;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLSerializer
abstract class XMLSerializer {

  factory XMLSerializer() => _XMLSerializerFactoryProvider.createXMLSerializer();

  /** @domName XMLSerializer.serializeToString */
  String serializeToString(Node node);
}

class _XMLSerializerImpl implements XMLSerializer native "*XMLSerializer" {

  String serializeToString(_NodeImpl node) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathEvaluator
abstract class XPathEvaluator {

  factory XPathEvaluator() => _XPathEvaluatorFactoryProvider.createXPathEvaluator();

  /** @domName XPathEvaluator.createExpression */
  XPathExpression createExpression(String expression, XPathNSResolver resolver);

  /** @domName XPathEvaluator.createNSResolver */
  XPathNSResolver createNSResolver(Node nodeResolver);

  /** @domName XPathEvaluator.evaluate */
  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult);
}

class _XPathEvaluatorImpl implements XPathEvaluator native "*XPathEvaluator" {

  _XPathExpressionImpl createExpression(String expression, _XPathNSResolverImpl resolver) native;

  _XPathNSResolverImpl createNSResolver(_NodeImpl nodeResolver) native;

  _XPathResultImpl evaluate(String expression, _NodeImpl contextNode, _XPathNSResolverImpl resolver, int type, _XPathResultImpl inResult) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathException
abstract class XPathException {

  static const int INVALID_EXPRESSION_ERR = 51;

  static const int TYPE_ERR = 52;

  /** @domName XPathException.code */
  int get code;

  /** @domName XPathException.message */
  String get message;

  /** @domName XPathException.name */
  String get name;

  /** @domName XPathException.toString */
  String toString();
}

class _XPathExceptionImpl implements XPathException native "*XPathException" {

  final int code;

  final String message;

  final String name;

  String toString() native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathExpression
abstract class XPathExpression {

  /** @domName XPathExpression.evaluate */
  XPathResult evaluate(Node contextNode, int type, XPathResult inResult);
}

class _XPathExpressionImpl implements XPathExpression native "*XPathExpression" {

  _XPathResultImpl evaluate(_NodeImpl contextNode, int type, _XPathResultImpl inResult) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathNSResolver
abstract class XPathNSResolver {

  /** @domName XPathNSResolver.lookupNamespaceURI */
  String lookupNamespaceURI(String prefix);
}

class _XPathNSResolverImpl implements XPathNSResolver native "*XPathNSResolver" {

  String lookupNamespaceURI(String prefix) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathResult
abstract class XPathResult {

  static const int ANY_TYPE = 0;

  static const int ANY_UNORDERED_NODE_TYPE = 8;

  static const int BOOLEAN_TYPE = 3;

  static const int FIRST_ORDERED_NODE_TYPE = 9;

  static const int NUMBER_TYPE = 1;

  static const int ORDERED_NODE_ITERATOR_TYPE = 5;

  static const int ORDERED_NODE_SNAPSHOT_TYPE = 7;

  static const int STRING_TYPE = 2;

  static const int UNORDERED_NODE_ITERATOR_TYPE = 4;

  static const int UNORDERED_NODE_SNAPSHOT_TYPE = 6;

  /** @domName XPathResult.booleanValue */
  bool get booleanValue;

  /** @domName XPathResult.invalidIteratorState */
  bool get invalidIteratorState;

  /** @domName XPathResult.numberValue */
  num get numberValue;

  /** @domName XPathResult.resultType */
  int get resultType;

  /** @domName XPathResult.singleNodeValue */
  Node get singleNodeValue;

  /** @domName XPathResult.snapshotLength */
  int get snapshotLength;

  /** @domName XPathResult.stringValue */
  String get stringValue;

  /** @domName XPathResult.iterateNext */
  Node iterateNext();

  /** @domName XPathResult.snapshotItem */
  Node snapshotItem(int index);
}

class _XPathResultImpl implements XPathResult native "*XPathResult" {

  final bool booleanValue;

  final bool invalidIteratorState;

  final num numberValue;

  final int resultType;

  final _NodeImpl singleNodeValue;

  final int snapshotLength;

  final String stringValue;

  _NodeImpl iterateNext() native;

  _NodeImpl snapshotItem(int index) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XSLTProcessor
abstract class XSLTProcessor {

  factory XSLTProcessor() => _XSLTProcessorFactoryProvider.createXSLTProcessor();

  /** @domName XSLTProcessor.clearParameters */
  void clearParameters();

  /** @domName XSLTProcessor.getParameter */
  String getParameter(String namespaceURI, String localName);

  /** @domName XSLTProcessor.importStylesheet */
  void importStylesheet(Node stylesheet);

  /** @domName XSLTProcessor.removeParameter */
  void removeParameter(String namespaceURI, String localName);

  /** @domName XSLTProcessor.reset */
  void reset();

  /** @domName XSLTProcessor.setParameter */
  void setParameter(String namespaceURI, String localName, String value);

  /** @domName XSLTProcessor.transformToDocument */
  Document transformToDocument(Node source);

  /** @domName XSLTProcessor.transformToFragment */
  DocumentFragment transformToFragment(Node source, Document docVal);
}

class _XSLTProcessorImpl implements XSLTProcessor native "*XSLTProcessor" {

  void clearParameters() native;

  String getParameter(String namespaceURI, String localName) native;

  void importStylesheet(_NodeImpl stylesheet) native;

  void removeParameter(String namespaceURI, String localName) native;

  void reset() native;

  void setParameter(String namespaceURI, String localName, String value) native;

  _DocumentImpl transformToDocument(_NodeImpl source) native;

  _DocumentFragmentImpl transformToFragment(_NodeImpl source, _DocumentImpl docVal) native;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ArrayBufferFactoryProvider {
  static ArrayBuffer createArrayBuffer(int length) =>
      JS('ArrayBuffer', 'new ArrayBuffer(#)', length);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioElementFactoryProvider {
  static AudioElement createAudioElement([String src = null]) {
    if (src == null) return JS('AudioElement', 'new Audio()');
    return JS('AudioElement', 'new Audio(#)', src);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _BlobFactoryProvider {
  static Blob createBlob([List blobParts = null, String type, String endings]) {
    // TODO: validate that blobParts is a JS Array and convert if not.
    // TODO: any coercions on the elements of blobParts, e.g. coerce a typed
    // array to ArrayBuffer if it is a total view.
    if (type == null && endings == null) {
      return _create_1(blobParts);
    }
    var bag = _create_bag();
    if (type != null) _bag_set(bag, 'type', type);
    if (endings != null) _bag_set(bag, 'endings', endings);
    return _create_2(blobParts, bag);
  }

  static _create_1(parts) => JS('Blob', 'new Blob(#)', parts);
  static _create_2(parts, bag) => JS('Blob', 'new Blob(#, #)', parts, bag);

  static _create_bag() => JS('var', '{}');
  static _bag_set(bag, key, value) { JS('void', '#[#] = #', bag, key, value); }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _CSSMatrixFactoryProvider {
  static CSSMatrix createCSSMatrix([String cssValue = '']) =>
      JS('CSSMatrix', 'new WebKitCSSMatrix(#)', cssValue);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMParserFactoryProvider {
  static DOMParser createDOMParser() =>
      JS('DOMParser', 'new DOMParser()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMURLFactoryProvider {
  static DOMURL createDOMURL() =>
      JS('DOMURL', 'new DOMURL()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DataViewFactoryProvider {
  static DataView createDataView(
      ArrayBuffer buffer, [int byteOffset = null, int byteLength = null]) {
    if (byteOffset == null) {
      return JS('DataView', 'new DataView(#)', buffer);
    }
    if (byteLength == null) {
      return JS('DataView', 'new DataView(#,#)', buffer, byteOffset);
    }
    return JS('DataView', 'new DataView(#,#,#)', buffer, byteOffset, byteLength);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


class _Elements {


  static AnchorElement createAnchorElement([String href]) {
    _AnchorElementImpl _e = _document.$dom_createElement("a");
    if (href != null) _e.href = href;
    return _e;
  }

  static AreaElement createAreaElement() {
    _AreaElementImpl _e = _document.$dom_createElement("area");
    return _e;
  }

  static BRElement createBRElement() {
    _BRElementImpl _e = _document.$dom_createElement("br");
    return _e;
  }

  static BaseElement createBaseElement() {
    _BaseElementImpl _e = _document.$dom_createElement("base");
    return _e;
  }

  static BodyElement createBodyElement() {
    _BodyElementImpl _e = _document.$dom_createElement("body");
    return _e;
  }

  static ButtonElement createButtonElement() {
    _ButtonElementImpl _e = _document.$dom_createElement("button");
    return _e;
  }

  static CanvasElement createCanvasElement([int width, int height]) {
    _CanvasElementImpl _e = _document.$dom_createElement("canvas");
    if (width != null) _e.width = width;
    if (height != null) _e.height = height;
    return _e;
  }

  static ContentElement createContentElement() {
    _ContentElementImpl _e = _document.$dom_createElement("content");
    return _e;
  }

  static DListElement createDListElement() {
    _DListElementImpl _e = _document.$dom_createElement("dl");
    return _e;
  }

  static DataListElement createDataListElement() {
    _DataListElementImpl _e = _document.$dom_createElement("datalist");
    return _e;
  }

  static DetailsElement createDetailsElement() {
    _DetailsElementImpl _e = _document.$dom_createElement("details");
    return _e;
  }

  static DivElement createDivElement() {
    _DivElementImpl _e = _document.$dom_createElement("div");
    return _e;
  }

  static EmbedElement createEmbedElement() {
    _EmbedElementImpl _e = _document.$dom_createElement("embed");
    return _e;
  }

  static FieldSetElement createFieldSetElement() {
    _FieldSetElementImpl _e = _document.$dom_createElement("fieldset");
    return _e;
  }

  static FormElement createFormElement() {
    _FormElementImpl _e = _document.$dom_createElement("form");
    return _e;
  }

  static HRElement createHRElement() {
    _HRElementImpl _e = _document.$dom_createElement("hr");
    return _e;
  }

  static HeadElement createHeadElement() {
    _HeadElementImpl _e = _document.$dom_createElement("head");
    return _e;
  }

  static HeadingElement createHeadingElement_h1() {
    _HeadingElementImpl _e = _document.$dom_createElement("h1");
    return _e;
  }

  static HeadingElement createHeadingElement_h2() {
    _HeadingElementImpl _e = _document.$dom_createElement("h2");
    return _e;
  }

  static HeadingElement createHeadingElement_h3() {
    _HeadingElementImpl _e = _document.$dom_createElement("h3");
    return _e;
  }

  static HeadingElement createHeadingElement_h4() {
    _HeadingElementImpl _e = _document.$dom_createElement("h4");
    return _e;
  }

  static HeadingElement createHeadingElement_h5() {
    _HeadingElementImpl _e = _document.$dom_createElement("h5");
    return _e;
  }

  static HeadingElement createHeadingElement_h6() {
    _HeadingElementImpl _e = _document.$dom_createElement("h6");
    return _e;
  }

  static HtmlElement createHtmlElement() {
    _HtmlElementImpl _e = _document.$dom_createElement("html");
    return _e;
  }

  static IFrameElement createIFrameElement() {
    _IFrameElementImpl _e = _document.$dom_createElement("iframe");
    return _e;
  }

  static ImageElement createImageElement([String src, int width, int height]) {
    _ImageElementImpl _e = _document.$dom_createElement("img");
    if (src != null) _e.src = src;
    if (width != null) _e.width = width;
    if (height != null) _e.height = height;
    return _e;
  }

  static InputElement createInputElement([String type]) {
    _InputElementImpl _e = _document.$dom_createElement("input");
    if (type != null) _e.type = type;
    return _e;
  }

  static KeygenElement createKeygenElement() {
    _KeygenElementImpl _e = _document.$dom_createElement("keygen");
    return _e;
  }

  static LIElement createLIElement() {
    _LIElementImpl _e = _document.$dom_createElement("li");
    return _e;
  }

  static LabelElement createLabelElement() {
    _LabelElementImpl _e = _document.$dom_createElement("label");
    return _e;
  }

  static LegendElement createLegendElement() {
    _LegendElementImpl _e = _document.$dom_createElement("legend");
    return _e;
  }

  static LinkElement createLinkElement() {
    _LinkElementImpl _e = _document.$dom_createElement("link");
    return _e;
  }

  static MapElement createMapElement() {
    _MapElementImpl _e = _document.$dom_createElement("map");
    return _e;
  }

  static MenuElement createMenuElement() {
    _MenuElementImpl _e = _document.$dom_createElement("menu");
    return _e;
  }

  static MeterElement createMeterElement() {
    _MeterElementImpl _e = _document.$dom_createElement("meter");
    return _e;
  }

  static OListElement createOListElement() {
    _OListElementImpl _e = _document.$dom_createElement("ol");
    return _e;
  }

  static ObjectElement createObjectElement() {
    _ObjectElementImpl _e = _document.$dom_createElement("object");
    return _e;
  }

  static OptGroupElement createOptGroupElement() {
    _OptGroupElementImpl _e = _document.$dom_createElement("optgroup");
    return _e;
  }

  static OutputElement createOutputElement() {
    _OutputElementImpl _e = _document.$dom_createElement("output");
    return _e;
  }

  static ParagraphElement createParagraphElement() {
    _ParagraphElementImpl _e = _document.$dom_createElement("p");
    return _e;
  }

  static ParamElement createParamElement() {
    _ParamElementImpl _e = _document.$dom_createElement("param");
    return _e;
  }

  static PreElement createPreElement() {
    _PreElementImpl _e = _document.$dom_createElement("pre");
    return _e;
  }

  static ProgressElement createProgressElement() {
    _ProgressElementImpl _e = _document.$dom_createElement("progress");
    return _e;
  }

  static ScriptElement createScriptElement() {
    _ScriptElementImpl _e = _document.$dom_createElement("script");
    return _e;
  }

  static SelectElement createSelectElement() {
    _SelectElementImpl _e = _document.$dom_createElement("select");
    return _e;
  }

  static SourceElement createSourceElement() {
    _SourceElementImpl _e = _document.$dom_createElement("source");
    return _e;
  }

  static SpanElement createSpanElement() {
    _SpanElementImpl _e = _document.$dom_createElement("span");
    return _e;
  }

  static StyleElement createStyleElement() {
    _StyleElementImpl _e = _document.$dom_createElement("style");
    return _e;
  }

  static TableCaptionElement createTableCaptionElement() {
    _TableCaptionElementImpl _e = _document.$dom_createElement("caption");
    return _e;
  }

  static TableCellElement createTableCellElement() {
    _TableCellElementImpl _e = _document.$dom_createElement("td");
    return _e;
  }

  static TableColElement createTableColElement() {
    _TableColElementImpl _e = _document.$dom_createElement("col");
    return _e;
  }

  static TableElement createTableElement() {
    _TableElementImpl _e = _document.$dom_createElement("table");
    return _e;
  }

  static TableRowElement createTableRowElement() {
    _TableRowElementImpl _e = _document.$dom_createElement("tr");
    return _e;
  }

  static TextAreaElement createTextAreaElement() {
    _TextAreaElementImpl _e = _document.$dom_createElement("textarea");
    return _e;
  }

  static TitleElement createTitleElement() {
    _TitleElementImpl _e = _document.$dom_createElement("title");
    return _e;
  }

  static TrackElement createTrackElement() {
    _TrackElementImpl _e = _document.$dom_createElement("track");
    return _e;
  }

  static UListElement createUListElement() {
    _UListElementImpl _e = _document.$dom_createElement("ul");
    return _e;
  }

  static VideoElement createVideoElement() {
    _VideoElementImpl _e = _document.$dom_createElement("video");
    return _e;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventSourceFactoryProvider {
  static EventSource createEventSource(String scriptUrl) =>
      JS('EventSource', 'new EventSource(#)', scriptUrl);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderFactoryProvider {
  static FileReader createFileReader() =>
      JS('FileReader', 'new FileReader()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderSyncFactoryProvider {
  static FileReaderSync createFileReaderSync() =>
      JS('FileReaderSync', 'new FileReaderSync()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FormDataFactoryProvider {
  static FormData createFormData([FormElement form = null]) {
    if (form == null) return JS('FormData', 'new FormData()');
    return JS('FormData', 'new FormData(#)', form);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _HttpRequestFactoryProvider {
  static HttpRequest createHttpRequest() =>
      JS('HttpRequest', 'new XMLHttpRequest()');

  static HttpRequest createHttpRequest_get(String url,
      onSuccess(HttpRequest request)) =>
      _HttpRequestUtils.get(url, onSuccess, false);

  static HttpRequest createHttpRequest_getWithCredentials(String url,
      onSuccess(HttpRequest request)) =>
      _HttpRequestUtils.get(url, onSuccess, true);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _IceCandidateFactoryProvider {
  static IceCandidate createIceCandidate(String label, String candidateLine) =>
      JS('IceCandidate', 'new IceCandidate(#,#)', label, candidateLine);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaControllerFactoryProvider {
  static MediaController createMediaController() =>
      JS('MediaController', 'new MediaController()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaSourceFactoryProvider {
  static MediaSource createMediaSource() =>
      JS('MediaSource', 'new MediaSource()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaStreamFactoryProvider {
  static MediaStream createMediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks) =>
      JS('MediaStream', 'new MediaStream(#,#)', audioTracks, videoTracks);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MessageChannelFactoryProvider {
  static MessageChannel createMessageChannel() =>
      JS('MessageChannel', 'new MessageChannel()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MutationObserverFactoryProvider {
  static MutationObserver createMutationObserver(MutationCallback callback) native '''
    var constructor =
        window.MutationObserver || window.WebKitMutationObserver ||
        window.MozMutationObserver;
    return new constructor(callback);
  ''';

  // TODO(sra): Dart2js inserts a conversion when a Dart function (i.e. an
  // object with a call method) is passed to a native method.  This is so the
  // native code sees a JavaScript function.
  //
  // This does not happen when a function is 'passed' to a JS-form so it is not
  // possible to rewrite the above code to, e.g. (simplified):
  //
  // static createMutationObserver(MutationCallback callback) =>
  //    JS('var', 'new (window.MutationObserver)(#)', callback);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _NotificationFactoryProvider {
  static Notification createNotification(String title, [Map options]) =>
      JS('Notification', 'new Notification(#,#)', title, options);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _OptionElementFactoryProvider {
  static OptionElement createOptionElement(
      [String data, String value, bool defaultSelected, bool selected]) {
    if (data == null) {
      return JS('OptionElement', 'new Option()');
    }
    if (value == null) {
      return JS('OptionElement', 'new Option(#)', data);
    }
    if (defaultSelected == null) {
      return JS('OptionElement', 'new Option(#,#)', data, value);
    }
    if (selected == null) {
      return JS('OptionElement', 'new Option(#,#,#)',
                data, value, defaultSelected);
    }
    return JS('OptionElement', 'new Option(#,#,#,#)',
              data, value, defaultSelected, selected);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _PeerConnection00FactoryProvider {
  static PeerConnection00 createPeerConnection00(String serverConfiguration, IceCallback iceCallback) =>
      JS('PeerConnection00', 'new PeerConnection00(#,#)', serverConfiguration, iceCallback);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _RTCIceCandidateFactoryProvider {
  static RTCIceCandidate createRTCIceCandidate(Map dictionary) =>
      JS('RTCIceCandidate', 'new RTCIceCandidate(#)', dictionary);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _RTCPeerConnectionFactoryProvider {
  static RTCPeerConnection createRTCPeerConnection(Map rtcIceServers, [Map mediaConstraints]) =>
      JS('RTCPeerConnection', 'new RTCPeerConnection(#,#)', rtcIceServers, mediaConstraints);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _RTCSessionDescriptionFactoryProvider {
  static RTCSessionDescription createRTCSessionDescription(Map dictionary) =>
      JS('RTCSessionDescription', 'new RTCSessionDescription(#)', dictionary);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SessionDescriptionFactoryProvider {
  static SessionDescription createSessionDescription(String sdp) =>
      JS('SessionDescription', 'new SessionDescription(#)', sdp);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ShadowRootFactoryProvider {
  static ShadowRoot createShadowRoot(Element host) =>
      JS('ShadowRoot',
         'new (window.ShadowRoot || window.WebKitShadowRoot)(#)', host);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SharedWorkerFactoryProvider {
  static SharedWorker createSharedWorker(String scriptURL, [String name]) {
    if (name == null) return JS('SharedWorker', 'new SharedWorker(#)', scriptURL);
    return JS('SharedWorker', 'new SharedWorker(#,#)', scriptURL, name);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarFactoryProvider {
  static SpeechGrammar createSpeechGrammar() =>
      JS('SpeechGrammar', 'new SpeechGrammar()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarListFactoryProvider {
  static SpeechGrammarList createSpeechGrammarList() =>
      JS('SpeechGrammarList', 'new SpeechGrammarList()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechRecognitionFactoryProvider {
  static SpeechRecognition createSpeechRecognition() =>
      JS('SpeechRecognition', 'new SpeechRecognition()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _TextTrackCueFactoryProvider {
  static TextTrackCue createTextTrackCue(
      String id, num startTime, num endTime, String text,
      [String settings, bool pauseOnExit]) {
        if (settings == null) {
          return JS('TextTrackCue',
                    'new TextTrackCue(#,#,#,#)',
                    id, startTime, endTime, text);
        }
        if (pauseOnExit == null) {
          return JS('TextTrackCue',
                    'new TextTrackCue(#,#,#,#,#)',
                    id, startTime, endTime, text, settings);
        }
        return JS('TextTrackCue',
                  'new TextTrackCue(#,#,#,#,#,#)',
                  id, startTime, endTime, text, settings, pauseOnExit);
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WorkerFactoryProvider {
  static Worker createWorker(String scriptUrl) =>
      JS('Worker', 'new Worker(#)', scriptUrl);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLSerializerFactoryProvider {
  static XMLSerializer createXMLSerializer() =>
      JS('XMLSerializer', 'new XMLSerializer()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XPathEvaluatorFactoryProvider {
  static XPathEvaluator createXPathEvaluator() =>
      JS('XPathEvaluator', 'new XPathEvaluator()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XSLTProcessorFactoryProvider {
  static XSLTProcessor createXSLTProcessor() =>
      JS('XSLTProcessor', 'new XSLTProcessor()' );
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

abstract class Window {
  // Fields.
  Location get location;
  History get history;

  bool get closed;
  Window get opener;
  Window get parent;
  Window get top;

  // Methods.
  void focus();
  void blur();
  void close();
  void postMessage(var message, String targetOrigin, [List messagePorts = null]);
}

abstract class Location {
  void set href(String val);
}

abstract class History {
  void back();
  void forward();
  void go(int distance);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void EventListener(Event event);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the keycode values for keys that are returned by 
 * KeyboardEvent.keyCode.
 * 
 * Important note: There is substantial divergence in how different browsers
 * handle keycodes and their variants in different locales/keyboard layouts. We
 * provide these constants to help make code processing keys more readable.
 */
abstract class KeyCode {
  // These constant names were borrowed from Closure's Keycode enumeration
  // class.
  // http://closure-library.googlecode.com/svn/docs/closure_goog_events_keycodes.js.source.html  
  static final int WIN_KEY_FF_LINUX = 0;
  static final int MAC_ENTER = 3;
  static final int BACKSPACE = 8;
  static final int TAB = 9;
  /** NUM_CENTER is also NUMLOCK for FF and Safari on Mac. */
  static final int NUM_CENTER = 12;
  static final int ENTER = 13;
  static final int SHIFT = 16;
  static final int CTRL = 17;
  static final int ALT = 18;
  static final int PAUSE = 19;
  static final int CAPS_LOCK = 20;
  static final int ESC = 27;
  static final int SPACE = 32;
  static final int PAGE_UP = 33;
  static final int PAGE_DOWN = 34;
  static final int END = 35;
  static final int HOME = 36;
  static final int LEFT = 37;
  static final int UP = 38;
  static final int RIGHT = 39;
  static final int DOWN = 40;
  static final int NUM_NORTH_EAST = 33;
  static final int NUM_SOUTH_EAST = 34;
  static final int NUM_SOUTH_WEST = 35;
  static final int NUM_NORTH_WEST = 36;
  static final int NUM_WEST = 37;
  static final int NUM_NORTH = 38;
  static final int NUM_EAST = 39;
  static final int NUM_SOUTH = 40;
  static final int PRINT_SCREEN = 44;
  static final int INSERT = 45;
  static final int NUM_INSERT = 45;
  static final int DELETE = 46;
  static final int NUM_DELETE = 46;
  static final int ZERO = 48;
  static final int ONE = 49;
  static final int TWO = 50;
  static final int THREE = 51;
  static final int FOUR = 52;
  static final int FIVE = 53;
  static final int SIX = 54;
  static final int SEVEN = 55;
  static final int EIGHT = 56;
  static final int NINE = 57;
  static final int FF_SEMICOLON = 59;
  static final int FF_EQUALS = 61;
  /**
   * CAUTION: The question mark is for US-keyboard layouts. It varies
   * for other locales and keyboard layouts.
   */
  static final int QUESTION_MARK = 63;
  static final int A = 65;
  static final int B = 66;
  static final int C = 67;
  static final int D = 68;
  static final int E = 69;
  static final int F = 70;
  static final int G = 71;
  static final int H = 72;
  static final int I = 73;
  static final int J = 74;
  static final int K = 75;
  static final int L = 76;
  static final int M = 77;
  static final int N = 78;
  static final int O = 79;
  static final int P = 80;
  static final int Q = 81;
  static final int R = 82;
  static final int S = 83;
  static final int T = 84;
  static final int U = 85;
  static final int V = 86;
  static final int W = 87;
  static final int X = 88;
  static final int Y = 89;
  static final int Z = 90;
  static final int META = 91;
  static final int WIN_KEY_LEFT = 91;
  static final int WIN_KEY_RIGHT = 92;
  static final int CONTEXT_MENU = 93;
  static final int NUM_ZERO = 96;
  static final int NUM_ONE = 97;
  static final int NUM_TWO = 98;
  static final int NUM_THREE = 99;
  static final int NUM_FOUR = 100;
  static final int NUM_FIVE = 101;
  static final int NUM_SIX = 102;
  static final int NUM_SEVEN = 103;
  static final int NUM_EIGHT = 104;
  static final int NUM_NINE = 105;
  static final int NUM_MULTIPLY = 106;
  static final int NUM_PLUS = 107;
  static final int NUM_MINUS = 109;
  static final int NUM_PERIOD = 110;
  static final int NUM_DIVISION = 111;
  static final int F1 = 112;
  static final int F2 = 113;
  static final int F3 = 114;
  static final int F4 = 115;
  static final int F5 = 116;
  static final int F6 = 117;
  static final int F7 = 118;
  static final int F8 = 119;
  static final int F9 = 120;
  static final int F10 = 121;
  static final int F11 = 122;
  static final int F12 = 123;
  static final int NUMLOCK = 144;
  static final int SCROLL_LOCK = 145;

  // OS-specific media keys like volume controls and browser controls.
  static final int FIRST_MEDIA_KEY = 166;
  static final int LAST_MEDIA_KEY = 183;

  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int SEMICOLON = 186;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int DASH = 189;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int EQUALS = 187;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int COMMA = 188;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int PERIOD = 190;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int SLASH = 191;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int APOSTROPHE = 192;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int TILDE = 192;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int SINGLE_QUOTE = 222;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int OPEN_SQUARE_BRACKET = 219;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int BACKSLASH = 220;
  /**
   * CAUTION: This constant requires localization for other locales and keyboard
   * layouts.
   */
  static final int CLOSE_SQUARE_BRACKET = 221;
  static final int WIN_KEY = 224;
  static final int MAC_FF_META = 224;
  static final int WIN_IME = 229;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard key locations returned by
 * KeyboardEvent.getKeyLocation.
 */
abstract class KeyLocation {

  /**
   * The event key is not distinguished as the left or right version
   * of the key, and did not originate from the numeric keypad (or did not
   * originate with a virtual key corresponding to the numeric keypad).
   */
  static const int STANDARD = 0;

  /**
   * The event key is in the left key location.
   */
  static const int LEFT = 1;

  /**
   * The event key is in the right key location.
   */
  static const int RIGHT = 2;

  /**
   * The event key originated on the numeric keypad or with a virtual key
   * corresponding to the numeric keypad.
   */
  static const int NUMPAD = 3;

  /**
   * The event key originated on a mobile device, either on a physical
   * keypad or a virtual keyboard.
   */
  static const int MOBILE = 4;

  /**
   * The event key originated on a game controller or a joystick on a mobile
   * device.
   */
  static const int JOYSTICK = 5;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard keyboard identifier names for keys that are returned
 * by KeyEvent.getKeyboardIdentifier when the key does not have a direct
 * unicode mapping.
 */
abstract class KeyName {

  /** The Accept (Commit, OK) key */
  static const String ACCEPT = "Accept";

  /** The Add key */
  static const String ADD = "Add";

  /** The Again key */
  static const String AGAIN = "Again";

  /** The All Candidates key */
  static const String ALL_CANDIDATES = "AllCandidates";

  /** The Alphanumeric key */
  static const String ALPHANUMERIC = "Alphanumeric";

  /** The Alt (Menu) key */
  static const String ALT = "Alt";

  /** The Alt-Graph key */
  static const String ALT_GRAPH = "AltGraph";

  /** The Application key */
  static const String APPS = "Apps";

  /** The ATTN key */
  static const String ATTN = "Attn";

  /** The Browser Back key */
  static const String BROWSER_BACK = "BrowserBack";

  /** The Browser Favorites key */
  static const String BROWSER_FAVORTIES = "BrowserFavorites";

  /** The Browser Forward key */
  static const String BROWSER_FORWARD = "BrowserForward";

  /** The Browser Home key */
  static const String BROWSER_NAME = "BrowserHome";

  /** The Browser Refresh key */
  static const String BROWSER_REFRESH = "BrowserRefresh";

  /** The Browser Search key */
  static const String BROWSER_SEARCH = "BrowserSearch";

  /** The Browser Stop key */
  static const String BROWSER_STOP = "BrowserStop";

  /** The Camera key */
  static const String CAMERA = "Camera";

  /** The Caps Lock (Capital) key */
  static const String CAPS_LOCK = "CapsLock";

  /** The Clear key */
  static const String CLEAR = "Clear";

  /** The Code Input key */
  static const String CODE_INPUT = "CodeInput";

  /** The Compose key */
  static const String COMPOSE = "Compose";

  /** The Control (Ctrl) key */
  static const String CONTROL = "Control";

  /** The Crsel key */
  static const String CRSEL = "Crsel";

  /** The Convert key */
  static const String CONVERT = "Convert";

  /** The Copy key */
  static const String COPY = "Copy";

  /** The Cut key */
  static const String CUT = "Cut";

  /** The Decimal key */
  static const String DECIMAL = "Decimal";

  /** The Divide key */
  static const String DIVIDE = "Divide";

  /** The Down Arrow key */
  static const String DOWN = "Down";

  /** The diagonal Down-Left Arrow key */
  static const String DOWN_LEFT = "DownLeft";

  /** The diagonal Down-Right Arrow key */
  static const String DOWN_RIGHT = "DownRight";

  /** The Eject key */
  static const String EJECT = "Eject";

  /** The End key */
  static const String END = "End";

  /**
   * The Enter key. Note: This key value must also be used for the Return
   *  (Macintosh numpad) key
   */
  static const String ENTER = "Enter";

  /** The Erase EOF key */
  static const String ERASE_EOF= "EraseEof";

  /** The Execute key */
  static const String EXECUTE = "Execute";

  /** The Exsel key */
  static const String EXSEL = "Exsel";

  /** The Function switch key */
  static const String FN = "Fn";

  /** The F1 key */
  static const String F1 = "F1";

  /** The F2 key */
  static const String F2 = "F2";

  /** The F3 key */
  static const String F3 = "F3";

  /** The F4 key */
  static const String F4 = "F4";

  /** The F5 key */
  static const String F5 = "F5";

  /** The F6 key */
  static const String F6 = "F6";

  /** The F7 key */
  static const String F7 = "F7";

  /** The F8 key */
  static const String F8 = "F8";

  /** The F9 key */
  static const String F9 = "F9";

  /** The F10 key */
  static const String F10 = "F10";

  /** The F11 key */
  static const String F11 = "F11";

  /** The F12 key */
  static const String F12 = "F12";

  /** The F13 key */
  static const String F13 = "F13";

  /** The F14 key */
  static const String F14 = "F14";

  /** The F15 key */
  static const String F15 = "F15";

  /** The F16 key */
  static const String F16 = "F16";

  /** The F17 key */
  static const String F17 = "F17";

  /** The F18 key */
  static const String F18 = "F18";

  /** The F19 key */
  static const String F19 = "F19";

  /** The F20 key */
  static const String F20 = "F20";

  /** The F21 key */
  static const String F21 = "F21";

  /** The F22 key */
  static const String F22 = "F22";

  /** The F23 key */
  static const String F23 = "F23";

  /** The F24 key */
  static const String F24 = "F24";

  /** The Final Mode (Final) key used on some asian keyboards */
  static const String FINAL_MODE = "FinalMode";

  /** The Find key */
  static const String FIND = "Find";

  /** The Full-Width Characters key */
  static const String FULL_WIDTH = "FullWidth";

  /** The Half-Width Characters key */
  static const String HALF_WIDTH = "HalfWidth";

  /** The Hangul (Korean characters) Mode key */
  static const String HANGUL_MODE = "HangulMode";

  /** The Hanja (Korean characters) Mode key */
  static const String HANJA_MODE = "HanjaMode";

  /** The Help key */
  static const String HELP = "Help";

  /** The Hiragana (Japanese Kana characters) key */
  static const String HIRAGANA = "Hiragana";

  /** The Home key */
  static const String HOME = "Home";

  /** The Insert (Ins) key */
  static const String INSERT = "Insert";

  /** The Japanese-Hiragana key */
  static const String JAPANESE_HIRAGANA = "JapaneseHiragana";

  /** The Japanese-Katakana key */
  static const String JAPANESE_KATAKANA = "JapaneseKatakana";

  /** The Japanese-Romaji key */
  static const String JAPANESE_ROMAJI = "JapaneseRomaji";

  /** The Junja Mode key */
  static const String JUNJA_MODE = "JunjaMode";

  /** The Kana Mode (Kana Lock) key */
  static const String KANA_MODE = "KanaMode";

  /**
   * The Kanji (Japanese name for ideographic characters of Chinese origin)
   * Mode key
   */
  static const String KANJI_MODE = "KanjiMode";

  /** The Katakana (Japanese Kana characters) key */
  static const String KATAKANA = "Katakana";

  /** The Start Application One key */
  static const String LAUNCH_APPLICATION_1 = "LaunchApplication1";

  /** The Start Application Two key */
  static const String LAUNCH_APPLICATION_2 = "LaunchApplication2";

  /** The Start Mail key */
  static const String LAUNCH_MAIL = "LaunchMail";

  /** The Left Arrow key */
  static const String LEFT = "Left";

  /** The Menu key */
  static const String MENU = "Menu";

  /**
   * The Meta key. Note: This key value shall be also used for the Apple
   * Command key
   */
  static const String META = "Meta";

  /** The Media Next Track key */
  static const String MEDIA_NEXT_TRACK = "MediaNextTrack";

  /** The Media Play Pause key */
  static const String MEDIA_PAUSE_PLAY = "MediaPlayPause";

  /** The Media Previous Track key */
  static const String MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";

  /** The Media Stop key */
  static const String MEDIA_STOP = "MediaStop";

  /** The Mode Change key */
  static const String MODE_CHANGE = "ModeChange";

  /** The Next Candidate function key */
  static const String NEXT_CANDIDATE = "NextCandidate";

  /** The Nonconvert (Don't Convert) key */
  static const String NON_CONVERT = "Nonconvert";

  /** The Number Lock key */
  static const String NUM_LOCK = "NumLock";

  /** The Page Down (Next) key */
  static const String PAGE_DOWN = "PageDown";

  /** The Page Up key */
  static const String PAGE_UP = "PageUp";

  /** The Paste key */
  static const String PASTE = "Paste";

  /** The Pause key */
  static const String PAUSE = "Pause";

  /** The Play key */
  static const String PLAY = "Play";

  /**
   * The Power key. Note: Some devices may not expose this key to the
   * operating environment
   */
  static const String POWER = "Power";

  /** The Previous Candidate function key */
  static const String PREVIOUS_CANDIDATE = "PreviousCandidate";

  /** The Print Screen (PrintScrn, SnapShot) key */
  static const String PRINT_SCREEN = "PrintScreen";

  /** The Process key */
  static const String PROCESS = "Process";

  /** The Props key */
  static const String PROPS = "Props";

  /** The Right Arrow key */
  static const String RIGHT = "Right";

  /** The Roman Characters function key */
  static const String ROMAN_CHARACTERS = "RomanCharacters";

  /** The Scroll Lock key */
  static const String SCROLL = "Scroll";

  /** The Select key */
  static const String SELECT = "Select";

  /** The Select Media key */
  static const String SELECT_MEDIA = "SelectMedia";

  /** The Separator key */
  static const String SEPARATOR = "Separator";

  /** The Shift key */
  static const String SHIFT = "Shift";

  /** The Soft1 key */
  static const String SOFT_1 = "Soft1";

  /** The Soft2 key */
  static const String SOFT_2 = "Soft2";

  /** The Soft3 key */
  static const String SOFT_3 = "Soft3";

  /** The Soft4 key */
  static const String SOFT_4 = "Soft4";

  /** The Stop key */
  static const String STOP = "Stop";

  /** The Subtract key */
  static const String SUBTRACT = "Subtract";

  /** The Symbol Lock key */
  static const String SYMBOL_LOCK = "SymbolLock";

  /** The Up Arrow key */
  static const String UP = "Up";

  /** The diagonal Up-Left Arrow key */
  static const String UP_LEFT = "UpLeft";

  /** The diagonal Up-Right Arrow key */
  static const String UP_RIGHT = "UpRight";

  /** The Undo key */
  static const String UNDO = "Undo";

  /** The Volume Down key */
  static const String VOLUME_DOWN = "VolumeDown";

  /** The Volume Mute key */
  static const String VOLUMN_MUTE = "VolumeMute";

  /** The Volume Up key */
  static const String VOLUMN_UP = "VolumeUp";

  /** The Windows Logo key */
  static const String WIN = "Win";

  /** The Zoom key */
  static const String ZOOM = "Zoom";

  /**
   * The Backspace (Back) key. Note: This key value shall be also used for the
   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key
   */
  static const String BACKSPACE = "Backspace";

  /** The Horizontal Tabulation (Tab) key */
  static const String TAB = "Tab";

  /** The Cancel key */
  static const String CANCEL = "Cancel";

  /** The Escape (Esc) key */
  static const String ESC = "Esc";

  /** The Space (Spacebar) key:   */
  static const String SPACEBAR = "Spacebar";

  /**
   * The Delete (Del) Key. Note: This key value shall be also used for the key
   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key
   */
  static const String DEL = "Del";

  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */
  static const String DEAD_GRAVE = "DeadGrave";

  /**
   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)
   * key
   */
  static const String DEAD_EACUTE = "DeadEacute";

  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */
  static const String DEAD_CIRCUMFLEX = "DeadCircumflex";

  /** The Combining Tilde (Dead Tilde) key */
  static const String DEAD_TILDE = "DeadTilde";

  /** The Combining Macron (Long, Dead Macron) key */
  static const String DEAD_MACRON = "DeadMacron";

  /** The Combining Breve (Short, Dead Breve) key */
  static const String DEAD_BREVE = "DeadBreve";

  /** The Combining Dot Above (Derivative, Dead Above Dot) key */
  static const String DEAD_ABOVE_DOT = "DeadAboveDot";

  /**
   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,
   * Double Derivative, Dead Diaeresis) key
   */
  static const String DEAD_UMLAUT = "DeadUmlaut";

  /** The Combining Ring Above (Dead Above Ring) key */
  static const String DEAD_ABOVE_RING = "DeadAboveRing";

  /** The Combining Double Acute Accent (Dead Doubleacute) key */
  static const String DEAD_DOUBLEACUTE = "DeadDoubleacute";

  /** The Combining Caron (Hacek, V Above, Dead Caron) key */
  static const String DEAD_CARON = "DeadCaron";

  /** The Combining Cedilla (Dead Cedilla) key */
  static const String DEAD_CEDILLA = "DeadCedilla";

  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */
  static const String DEAD_OGONEK = "DeadOgonek";

  /**
   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota
   * Subscript, Dead Iota) key
   */
  static const String DEAD_IOTA = "DeadIota";

  /**
   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key
   */
  static const String DEAD_VOICED_SOUND = "DeadVoicedSound";

  /**
   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced
   * Sound) key
   */
  static const String DEC_SEMIVOICED_SOUND= "DeadSemivoicedSound";

  /**
   * Key value used when an implementation is unable to identify another key
   * value, due to either hardware, platform, or software constraints
   */
  static const String UNIDENTIFIED = "Unidentified";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Contains the set of standard values returned by HTMLDocument.getReadyState.
 */
abstract class ReadyState {
  /**
   * Indicates the document is still loading and parsing.
   */
  static const String LOADING = "loading";

  /**
   * Indicates the document is finished parsing but is still loading
   * subresources.
   */
  static const String INTERACTIVE = "interactive";

  /**
   * Indicates the document and all subresources have been loaded.
   */
  static const String COMPLETE = "complete";
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(antonm): support not DOM isolates too.
class _Timer implements Timer {
  final canceller;

  _Timer(this.canceller);

  void cancel() { canceller(); }
}

get _timerFactoryClosure => (int milliSeconds, void callback(Timer timer), bool repeating) {
  var maker;
  var canceller;
  if (repeating) {
    maker = window.setInterval;
    canceller = window.clearInterval;
  } else {
    maker = window.setTimeout;
    canceller = window.clearTimeout;
  }
  Timer timer;
  final int id = maker(() { callback(timer); }, milliSeconds);
  timer = new _Timer(() { canceller(id); });
  return timer;
};
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collections] class implements static methods useful when
 * writing a class that implements [Collection] and the [iterator]
 * method.
 */
class _Collections {
  static bool contains(Iterable<Object> iterable, Object element) {
    for (final e in iterable) {
      if (e == element) return true;
    }
    return false;
  }

  static void forEach(Iterable<Object> iterable, void f(Object o)) {
    for (final e in iterable) {
      f(e);
    }
  }

  static List map(Iterable<Object> source,
                  List<Object> destination,
                  f(o)) {
    for (final e in source) {
      destination.add(f(e));
    }
    return destination;
  }

  static bool some(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (f(e)) return true;
    }
    return false;
  }

  static bool every(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (!f(e)) return false;
    }
    return true;
  }

  static List filter(Iterable<Object> source,
                     List<Object> destination,
                     bool f(o)) {
    for (final e in source) {
      if (f(e)) destination.add(e);
    }
    return destination;
  }

  static bool isEmpty(Iterable<Object> iterable) {
    return !iterable.iterator().hasNext;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _HttpRequestUtils {

  // Helper for factory HttpRequest.get
  static HttpRequest get(String url,
                            onSuccess(HttpRequest request),
                            bool withCredentials) {
    final request = new HttpRequest();
    request.open('GET', url, true);

    request.withCredentials = withCredentials;

    // Status 0 is for local XHR request.
    request.on.readyStateChange.add((e) {
      if (request.readyState == HttpRequest.DONE &&
          (request.status == 200 || request.status == 0)) {
        onSuccess(request);
      }
    });

    request.send();

    return request;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

_serialize(var message) {
  return new _JsSerializer().traverse(message);
}

class _JsSerializer extends _Serializer {

  visitSendPortSync(SendPortSync x) {
    if (x is _JsSendPortSync) return visitJsSendPortSync(x);
    if (x is _LocalSendPortSync) return visitLocalSendPortSync(x);
    if (x is _RemoteSendPortSync) return visitRemoteSendPortSync(x);
    throw "Unknown port type $x";
  }

  visitJsSendPortSync(_JsSendPortSync x) {
    return [ 'sendport', 'nativejs', x._id ];
  }

  visitLocalSendPortSync(_LocalSendPortSync x) {
    return [ 'sendport', 'dart',
             ReceivePortSync._isolateId, x._receivePort._portId ];
  }

  visitRemoteSendPortSync(_RemoteSendPortSync x) {
    return [ 'sendport', 'dart',
             x._receivePort._isolateId, x._receivePort._portId ];
  }
}

_deserialize(var message) {
  return new _JsDeserializer().deserialize(message);
}


class _JsDeserializer extends _Deserializer {

  static const _UNSPECIFIED = const Object();

  deserializeSendPort(List x) {
    String tag = x[1];
    switch (tag) {
      case 'nativejs':
        num id = x[2];
        return new _JsSendPortSync(id);
      case 'dart':
        num isolateId = x[2];
        num portId = x[3];
        return ReceivePortSync._lookup(isolateId, portId);
      default:
        throw 'Illegal SendPortSync type: $tag';
    }
  }
}

// The receiver is JS.
class _JsSendPortSync implements SendPortSync {

  num _id;
  _JsSendPortSync(this._id);

  callSync(var message) {
    var serialized = _serialize(message);
    var result = _callPortSync(_id, serialized);
    return _deserialize(result);
  }

}

// TODO(vsm): Differentiate between Dart2Js and Dartium isolates.
// The receiver is a different Dart isolate, compiled to JS.
class _RemoteSendPortSync implements SendPortSync {

  int _isolateId;
  int _portId;
  _RemoteSendPortSync(this._isolateId, this._portId);

  callSync(var message) {
    var serialized = _serialize(message);
    var result = _call(_isolateId, _portId, serialized);
    return _deserialize(result);
  }

  static _call(int isolateId, int portId, var message) {
    var target = 'dart-port-$isolateId-$portId'; 
    // TODO(vsm): Make this re-entrant.
    // TODO(vsm): Set this up set once, on the first call.
    var source = '$target-result';
    var result = null;
    var listener = (Event e) {
      result = JSON.parse(_getPortSyncEventData(e));
    };
    window.on[source].add(listener);
    _dispatchEvent(target, [source, message]);
    window.on[source].remove(listener);
    return result;
  }
}

// The receiver is in the same Dart isolate, compiled to JS.
class _LocalSendPortSync implements SendPortSync {

  ReceivePortSync _receivePort;

  _LocalSendPortSync._internal(this._receivePort);

  callSync(var message) {
    // TODO(vsm): Do a more efficient deep copy.
    var copy = _deserialize(_serialize(message));
    var result = _receivePort._callback(copy);
    return _deserialize(_serialize(result));
  }
}

// TODO(vsm): Move this to dart:isolate.  This will take some
// refactoring as there are dependences here on the DOM.  Users
// interact with this class (or interface if we change it) directly -
// new ReceivePortSync.  I think most of the DOM logic could be
// delayed until the corresponding SendPort is registered on the
// window.

// A Dart ReceivePortSync (tagged 'dart' when serialized) is
// identifiable / resolvable by the combination of its isolateid and
// portid.  When a corresponding SendPort is used within the same
// isolate, the _portMap below can be used to obtain the
// ReceivePortSync directly.  Across isolates (or from JS), an
// EventListener can be used to communicate with the port indirectly.
class ReceivePortSync {

  static Map<int, ReceivePortSync> _portMap;
  static int _portIdCount;
  static int _cachedIsolateId;

  num _portId;
  Function _callback;
  EventListener _listener;

  ReceivePortSync() {
    if (_portIdCount == null) {
      _portIdCount = 0;
      _portMap = new Map<int, ReceivePortSync>();
    }
    _portId = _portIdCount++;
    _portMap[_portId] = this;
  }

  static int get _isolateId {
    // TODO(vsm): Make this coherent with existing isolate code.
    if (_cachedIsolateId == null) {
      _cachedIsolateId = _getNewIsolateId();      
    }
    return _cachedIsolateId;
  }

  static String _getListenerName(isolateId, portId) =>
      'dart-port-$isolateId-$portId'; 
  String get _listenerName => _getListenerName(_isolateId, _portId);

  void receive(callback(var message)) {
    _callback = callback;
    if (_listener == null) {
      _listener = (Event e) {
        var data = JSON.parse(_getPortSyncEventData(e));
        var replyTo = data[0];
        var message = _deserialize(data[1]);
        var result = _callback(message);
        _dispatchEvent(replyTo, _serialize(result));
      };
      window.on[_listenerName].add(_listener);
    }
  }

  void close() {
    _portMap.remove(_portId);
    if (_listener != null) window.on[_listenerName].remove(_listener);
  }

  SendPortSync toSendPort() {
    return new _LocalSendPortSync._internal(this);
  }

  static SendPortSync _lookup(int isolateId, int portId) {
    if (isolateId == _isolateId) {
      return _portMap[portId].toSendPort();
    } else {
      return new _RemoteSendPortSync(isolateId, portId);
    }
  }
}

get _isolateId => ReceivePortSync._isolateId;

void _dispatchEvent(String receiver, var message) {
  var event = new CustomEvent(receiver, false, false, JSON.stringify(message));
  window.$dom_dispatchEvent(event);
}

String _getPortSyncEventData(CustomEvent event) => event.detail;
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef Object ComputeValue();

class _MeasurementRequest<T> {
  final ComputeValue computeValue;
  final Completer<T> completer;
  Object value;
  bool exception = false;
  _MeasurementRequest(this.computeValue, this.completer);
}

typedef void _MeasurementCallback();


/**
 * This class attempts to invoke a callback as soon as the current event stack
 * unwinds, but before the browser repaints.
 */
abstract class _MeasurementScheduler {
  bool _nextMeasurementFrameScheduled = false;
  _MeasurementCallback _callback;

  _MeasurementScheduler(this._callback);

  /**
   * Creates the best possible measurement scheduler for the current platform.
   */
  factory _MeasurementScheduler.best(_MeasurementCallback callback) {
    if (_isMutationObserverSupported()) {
      return new _MutationObserverScheduler(callback);
    }
    return new _PostMessageScheduler(callback);
  }

  /**
   * Schedules a measurement callback if one has not been scheduled already.
   */
  void maybeSchedule() {
    if (this._nextMeasurementFrameScheduled) {
      return;
    }
    this._nextMeasurementFrameScheduled = true;
    this._schedule();
  }

  /**
   * Does the actual scheduling of the callback.
   */
  void _schedule();

  /**
   * Handles the measurement callback and forwards it if necessary.
   */
  void _onCallback() {
    // Ignore spurious messages.
    if (!_nextMeasurementFrameScheduled) {
      return;
    }
    _nextMeasurementFrameScheduled = false;
    this._callback();
  }
}

/**
 * Scheduler which uses window.postMessage to schedule events.
 */
class _PostMessageScheduler extends _MeasurementScheduler {
  const _MEASUREMENT_MESSAGE = "DART-MEASURE";

  _PostMessageScheduler(_MeasurementCallback callback): super(callback) {
      // Messages from other windows do not cause a security risk as
      // all we care about is that _handleMessage is called
      // after the current event loop is unwound and calling the function is
      // a noop when zero requests are pending.
      window.on.message.add(this._handleMessage);
  }

  void _schedule() {
    window.postMessage(_MEASUREMENT_MESSAGE, "*");
  }

  _handleMessage(e) {
    this._onCallback();
  }
}

/**
 * Scheduler which uses a MutationObserver to schedule events.
 */
class _MutationObserverScheduler extends _MeasurementScheduler {
  MutationObserver _observer;
  Element _dummy;

  _MutationObserverScheduler(_MeasurementCallback callback): super(callback) {
    // Mutation events get fired as soon as the current event stack is unwound
    // so we just make a dummy event and listen for that.
    _observer = new MutationObserver(this._handleMutation);
    _dummy = new DivElement();
    _observer.observe(_dummy, attributes: true);
  }

  void _schedule() {
    // Toggle it to trigger the mutation event.
    _dummy.hidden = !_dummy.hidden;
  }

  _handleMutation(List<MutationRecord> mutations, MutationObserver observer) {
    this._onCallback();
  }
}


List<_MeasurementRequest> _pendingRequests;
List<TimeoutHandler> _pendingMeasurementFrameCallbacks;
_MeasurementScheduler _measurementScheduler = null;

void _maybeScheduleMeasurementFrame() {
  if (_measurementScheduler == null) {
    _measurementScheduler =
      new _MeasurementScheduler.best(_completeMeasurementFutures);
  }
  _measurementScheduler.maybeSchedule();
}

/**
 * Registers a [callback] which is called after the next batch of measurements
 * completes. Even if no measurements completed, the callback is triggered
 * when they would have completed to avoid confusing bugs if it happened that
 * no measurements were actually requested.
 */
void _addMeasurementFrameCallback(TimeoutHandler callback) {
  if (_pendingMeasurementFrameCallbacks == null) {
    _pendingMeasurementFrameCallbacks = <TimeoutHandler>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingMeasurementFrameCallbacks.add(callback);
}

/**
 * Returns a [Future] whose value will be the result of evaluating
 * [computeValue] during the next safe measurement interval.
 * The next safe measurement interval is after the current event loop has
 * unwound but before the browser has rendered the page.
 * It is important that the [computeValue] function only queries the html
 * layout and html in any way.
 */
Future _createMeasurementFuture(ComputeValue computeValue,
                                Completer completer) {
  if (_pendingRequests == null) {
    _pendingRequests = <_MeasurementRequest>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingRequests.add(new _MeasurementRequest(computeValue, completer));
  return completer.future;
}

/**
 * Complete all pending measurement futures evaluating them in a single batch
 * so that the the browser is guaranteed to avoid multiple layouts.
 */
void _completeMeasurementFutures() {
  // We must compute all new values before fulfilling the futures as
  // the onComplete callbacks for the futures could modify the DOM making
  // subsequent measurement calculations expensive to compute.
  if (_pendingRequests != null) {
    for (_MeasurementRequest request in _pendingRequests) {
      try {
        request.value = request.computeValue();
      } catch (e) {
        request.value = e;
        request.exception = true;
      }
    }
  }

  final completedRequests = _pendingRequests;
  final readyMeasurementFrameCallbacks = _pendingMeasurementFrameCallbacks;
  _pendingRequests = null;
  _pendingMeasurementFrameCallbacks = null;
  if (completedRequests != null) {
    for (_MeasurementRequest request in completedRequests) {
      if (request.exception) {
        request.completer.completeException(request.value);
      } else {
        request.completer.complete(request.value);
      }
    }
  }

  if (readyMeasurementFrameCallbacks != null) {
    for (TimeoutHandler handler in readyMeasurementFrameCallbacks) {
      // TODO(jacobr): wrap each call to a handler in a try-catch block.
      handler();
    }
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Patch file for the dart:isolate library.

/********************************************************
  Inserted from lib/isolate/serialization.dart
 ********************************************************/

class _MessageTraverserVisitedMap {

  operator[](var object) => null;
  void operator[]=(var object, var info) { }

  void reset() { }
  void cleanup() { }

}

/** Abstract visitor for dart objects that can be sent as isolate messages. */
class _MessageTraverser {

  _MessageTraverserVisitedMap _visited;
  _MessageTraverser() : _visited = new _MessageTraverserVisitedMap();

  /** Visitor's entry point. */
  traverse(var x) {
    if (isPrimitive(x)) return visitPrimitive(x);
    _visited.reset();
    var result;
    try {
      result = _dispatch(x);
    } finally {
      _visited.cleanup();
    }
    return result;
  }

  _dispatch(var x) {
    if (isPrimitive(x)) return visitPrimitive(x);
    if (x is List) return visitList(x);
    if (x is Map) return visitMap(x);
    if (x is SendPort) return visitSendPort(x);
    if (x is SendPortSync) return visitSendPortSync(x);

    // Overridable fallback.
    return visitObject(x);
  }

  abstract visitPrimitive(x);
  abstract visitList(List x);
  abstract visitMap(Map x);
  abstract visitSendPort(SendPort x);
  abstract visitSendPortSync(SendPortSync x);

  visitObject(Object x) {
    // TODO(floitsch): make this a real exception. (which one)?
    throw "Message serialization: Illegal value $x passed";
  }

  static bool isPrimitive(x) {
    return (x == null) || (x is String) || (x is num) || (x is bool);
  }
}


/** A visitor that recursively copies a message. */
class _Copier extends _MessageTraverser {

  visitPrimitive(x) => x;

  List visitList(List list) {
    List copy = _visited[list];
    if (copy != null) return copy;

    int len = list.length;

    // TODO(floitsch): we loose the generic type of the List.
    copy = new List(len);
    _visited[list] = copy;
    for (int i = 0; i < len; i++) {
      copy[i] = _dispatch(list[i]);
    }
    return copy;
  }

  Map visitMap(Map map) {
    Map copy = _visited[map];
    if (copy != null) return copy;

    // TODO(floitsch): we loose the generic type of the map.
    copy = new Map();
    _visited[map] = copy;
    map.forEach((key, val) {
      copy[_dispatch(key)] = _dispatch(val);
    });
    return copy;
  }

}

/** Visitor that serializes a message as a JSON array. */
class _Serializer extends _MessageTraverser {
  int _nextFreeRefId = 0;

  visitPrimitive(x) => x;

  visitList(List list) {
    int copyId = _visited[list];
    if (copyId != null) return ['ref', copyId];

    int id = _nextFreeRefId++;
    _visited[list] = id;
    var jsArray = _serializeList(list);
    // TODO(floitsch): we are losing the generic type.
    return ['list', id, jsArray];
  }

  visitMap(Map map) {
    int copyId = _visited[map];
    if (copyId != null) return ['ref', copyId];

    int id = _nextFreeRefId++;
    _visited[map] = id;
    var keys = _serializeList(map.keys);
    var values = _serializeList(map.values);
    // TODO(floitsch): we are losing the generic type.
    return ['map', id, keys, values];
  }

  _serializeList(List list) {
    int len = list.length;
    var result = new List(len);
    for (int i = 0; i < len; i++) {
      result[i] = _dispatch(list[i]);
    }
    return result;
  }
}

/** Deserializes arrays created with [_Serializer]. */
class _Deserializer {
  Map<int, dynamic> _deserialized;

  _Deserializer();

  static bool isPrimitive(x) {
    return (x == null) || (x is String) || (x is num) || (x is bool);
  }

  deserialize(x) {
    if (isPrimitive(x)) return x;
    // TODO(floitsch): this should be new HashMap<int, dynamic>()
    _deserialized = new HashMap();
    return _deserializeHelper(x);
  }

  _deserializeHelper(x) {
    if (isPrimitive(x)) return x;
    assert(x is List);
    switch (x[0]) {
      case 'ref': return _deserializeRef(x);
      case 'list': return _deserializeList(x);
      case 'map': return _deserializeMap(x);
      case 'sendport': return deserializeSendPort(x);
      default: return deserializeObject(x);
    }
  }

  _deserializeRef(List x) {
    int id = x[1];
    var result = _deserialized[id];
    assert(result != null);
    return result;
  }

  List _deserializeList(List x) {
    int id = x[1];
    // We rely on the fact that Dart-lists are directly mapped to Js-arrays.
    List dartList = x[2];
    _deserialized[id] = dartList;
    int len = dartList.length;
    for (int i = 0; i < len; i++) {
      dartList[i] = _deserializeHelper(dartList[i]);
    }
    return dartList;
  }

  Map _deserializeMap(List x) {
    Map result = new Map();
    int id = x[1];
    _deserialized[id] = result;
    List keys = x[2];
    List values = x[3];
    int len = keys.length;
    assert(len == values.length);
    for (int i = 0; i < len; i++) {
      var key = _deserializeHelper(keys[i]);
      var value = _deserializeHelper(values[i]);
      result[key] = value;
    }
    return result;
  }

  abstract deserializeSendPort(List x);

  deserializeObject(List x) {
    // TODO(floitsch): Use real exception (which one?).
    throw "Unexpected serialized object";
  }
}

// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _CustomEventFactoryProvider {
  static CustomEvent createCustomEvent(String type, [bool canBubble = true,
      bool cancelable = true, Object detail = null]) {
    final _CustomEventImpl e = _document.$dom_createEvent("CustomEvent");
    e.$dom_initCustomEvent(type, canBubble, cancelable, detail);
    return e;
  }
}

class _EventFactoryProvider {
  static Event createEvent(String type, [bool canBubble = true,
      bool cancelable = true]) {
    final _EventImpl e = _document.$dom_createEvent("Event");
    e.$dom_initEvent(type, canBubble, cancelable);
    return e;
  }
}

class _MouseEventFactoryProvider {
  static MouseEvent createMouseEvent(String type, Window view, int detail,
      int screenX, int screenY, int clientX, int clientY, int button,
      [bool canBubble = true, bool cancelable = true, bool ctrlKey = false,
      bool altKey = false, bool shiftKey = false, bool metaKey = false,
      EventTarget relatedTarget = null]) {
    final e = _document.$dom_createEvent("MouseEvent");
    e.$dom_initMouseEvent(type, canBubble, cancelable, view, detail,
        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
        button, relatedTarget);
    return e;
  }
}

class _CSSStyleDeclarationFactoryProvider {
  static CSSStyleDeclaration createCSSStyleDeclaration_css(String css) {
    final style = new Element.tag('div').style;
    style.cssText = css;
    return style;
  }

  static CSSStyleDeclaration createCSSStyleDeclaration() {
    return new CSSStyleDeclaration.css('');
  }
}

class _DocumentFragmentFactoryProvider {
  /** @domName Document.createDocumentFragment */
  static DocumentFragment createDocumentFragment() =>
      document.createDocumentFragment();

  static DocumentFragment createDocumentFragment_html(String html) {
    final fragment = new DocumentFragment();
    fragment.innerHTML = html;
    return fragment;
  }

  // TODO(nweiz): enable this when XML is ported.
  // factory DocumentFragment.xml(String xml) {
  //   final fragment = new DocumentFragment();
  //   final e = new XMLElement.tag("xml");
  //   e.innerHTML = xml;
  //
  //   // Copy list first since we don't want liveness during iteration.
  //   final List nodes = new List.from(e.nodes);
  //   fragment.nodes.addAll(nodes);
  //   return fragment;
  // }

  static DocumentFragment createDocumentFragment_svg(String svg) {
    final fragment = new DocumentFragment();
    final e = new SVGSVGElement();
    e.innerHTML = svg;

    // Copy list first since we don't want liveness during iteration.
    final List nodes = new List.from(e.nodes);
    fragment.nodes.addAll(nodes);
    return fragment;
  }
}

class _SVGElementFactoryProvider {
  static SVGElement createSVGElement_tag(String tag) {
    final Element temp =
      _document.$dom_createElementNS("http://www.w3.org/2000/svg", tag);
    return temp;
  }

  static SVGElement createSVGElement_svg(String svg) {
    Element parentTag;
    final match = _START_TAG_REGEXP.firstMatch(svg);
    if (match != null && match.group(1).toLowerCase() == 'svg') {
      parentTag = new Element.tag('div');
    } else {
      parentTag = new SVGSVGElement();
    }

    parentTag.innerHTML = svg;
    if (parentTag.elements.length == 1) return parentTag.elements.removeLast();

    throw new ArgumentError(
        'SVG had ${parentTag.elements.length} '
        'top-level elements but 1 expected');
  }
}

class _SVGSVGElementFactoryProvider {
  static SVGSVGElement createSVGSVGElement() {
    final el = new SVGElement.tag("svg");
    // The SVG spec requires the version attribute to match the spec version
    el.attributes['version'] = "1.1";
    return el;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


// Conversions for IDBKey.
//
// Per http://www.w3.org/TR/IndexedDB/#key-construct
//
// "A value is said to be a valid key if it is one of the following types: Array
// JavaScript objects [ECMA-262], DOMString [WEBIDL], Date [ECMA-262] or float
// [WEBIDL]. However Arrays are only valid keys if every item in the array is
// defined and is a valid key (i.e. sparse arrays can not be valid keys) and if
// the Array doesn't directly or indirectly contain itself. Any non-numeric
// properties are ignored, and thus does not affect whether the Array is a valid
// key. Additionally, if the value is of type float, it is only a valid key if
// it is not NaN, and if the value is of type Date it is only a valid key if its
// [[PrimitiveValue]] internal property, as defined by [ECMA-262], is not NaN."

// What is required is to ensure that an Lists in the key are actually
// JavaScript arrays, and any Dates are JavaScript Dates.

// Conversions for Window.  These check if the window is the local
// window, and if it's not, wraps or unwraps it with a secure wrapper.
// We need to test for EventTarget here as well as it's a base type.
// We omit an unwrapper for Window as no methods take a non-local
// window as a parameter.

Window _convertNativeToDart_Window(win) {
  return _DOMWindowCrossFrameImpl._createSafe(win);
}

EventTarget _convertNativeToDart_EventTarget(e) {
  // Assume it's a Window if it contains the setInterval property.  It may be
  // from a different frame - without a patched prototype - so we cannot
  // rely on Dart type checking.
  if (JS('bool', r'"setInterval" in #', e))
    return _DOMWindowCrossFrameImpl._createSafe(e);
  else
    return e;
}

EventTarget _convertDartToNative_EventTarget(e) {
  if (e is _DOMWindowCrossFrameImpl) {
    return e._window;
  } else {
    return e;
  }
}

// Conversions for ImageData
//
// On Firefox, the returned ImageData is a plain object.

class _TypedImageData implements ImageData {
  final Uint8ClampedArray data;
  final int height;
  final int width;

  _TypedImageData(this.data, this.height, this.width);
}

ImageData _convertNativeToDart_ImageData(nativeImageData) {
  if (nativeImageData is ImageData) return nativeImageData;

  // On Firefox the above test fails because imagedata is a plain object.
  // So we create a _TypedImageData.

  return new _TypedImageData(
      JS('var', '#.data', nativeImageData),
      JS('var', '#.height', nativeImageData),
      JS('var', '#.width', nativeImageData));
}

// We can get rid of this conversion if _TypedImageData implements the fields
// with native names.
_convertDartToNative_ImageData(ImageData imageData) {
  if (imageData is _ImageDataImpl) return imageData;
  return JS('Object', '{data: #, height: #, width: #}',
            imageData.data, imageData.height, imageData.width);
}


/// Converts a JavaScript object with properties into a Dart Map.
/// Not suitable for nested objects.
Map _convertNativeToDart_Dictionary(object) {
  if (object == null) return null;
  var dict = {};
  for (final key in JS('List', 'Object.getOwnPropertyNames(#)', object)) {
    dict[key] = JS('var', '#[#]', object, key);
  }
  return dict;
}

/// Converts a flat Dart map into a JavaScript object with properties.
_convertDartToNative_Dictionary(Map dict) {
  if (dict == null) return null;
  var object = JS('var', '{}');
  dict.forEach((String key, value) {
      JS('void', '#[#] = #', object, key, value);
    });
  return object;
}


/**
 * Ensures that the input is a JavaScript Array.
 *
 * Creates a new JavaScript array if necessary, otherwise returns the original.
 */
List _convertDartToNative_StringArray(List<String> input) {
  // TODO(sra).  Implement this.
  return input;
}


// -----------------------------------------------------------------------------

/**
 * Converts a native IDBKey into a Dart object.
 *
 * May return the original input.  May mutate the original input (but will be
 * idempotent if mutation occurs).  It is assumed that this conversion happens
 * on native IDBKeys on all paths that return IDBKeys from native DOM calls.
 *
 * If necessary, JavaScript Dates are converted into Dart Dates.
 */
_convertNativeToDart_IDBKey(nativeKey) {
  containsDate(object) {
    if (_isJavaScriptDate(object)) return true;
    if (object is List) {
      for (int i = 0; i < object.length; i++) {
        if (containsDate(object[i])) return true;
      }
    }
    return false;  // number, string.
  }
  if (containsDate(nativeKey)) {
    throw new UnimplementedError('IDBKey containing Date');
  }
  // TODO: Cache conversion somewhere?
  return nativeKey;
}

/**
 * Converts a Dart object into a valid IDBKey.
 *
 * May return the original input.  Does not mutate input.
 *
 * If necessary, [dartKey] may be copied to ensure all lists are converted into
 * JavaScript Arrays and Dart Dates into JavaScript Dates.
 */
_convertDartToNative_IDBKey(dartKey) {
  // TODO: Implement.
  return dartKey;
}



/// May modify original.  If so, action is idempotent.
_convertNativeToDart_IDBAny(object) {
  return _convertNativeToDart_AcceptStructuredClone(object, mustCopy: false);
}

/// Converts a Dart value into a JavaScript SerializedScriptValue.
_convertDartToNative_SerializedScriptValue(value) {
  return _convertDartToNative_PrepareForStructuredClone(value);
}

/// Since the source object may be viewed via a JavaScript event listener the
/// original may not be modified.
_convertNativeToDart_SerializedScriptValue(object) {
  return _convertNativeToDart_AcceptStructuredClone(object, mustCopy: true);
}


/**
 * Converts a Dart value into a JavaScript SerializedScriptValue.  Returns the
 * original input or a functional 'copy'.  Does not mutate the original.
 *
 * The main transformation is the translation of Dart Maps are converted to
 * JavaScript Objects.
 *
 * The algorithm is essentially a dry-run of the structured clone algorithm
 * described at
 * http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#structured-clone
 * https://www.khronos.org/registry/typedarray/specs/latest/#9
 *
 * Since the result of this function is expected to be passed only to JavaScript
 * operations that perform the structured clone algorithm which does not mutate
 * its output, the result may share structure with the input [value].
 */
_convertDartToNative_PrepareForStructuredClone(value) {

  // TODO(sra): Replace slots with identity hash table.
  var values = [];
  var copies = [];  // initially 'null', 'true' during initial DFS, then a copy.

  int findSlot(value) {
    int length = values.length;
    for (int i = 0; i < length; i++) {
      if (identical(values[i], value)) return i;
    }
    values.add(value);
    copies.add(null);
    return length;
  }
  readSlot(int i) => copies[i];
  writeSlot(int i, x) { copies[i] = x; }
  cleanupSlots() {}  // Will be needed if we mark objects with a property.

  // Returns the input, or a clone of the input.
  walk(e) {
    if (e == null) return e;
    if (e is bool) return e;
    if (e is num) return e;
    if (e is String) return e;
    if (e is Date) {
      // TODO(sra).
      throw new UnimplementedError('structured clone of Date');
    }
    if (e is RegExp) {
      // TODO(sra).
      throw new UnimplementedError('structured clone of RegExp');
    }

    // The browser's internal structured cloning algorithm will copy certain
    // types of object, but it will copy only its own implementations and not
    // just any Dart implementations of the interface.

    // TODO(sra): The JavaScript objects suitable for direct cloning by the
    // structured clone algorithm could be tagged with an private interface.

    if (e is _FileImpl) return e;
    if (e is File) {
      throw new UnimplementedError('structured clone of File');
    }

    if (e is _BlobImpl) return e;
    if (e is Blob) {
      throw new UnimplementedError('structured clone of Blob');
    }

    if (e is _FileListImpl) return e;

    // TODO(sra): Firefox: How to convert _TypedImageData on the other end?
    if (e is _ImageDataImpl) return e;
    if (e is ImageData) {
      throw new UnimplementedError('structured clone of ImageData');
    }

    if (e is _ArrayBufferImpl) return e;
    if (e is ArrayBuffer) {
      throw new UnimplementedError('structured clone of ArrayBuffer');
    }

    if (e is _ArrayBufferViewImpl) return e;
    if (e is ArrayBufferView) {
      throw new UnimplementedError('structured clone of ArrayBufferView');
    }

    if (e is Map) {
      var slot = findSlot(e);
      var copy = readSlot(slot);
      if (copy != null) return copy;
      copy = JS('var', '{}');
      writeSlot(slot, copy);
      e.forEach((key, value) {
          JS('void', '#[#] = #', copy, key, walk(value));
        });
      return copy;
    }

    if (e is List) {
      // Since a JavaScript Array is an instance of Dart List it is possible to
      // avoid making a copy of the list if there is no need to copy anything
      // reachable from the array.  We defer creating a new array until a cycle
      // is detected or a subgraph was copied.
      int length = e.length;
      var slot = findSlot(e);
      var copy = readSlot(slot);
      if (copy != null) {
        if (true == copy) {  // Cycle, so commit to making a copy.
          copy = JS('List', 'new Array(#)', length);
          writeSlot(slot, copy);
        }
        return copy;
      }

      int i = 0;

      if (_isJavaScriptArray(e) &&
          // We have to copy immutable lists, otherwise the structured clone
          // algorithm will copy the .immutable$list marker property, making the
          // list immutable when received!
          !_isImmutableJavaScriptArray(e)) {
        writeSlot(slot, true);  // Deferred copy.
        for ( ; i < length; i++) {
          var element = e[i];
          var elementCopy = walk(element);
          if (!identical(elementCopy, element)) {
            copy = readSlot(slot);   // Cyclic reference may have created it.
            if (true == copy) {
              copy = JS('List', 'new Array(#)', length);
              writeSlot(slot, copy);
            }
            for (int j = 0; j < i; j++) {
              copy[j] = e[j];
            }
            copy[i] = elementCopy;
            i++;
            break;
          }
        }
        if (copy == null) {
          copy = e;
          writeSlot(slot, copy);
        }
      } else {
        // Not a JavaScript Array.  We are forced to make a copy.
        copy = JS('List', 'new Array(#)', length);
        writeSlot(slot, copy);
      }

      for ( ; i < length; i++) {
        copy[i] = walk(e[i]);
      }
      return copy;
    }

    throw new UnimplementedError('structured clone of other type');
  }

  var copy = walk(value);
  cleanupSlots();
  return copy;
}

/**
 * Converts a native value into a Dart object.
 *
 * If [mustCopy] is [:false:], may return the original input.  May mutate the
 * original input (but will be idempotent if mutation occurs).  It is assumed
 * that this conversion happens on native serializable script values such values
 * from native DOM calls.
 *
 * [object] is the result of a structured clone operation.
 *
 * If necessary, JavaScript Dates are converted into Dart Dates.
 *
 * If [mustCopy] is [:true:], the entire object is copied and the original input
 * is not mutated.  This should be the case where Dart and JavaScript code can
 * access the value, for example, via multiple event listeners for
 * MessageEvents.  Mutating the object to make it more 'Dart-like' would corrupt
 * the value as seen from the JavaScript listeners.
 */
_convertNativeToDart_AcceptStructuredClone(object, {mustCopy = false}) {

  // TODO(sra): Replace slots with identity hash table that works on non-dart
  // objects.
  var values = [];
  var copies = [];

  int findSlot(value) {
    int length = values.length;
    for (int i = 0; i < length; i++) {
      if (identical(values[i], value)) return i;
    }
    values.add(value);
    copies.add(null);
    return length;
  }
  readSlot(int i) => copies[i];
  writeSlot(int i, x) { copies[i] = x; }

  walk(e) {
    if (e == null) return e;
    if (e is bool) return e;
    if (e is num) return e;
    if (e is String) return e;

    if (_isJavaScriptDate(e)) {
      // TODO(sra).
      throw new UnimplementedError('structured clone of Date');
    }

    if (_isJavaScriptRegExp(e)) {
      // TODO(sra).
      throw new UnimplementedError('structured clone of RegExp');
    }

    if (_isJavaScriptSimpleObject(e)) {
      // TODO(sra): If mustCopy is false, swizzle the prototype for one of a Map
      // implementation that uses the properies as storage.
      var slot = findSlot(e);
      var copy = readSlot(slot);
      if (copy != null) return copy;
      copy = {};

      writeSlot(slot, copy);
      for (final key in JS('List', 'Object.keys(#)', e)) {
        copy[key] = walk(JS('var', '#[#]', e, key));
      }
      return copy;
    }

    if (_isJavaScriptArray(e)) {
      var slot = findSlot(e);
      var copy = readSlot(slot);
      if (copy != null) return copy;

      int length = e.length;
      // Since a JavaScript Array is an instance of Dart List, we can modify it
      // in-place unless we must copy.
      copy = mustCopy ? JS('List', 'new Array(#)', length) : e;
      writeSlot(slot, copy);

      for (int i = 0; i < length; i++) {
        copy[i] = walk(e[i]);
      }
      return copy;
    }

    // Assume anything else is already a valid Dart object, either by having
    // already been processed, or e.g. a clonable native class.
    return e;
  }

  var copy = walk(object);
  return copy;
}


bool _isJavaScriptDate(value) => JS('bool', '# instanceof Date', value);
bool _isJavaScriptRegExp(value) => JS('bool', '# instanceof RegExp', value);
bool _isJavaScriptArray(value) => JS('bool', '# instanceof Array', value);
bool _isJavaScriptSimpleObject(value) =>
    JS('bool', 'Object.getPrototypeOf(#) === Object.prototype', value);
bool _isImmutableJavaScriptArray(value) =>
    JS('bool', r'!!(#.immutable$list)', value);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(vsm): Unify with Dartium version.
class _DOMWindowCrossFrameImpl implements Window {
  // Private window.  Note, this is a window in another frame, so it
  // cannot be typed as "Window" as its prototype is not patched
  // properly.  Its fields and methods can only be accessed via JavaScript.
  var _window;

  // Fields.
  History get history =>
    _HistoryCrossFrameImpl._createSafe(JS('History', '#.history', _window));
  Location get location =>
    _LocationCrossFrameImpl._createSafe(JS('Location', '#.location', _window));

  // TODO(vsm): Add frames to navigate subframes.  See 2312.

  bool get closed => JS('bool', '#.closed', _window);

  Window get opener => _createSafe(JS('Window', '#.opener', _window));

  Window get parent => _createSafe(JS('Window', '#.parent', _window));

  Window get top => _createSafe(JS('Window', '#.top', _window));

  // Methods.
  void focus() => JS('void', '#.focus()', _window);

  void blur() => JS('void', '#.blur()', _window);

  void close() => JS('void', '#.close()', _window);

  void postMessage(var message, String targetOrigin, [List messagePorts = null]) {
    if (messagePorts == null) {
      JS('void', '#.postMessage(#,#)', _window, message, targetOrigin);
    } else {
      JS('void', '#.postMessage(#,#,#)', _window, message, targetOrigin, messagePorts);
    }
  }

  // Implementation support.
  _DOMWindowCrossFrameImpl(this._window);

  static Window _createSafe(w) {
    if (identical(w, window)) {
      return w;
    } else {
      // TODO(vsm): Cache or implement equality.
      return new _DOMWindowCrossFrameImpl(w);
    }
  }
}

class _LocationCrossFrameImpl implements Location {
  // Private location.  Note, this is a location object in another frame, so it
  // cannot be typed as "Location" as its prototype is not patched
  // properly.  Its fields and methods can only be accessed via JavaScript.
  var _location;

  void set href(String val) => _setHref(_location, val);
  static void _setHref(location, val) {
    JS('void', '#.href = #', location, val);
  }

  // Implementation support.
  _LocationCrossFrameImpl(this._location);

  static Location _createSafe(location) {
    if (identical(location, window.location)) {
      return location;
    } else {
      // TODO(vsm): Cache or implement equality.
      return new _LocationCrossFrameImpl(location);
    }
  }
}

class _HistoryCrossFrameImpl implements History {
  // Private history.  Note, this is a history object in another frame, so it
  // cannot be typed as "History" as its prototype is not patched
  // properly.  Its fields and methods can only be accessed via JavaScript.
  var _history;

  void back() => JS('void', '#.back()', _history);

  void forward() => JS('void', '#.forward()', _history);

  void go(int distance) => JS('void', '#.go(#)', _history, distance);

  // Implementation support.
  _HistoryCrossFrameImpl(this._history);

  static History _createSafe(h) {
    if (identical(h, window.history)) {
      return h;
    } else {
      // TODO(vsm): Cache or implement equality.
      return new _HistoryCrossFrameImpl(h);
    }
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioContextFactoryProvider {

  static AudioContext createAudioContext() {
    return JS('AudioContext',
              'new (window.AudioContext || window.webkitAudioContext)()');
  }
}

class _PointFactoryProvider {
  static Point createPoint(num x, num y) =>
      JS('Point', 'new WebKitPoint(#, #)', x, y);
}

class _WebSocketFactoryProvider {
  static WebSocket createWebSocket(String url) =>
      JS('WebSocket', 'new WebSocket(#)', url);
}

class _TextFactoryProvider {
  static Text createText(String data) =>
      JS('Text', 'document.createTextNode(#)', data);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _IDBKeyRangeFactoryProvider {

  static IDBKeyRange createIDBKeyRange_only(/*IDBKey*/ value) =>
      _only(_class(), _translateKey(value));

  static IDBKeyRange createIDBKeyRange_lowerBound(
      /*IDBKey*/ bound, [bool open = false]) =>
      _lowerBound(_class(), _translateKey(bound), open);

  static IDBKeyRange createIDBKeyRange_upperBound(
      /*IDBKey*/ bound, [bool open = false]) =>
      _upperBound(_class(), _translateKey(bound), open);

  static IDBKeyRange createIDBKeyRange_bound(/*IDBKey*/ lower, /*IDBKey*/ upper,
      [bool lowerOpen = false, bool upperOpen = false]) =>
      _bound(_class(), _translateKey(lower), _translateKey(upper),
             lowerOpen, upperOpen);

  static var _cachedClass;

  static _class() {
    if (_cachedClass != null) return _cachedClass;
    return _cachedClass = _uncachedClass();
  }

  static _uncachedClass() =>
    JS('var',
       '''window.webkitIDBKeyRange || window.mozIDBKeyRange ||
          window.msIDBKeyRange || window.IDBKeyRange''');

  static _translateKey(idbkey) => idbkey;  // TODO: fixme.

  static _IDBKeyRangeImpl _only(cls, value) =>
       JS('_IDBKeyRangeImpl', '#.only(#)', cls, value);

  static _IDBKeyRangeImpl _lowerBound(cls, bound, open) =>
       JS('_IDBKeyRangeImpl', '#.lowerBound(#, #)', cls, bound, open);

  static _IDBKeyRangeImpl _upperBound(cls, bound, open) =>
       JS('_IDBKeyRangeImpl', '#.upperBound(#, #)', cls, bound, open);

  static _IDBKeyRangeImpl _bound(cls, lower, upper, lowerOpen, upperOpen) =>
       JS('_IDBKeyRangeImpl', '#.bound(#, #, #, #)',
          cls, lower, upper, lowerOpen, upperOpen);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.


// On Firefox 11, the object obtained from 'window.location' is very strange.
// It can't be monkey-patched and seems immune to putting methods on
// Object.prototype.  We are forced to wrap the object.

class _LocationWrapper implements LocalLocation {

  final _ptr;  // Opaque reference to real location.

  _LocationWrapper(this._ptr);

  // TODO(sra): Replace all the _set and _get calls with 'JS' forms.

  // final List<String> ancestorOrigins;
  List<String> get ancestorOrigins => _get(_ptr, 'ancestorOrigins');

  // String hash;
  String get hash => _get(_ptr, 'hash');
  void set hash(String value) => _set(_ptr, 'hash', value);

  // String host;
  String get host => _get(_ptr, 'host');
  void set host(String value) => _set(_ptr, 'host', value);

  // String hostname;
  String get hostname => _get(_ptr, 'hostname');
  void set hostname(String value) => _set(_ptr, 'hostname', value);

  // String href;
  String get href => _get(_ptr, 'href');
  void set href(String value) => _set(_ptr, 'href', value);

  // final String origin;
  String get origin => _get(_ptr, 'origin');

  // String pathname;
  String get pathname => _get(_ptr, 'pathname');
  void set pathname(String value) => _set(_ptr, 'pathname', value);

  // String port;
  String get port => _get(_ptr, 'port');
  void set port(String value) => _set(_ptr, 'port', value);

  // String protocol;
  String get protocol => _get(_ptr, 'protocol');
  void set protocol(String value) => _set(_ptr, 'protocol', value);

  // String search;
  String get search => _get(_ptr, 'search');
  void set search(String value) => _set(_ptr, 'search', value);


  void assign(String url) => JS('void', '#.assign(#)', _ptr, url);

  void reload() => JS('void', '#.reload()', _ptr);

  void replace(String url) => JS('void', '#.replace(#)', _ptr, url);

  String toString() => JS('String', '#.toString()', _ptr);


  static _get(p, m) => JS('var', '#[#]', p, m);
  static _set(p, m, v) => JS('void', '#[#] = #', p, m, v);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Checks to see if the mutation observer API is supported on the current
 * platform.
 */
bool _isMutationObserverSupported() =>
  JS('bool', '!!(window.MutationObserver || window.WebKitMutationObserver)');
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _TypedArrayFactoryProvider {

  static Float32Array createFloat32Array(int length) => _F32(length);
  static Float32Array createFloat32Array_fromList(List<num> list) =>
      _F32(ensureNative(list));
  static Float32Array createFloat32Array_fromBuffer(ArrayBuffer buffer,
                                  [int byteOffset = 0, int length]) {
    if (length == null) return _F32_2(buffer, byteOffset);
    return _F32_3(buffer, byteOffset, length);
  }

  static Float64Array createFloat64Array(int length) => _F64(length);
  static Float64Array createFloat64Array_fromList(List<num> list) =>
      _F64(ensureNative(list));
  static Float64Array createFloat64Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) {
    if (length == null) return _F64_2(buffer, byteOffset);
    return _F64_3(buffer, byteOffset, length);
  }

  static Int8Array createInt8Array(int length) => _I8(length);
  static Int8Array createInt8Array_fromList(List<num> list) =>
      _I8(ensureNative(list));
  static Int8Array createInt8Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) {
    if (length == null) return _I8_2(buffer, byteOffset);
    return _I8_3(buffer, byteOffset, length);
  }

  static Int16Array createInt16Array(int length) => _I16(length);
  static Int16Array createInt16Array_fromList(List<num> list) =>
      _I16(ensureNative(list));
  static Int16Array createInt16Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) {
    if (length == null) return _I16_2(buffer, byteOffset);
    return _I16_3(buffer, byteOffset, length);
  }

  static Int32Array createInt32Array(int length) => _I32(length);
  static Int32Array createInt32Array_fromList(List<num> list) =>
      _I32(ensureNative(list));
  static Int32Array createInt32Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) {
    if (length == null) return _I32_2(buffer, byteOffset);
    return _I32_3(buffer, byteOffset, length);
  }

  static Uint8Array createUint8Array(int length) => _U8(length);
  static Uint8Array createUint8Array_fromList(List<num> list) =>
      _U8(ensureNative(list));
  static Uint8Array createUint8Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) {
    if (length == null) return _U8_2(buffer, byteOffset);
    return _U8_3(buffer, byteOffset, length);
  }

  static Uint16Array createUint16Array(int length) => _U16(length);
  static Uint16Array createUint16Array_fromList(List<num> list) =>
      _U16(ensureNative(list));
  static Uint16Array createUint16Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) {
    if (length == null) return _U16_2(buffer, byteOffset);
    return _U16_3(buffer, byteOffset, length);
  }

  static Uint32Array createUint32Array(int length) => _U32(length);
  static Uint32Array createUint32Array_fromList(List<num> list) =>
      _U32(ensureNative(list));
  static Uint32Array createUint32Array_fromBuffer(ArrayBuffer buffer,
      [int byteOffset = 0, int length]) {
    if (length == null) return _U32_2(buffer, byteOffset);
    return _U32_3(buffer, byteOffset, length);
  }

  static Uint8ClampedArray createUint8ClampedArray(int length) => _U8C(length);
  static Uint8ClampedArray createUint8ClampedArray_fromList(List<num> list) =>
      _U8C(ensureNative(list));
  static Uint8ClampedArray createUint8ClampedArray_fromBuffer(
        ArrayBuffer buffer, [int byteOffset = 0, int length]) {
    if (length == null) return _U8C_2(buffer, byteOffset);
    return _U8C_3(buffer, byteOffset, length);
  }

  static Float32Array _F32(arg) =>
      JS('Float32Array', 'new Float32Array(#)', arg);
  static Float64Array _F64(arg) =>
      JS('Float64Array', 'new Float64Array(#)', arg);
  static Int8Array _I8(arg) =>
      JS('Int8Array', 'new Int8Array(#)', arg);
  static Int16Array _I16(arg) =>
      JS('Int16Array', 'new Int16Array(#)', arg);
  static Int32Array _I32(arg) =>
      JS('Int32Array', 'new Int32Array(#)', arg);
  static Uint8Array _U8(arg) =>
      JS('Uint8Array', 'new Uint8Array(#)', arg);
  static Uint16Array _U16(arg) =>
      JS('Uint16Array', 'new Uint16Array(#)', arg);
  static Uint32Array _U32(arg) =>
      JS('Uint32Array', 'new Uint32Array(#)', arg);
  static Uint8ClampedArray _U8C(arg) =>
      JS('Uint8ClampedArray', 'new Uint8ClampedArray(#)', arg);

  static Float32Array _F32_2(arg1, arg2) =>
      JS('Float32Array', 'new Float32Array(#, #)', arg1, arg2);
  static Float64Array _F64_2(arg1, arg2) =>
      JS('Float64Array', 'new Float64Array(#, #)', arg1, arg2);
  static Int8Array _I8_2(arg1, arg2) =>
      JS('Int8Array', 'new Int8Array(#, #)', arg1, arg2);
  static Int16Array _I16_2(arg1, arg2) =>
      JS('Int16Array', 'new Int16Array(#, #)', arg1, arg2);
  static Int32Array _I32_2(arg1, arg2) =>
      JS('Int32Array', 'new Int32Array(#, #)', arg1, arg2);
  static Uint8Array _U8_2(arg1, arg2) =>
      JS('Uint8Array', 'new Uint8Array(#, #)', arg1, arg2);
  static Uint16Array _U16_2(arg1, arg2) =>
      JS('Uint16Array', 'new Uint16Array(#, #)', arg1, arg2);
  static Uint32Array _U32_2(arg1, arg2) =>
      JS('Uint32Array', 'new Uint32Array(#, #)', arg1, arg2);
  static Uint8ClampedArray _U8C_2(arg1, arg2) =>
      JS('Uint8ClampedArray', 'new Uint8ClampedArray(#, #)', arg1, arg2);

  static Float32Array _F32_3(arg1, arg2, arg3) =>
      JS('Float32Array', 'new Float32Array(#, #, #)', arg1, arg2, arg3);
  static Float64Array _F64_3(arg1, arg2, arg3) =>
      JS('Float64Array', 'new Float64Array(#, #, #)', arg1, arg2, arg3);
  static Int8Array _I8_3(arg1, arg2, arg3) =>
      JS('Int8Array', 'new Int8Array(#, #, #)', arg1, arg2, arg3);
  static Int16Array _I16_3(arg1, arg2, arg3) =>
      JS('Int16Array', 'new Int16Array(#, #, #)', arg1, arg2, arg3);
  static Int32Array _I32_3(arg1, arg2, arg3) =>
      JS('Int32Array', 'new Int32Array(#, #, #)', arg1, arg2, arg3);
  static Uint8Array _U8_3(arg1, arg2, arg3) =>
      JS('Uint8Array', 'new Uint8Array(#, #, #)', arg1, arg2, arg3);
  static Uint16Array _U16_3(arg1, arg2, arg3) =>
      JS('Uint16Array', 'new Uint16Array(#, #, #)', arg1, arg2, arg3);
  static Uint32Array _U32_3(arg1, arg2, arg3) =>
      JS('Uint32Array', 'new Uint32Array(#, #, #)', arg1, arg2, arg3);
  static Uint8ClampedArray _U8C_3(arg1, arg2, arg3) =>
      JS('Uint8ClampedArray', 'new Uint8ClampedArray(#, #, #)', arg1, arg2, arg3);


  // Ensures that [list] is a JavaScript Array or a typed array.  If necessary,
  // copies the list.
  static ensureNative(List list) => list;  // TODO: make sure.
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(rnystrom): add a way to supress public classes from DartDoc output.
// TODO(jacobr): we can remove this class now that we are using the $dom_
// convention for deprecated methods rather than truly private methods.
/**
 * This class is intended for testing purposes only.
 */
class Testing {
  static void addEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    target.$dom_addEventListener(type, listener, useCapture);
  }
  static void removeEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    target.$dom_removeEventListener(type, listener, useCapture);
  }

}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Utils for device detection.
 */
class _Device {
  /**
   * Gets the browser's user agent. Using this function allows tests to inject
   * the user agent.
   * Returns the user agent.
   */
  static String get userAgent => window.navigator.userAgent;

  /**
   * Determines if the current device is running Opera.
   */
  static bool get isOpera => userAgent.contains("Opera", 0);

  /**
   * Determines if the current device is running Internet Explorer.
   */
  static bool get isIE => !isOpera && userAgent.contains("MSIE", 0);

  /**
   * Determines if the current device is running Firefox.
   */
  static bool get isFirefox => userAgent.contains("Firefox", 0);

  /**
   * Determines if the current device is running WebKit.
   */
  static bool get isWebKit => !isOpera && userAgent.contains("WebKit", 0);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Iterator for arrays with fixed size.
class _FixedSizeListIterator<T> extends _VariableSizeListIterator<T> {
  _FixedSizeListIterator(List<T> array)
      : super(array),
        _length = array.length;

  bool get hasNext => _length > _pos;

  final int _length;  // Cache array length for faster access.
}

// Iterator for arrays with variable size.
class _VariableSizeListIterator<T> implements Iterator<T> {
  _VariableSizeListIterator(List<T> array)
      : _array = array,
        _pos = 0;

  bool get hasNext => _array.length > _pos;

  T next() {
    if (!hasNext) {
      throw new StateError("No more elements");
    }
    return _array[_pos++];
  }

  final List<T> _array;
  int _pos;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _Lists {

  /**
   * Returns the index in the array [a] of the given [element], starting
   * the search at index [startIndex] to [endIndex] (exclusive).
   * Returns -1 if [element] is not found.
   */
  static int indexOf(List a,
                     Object element,
                     int startIndex,
                     int endIndex) {
    if (startIndex >= a.length) {
      return -1;
    }
    if (startIndex < 0) {
      startIndex = 0;
    }
    for (int i = startIndex; i < endIndex; i++) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the last index in the array [a] of the given [element], starting
   * the search at index [startIndex] to 0.
   * Returns -1 if [element] is not found.
   */
  static int lastIndexOf(List a, Object element, int startIndex) {
    if (startIndex < 0) {
      return -1;
    }
    if (startIndex >= a.length) {
      startIndex = a.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns a sub list copy of this list, from [start] to
   * [:start + length:].
   * Returns an empty list if [length] is 0.
   * Throws an [ArgumentError] if [length] is negative.
   * Throws a [RangeError] if [start] or [:start + length:] are out of range.
   */
  static List getRange(List a, int start, int length, List accumulator) {
    if (length < 0) throw new ArgumentError('length');
    if (start < 0) throw new RangeError.value(start);
    int end = start + length;
    if (end > a.length) throw new RangeError.value(end);
    for (int i = start; i < end; i++) {
      accumulator.add(a[i]);
    }
    return accumulator;
  }
}
