  // -- start List<$E> mixins.
  // $E is the element type.

  // From Iterable<$E>:

  Iterator<$E> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new FixedSizeListIterator<$E>(this);
  }

  // From Collection<$E>:
$if DEFINE_LENGTH_AS_NUM_ITEMS
  // SVG Collections expose numberOfItems rather than length.
  int get length => numberOfItems;
$endif

  void add($E value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addLast($E value) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  void addAll(Collection<$E> collection) {
    throw new UnsupportedError("Cannot add to immutable List.");
  }

  dynamic reduce(dynamic initialValue, dynamic combine(dynamic, $E)) {
    return Collections.reduce(this, initialValue, combine);
  }

$if DEFINE_CONTAINS
  bool contains($E element) => Collections.contains(this, element);
$else
  // contains() defined by IDL.
$endif

  void forEach(void f($E element)) => Collections.forEach(this, f);

  Collection map(f($E element)) => Collections.map(this, [], f);

  Collection<$E> filter(bool f($E element)) =>
     Collections.filter(this, <$E>[], f);

  bool every(bool f($E element)) => Collections.every(this, f);

  bool some(bool f($E element)) => Collections.some(this, f);

  bool get isEmpty => this.length == 0;

  // From List<$E>:
$if DEFINE_LENGTH_SETTER
  void set length(int value) {
    throw new UnsupportedError("Cannot resize immutable List.");
  }
$endif

$if DEFINE_CLEAR
  void clear() {
    throw new UnsupportedError("Cannot clear immutable List.");
  }
$else
  // contains() defined by IDL.
$endif

  void sort([Comparator compare = Comparable.compare]) {
    throw new UnsupportedError("Cannot sort immutable List.");
  }

  int indexOf($E element, [int start = 0]) =>
      Lists.indexOf(this, element, start, this.length);

  int lastIndexOf($E element, [int start]) {
    if (start == null) start = length - 1;
    return Lists.lastIndexOf(this, element, start);
  }

  $E get first => this[0];

  $E get last => this[length - 1];

  $E removeAt(int pos) {
    throw new UnsupportedError("Cannot removeAt on immutable List.");
  }

  $E removeLast() {
    throw new UnsupportedError("Cannot removeLast on immutable List.");
  }

  void setRange(int start, int rangeLength, List<$E> from, [int startFrom]) {
    throw new UnsupportedError("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedError("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [$E initialValue]) {
    throw new UnsupportedError("Cannot insertRange on immutable List.");
  }

  List<$E> getRange(int start, int rangeLength) =>
      Lists.getRange(this, start, rangeLength, <$E>[]);

  // -- end List<$E> mixins.
